{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"ABOUT","text":"所有博客均已同步至我在语雀的博客专栏：一大堆数据 关于我一颗荔枝味的汤圆，95 后，一个还在各种挣扎的硕士生。 本科：郑州大学，计算机科学与技术专业 硕士：上海科技大学，计算机科学与技术专业 研究领域：Multi-* Learning. 喜欢不务正业。 经常出没于下述场所： Github 知乎 B 站 Zhiwei Li 一颗荔枝味汤圆 一颗荔枝味汤圆 ABOUT MEMr. Lychee, born after 95s, who now is a struggling master student. He received the B.E. degree in Computer Science and Technology from Zhengzhou University, China, in 2020. Now He is studying in Computer Science and Technology at Shanghaitech University, China, and will graduate in 2023. Research Interests: Multi-* learning, Machine Learning You can find him in these websites: Github Zhihu Bilibili Zhiwei Li Takit Takit FRIEND LINKS 王政乔 糖醋鱼","link":"/about/index.html"},{"title":"CATERGORY","text":"","link":"/categories/index.html"},{"title":"TAG","text":"","link":"/tags/index.html"}],"posts":[{"title":"二分查找法","text":"二分查找法最近学校事比较多，自己好久没写过 JAVA 了，趁着这次开《算法图解》，可以好好的把 JAVA 基础再过一遍。 开始之前毕竟是《算法图解》的笔记，所以正好把算法是什么也解释一下吧。 算法是一组完成任务的指令。 —-《算法图解》 嗯，就是这个样子（嘿嘿嘿）。 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。 ​ —-摘自百度百科词条“算法” 根据百度百科中对“算法”的解释，可以看出算法就是为了能够更好更优的解决问题而存在的，简单来说就是使程序运行速度更快，占的空间更小。 二分查找 二分查找是一种算法，其输入是一个有序的元素列表。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。 —-《算法图解》 _有序_：是为了在查找时，让数据有序可循，以便于直知道二分点的数据与要查找的数据之间的关系。 二分查找的时间复杂度是 O(logn) 程序主体123456789101112131415161718192021int binary_search(int[] arr, int n) { int low = 0; //查找范围的头部位置 int high = arr.length - 1; //查找范围的尾部位置 int mid; //二分点 while(low &lt; high) { //如果low &lt; high，则始终进行比较，直到找到该数或low &gt;= high mid = (low + high) / 2; if(n == arr[mid]) { //若找到该数，则将该处位置返回，结束查找 return mid; }else if(n &gt; arr[mid]) { //若二分点的数字小于目标数 low = mid + 1; }else if(n &lt; arr[mid] ) { //若二分点的数字大于目标数 high = mid - 1; } } return -1; //若始终没能查到目标数字，则返回-1，证明该数字不存在 }","link":"/2021/06/08/Courses/2017-11-25-binary-find/"},{"title":"求二叉树两结点最近的共同祖先结点","text":"求二叉树两结点最近的共同祖先结点题目要求及思路分析 题目要求：已知在二叉树中，_ root 为根结点，_ p 和* q 为二叉树中两个结点，试编写求距离它们最近的共同祖先的算法。 —《数据结构习题集（C 语言版）》 思路： 显然在这个题目中，递归遍历不适用。同时先中后三种顺序，先序遍历比较合适。 要利用栈的特性来存储访问目标结点的路径，以便于最后查找它的祖先结点。 当* p 和* q 的路径都找到后，我们可以看到根结点在栈底，而目标结点在栈顶，这样的话不利于我们比较两条路径上共同的祖先结点。所以，要将两个目标结点的路径栈逆置，使栈顶元素都为根结点，这样在出栈的时候可以比较两个栈顶元素指向的结点。直到出现第一个不同的结点时，取上一个出栈元素，即为距两目标结点最近的共同祖先结点。 算法实现 两种数据类型的结构体定义 123456789101112131415161718192021/*-------二叉树的二叉链结点结构定义------*/#define TElemType chartypedef struct BiTNode{ // 结点结构 TElemType data; // 结点数据 struct BiTNode *lchild, *rchild; // 左右 孩子指针} BiTNode, *BiTree;/------栈的数据结构预定义------/define MAXSIZE 100 // 存储空间初始分配量 typedef struct{ BiTree data[MAXSIZE]; int top; //用于栈顶指针 }SqStack;/---------------------------/ 用到的栈的基本操作函数 12345678910111213141516171819/*-------栈的基本操作函数-------*/ Status Push(SqStack *S, BiTree e){ //插入元素e 为新的栈顶元素 if (S-&gt;top = MAXSIZE - 1)return ERROR; S-&gt;top++; S-&gt;data[S-&gt;top] = e; //将新插入元素赋值给栈顶空间 return OK; } BiTree Pop(SqStack *S){ //若栈不空，则删除S的栈顶元素，用e返回其值，变返回oK;否则返回ERROR if (S-&gt;top == -1)return ERROR; BiTree e = S-&gt;data[S-&gt;top]; //将要删除的栈顶元素赋给e S-&gt;top--; //栈顶指针减一 return e; } //pop /*-----栈的基本操作函数结束-----*/ 用到的树的基本操作函数 123456789101112131415161718192021222324252627282930313233343536/*------树的基本操作的函数------*///按照二叉树的定义初始化一个空树Status InitBiTree(BiTree *bt){ *bt = (BiTree)malloc(sizeof(BiTNode)); if (!bt)return OVERFLOW; *bt = NULL; return OK;}//构造二叉链表表示的二叉树T//按先序次序输入二叉树中结点的值（一个字符）,空格字符表示空树Status CreateBiTree(BiTree *T){ TElemType ch; printf_s(&quot;请输入数据：&quot;); scanf_s(&quot;%c&quot;, &amp;ch); getchar(); //getchar()用于处理回车占字符的问题 if (ch == '#') *T = NULL; else{ *T = (BiTree)malloc(sizeof(BiTNode)); if (!T)return OVERFLOW; // 若内存分配失败，则返回OVERFLOW (*T)-&gt;data = ch; // 生成根结点 CreateBiTree(&amp;((*T)-&gt;lchild)); //构建左子树 CreateBiTree(&amp;((*T)-&gt;rchild)); //构建右子树 } return OK;}/*----树的基本操作的函数结束----*/ 利用栈来存储访问目标结点的路径 12345678910111213141516171819202122232425262728293031323334/*求距两个子结点最近的共同祖先结点*/Status FindPath(BiTree root, BiTree target, SqStack *path){ SqStack* s; s = (SqStack *)malloc(sizeof(SqStack)); BiTree node = root; while (1){ Push(path, node); //将当前结点入栈 if (node == target)return OK; //若当前结点即为目标结点，则可直接结束 //若左孩子存在，则再看右孩子。若右孩子也存在，将右孩子存入栈s；若右孩子不存在，则直接访问下一个左孩子。 //若左孩子不存在，则访问右孩子。若左右孩子都不存在，则去查看栈s中的栈顶元素所指结点。 //重复操作，直到找到目标结点。这时栈path中存储的元素为访问到目标结点的所有元素。 if (node-&gt;lchild){ if (node-&gt;rchild){ Push(s, node-&gt;rchild); } node = node-&gt;lchild; }else if (node-&gt;rchild){ node = node-&gt;rchild; }else if (s){ while (path-&gt;data[path-&gt;top]-&gt;rchild != s-&gt;data[s-&gt;top]){ Pop(path); } node = s-&gt;data[s-&gt;top]; Pop(s); }else{ break; } } return OK;} 对* p、* q 分别调用第 4 步中的函数，将得到的两个路径栈逆置，在逆置后的栈中出栈顶元素同时进行比较，得到公共祖先结点 1234567891011121314151617181920212223242526Status CommentParent(BiTree* parent, BiTree root, BiTree p, BiTree q){ SqStack *path_p, *path_q; path_p = (SqStack *)malloc(sizeof(SqStack)); path_q = (SqStack *)malloc(sizeof(SqStack)); FindPath(root, p, path_p); FindPath(root, q, path_q); SqStack *reverse_p, *reverse_q; reverse_p = (SqStack *)malloc(sizeof(SqStack)); reverse_q = (SqStack *)malloc(sizeof(SqStack)); while (path_p){ Push(reverse_p, Pop(path_p)); } while (path_q){ Push(reverse_q, Pop(path_q)); } while (reverse_p-&gt;data[reverse_p-&gt;top] == reverse_q-&gt;data[reverse_q-&gt;top]){ *parent = reverse_p-&gt;data[reverse_p-&gt;top]; Pop(reverse_p); Pop(reverse_q); } return OK;} ​","link":"/2021/06/08/Courses/2017-11-27-common-father/"},{"title":"判断是否为完全二叉树","text":"判断是否为完全二叉树题目要求及思路分析 题目：编写算法判别给定二叉树是否为完全二叉树。 —《数据结构习题集（C 语言版）》 思路： 使用层序遍历二叉树 若完全二叉树中的某个结点没有左孩子，则其一定没有右孩子 若完全二叉树中的某个结点缺左孩子或右孩子，则其一定没有后继结点 算法实现 二叉树及队列的结构体定义 1234567891011121314151617/*-------二叉树的二叉链结点结构定义------*/#define TElemType chartypedef struct BiTNode{ // 结点结构 TElemType data; // 结点数据 struct BiTNode *lchild, *rchild; // 左右 孩子指针} BiTNode, *BiTree;/*-------队列的数据结构定义------*/#define MAXSIZE 1000typedef struct { BiTree data[MAXSIZE]; int front; int rear;}SqQueue; 队列的基本操作 12345678910111213141516171819202122232425262728293031323334/*----------以下为队列的基本操作函数----------*//*初始化一个空队列*/Status InitQueue(SqQueue *Q){ if (!Q)return ERROR; //若空间分配失败，则返回ERROR Q-&gt;front = 0; Q-&gt;rear = 0; return OK;}/*判断SqQueue是否为空*/Status IsQueueEmpty(SqQueue Q){ if (Q.rear == Q.front)return TRUE; //若尾指针指向头指针，则为空队列，返回TRUE else{ return FALSE; } //否则返回FALSE}/*插入元素e为新的队尾元素*/Status EnQueue(SqQueue *Q, BiTree e){ if ((Q-&gt;rear + 1) == MAXSIZE)return ERROR; // 若队列已满，则返回ERROR Q-&gt;data[Q-&gt;rear] = e; //e 入队列 Q-&gt;rear = (Q-&gt;rear + 1); //队尾指针后移 return OK;}/*若队列不空，则删除队头元素，并用e返回其值*/Status DeQueue(SqQueue *Q, BiTree *e){ if (Q-&gt;front == Q-&gt;rear)return ERROR; //若队列为空，则返回ERROR *e = Q-&gt;data[Q-&gt;front]; //若队列不为空，用e接收队头元素 Q-&gt;front = Q-&gt;front + 1; //队头指针后移 return OK;}/*----------队列的基本操作函数结束----------*/ 二叉树的基本操作 1234567891011121314151617181920212223242526272829303132333435/*-----------基本操作的函数-------------*///按照二叉树的定义初始化一个空树Status InitBiTree(BiTree *bt){ *bt = (BiTree )malloc(sizeof(BiTNode)); if (!bt)return OVERFLOW; *bt = NULL; return OK;}//构造二叉链表表示的二叉树T//按先序次序输入二叉树中结点的值（一个字符）,空格字符表示空树Status CreateBiTree(BiTree *T){ TElemType ch; printf_s(&quot;请输入数据：&quot;); scanf_s(&quot;%c&quot;, &amp;ch); getchar(); //getchar()用于处理回车占字符的问题 if (ch == '#') *T = NULL; else{ *T = (BiTree)malloc(sizeof(BiTNode)); if (!T)return OVERFLOW; // 若内存分配失败，则返回OVERFLOW (*T)-&gt;data = ch; // 生成根结点 CreateBiTree(&amp;((*T)-&gt;lchild)); //构建左子树 CreateBiTree(&amp;((*T)-&gt;rchild)); //构建右子树 } return OK;} 判断二叉树是否为完全二叉树 12345678910111213141516171819202122232425262728Status IsCompleteBiTree(BiTree T){ if (!T)return TRUE; // 若为一个空树，则直接结束 int flag = 0; //设立一个flag，若某结点有左右孩子则为0;若某一个空了，则为1 SqQueue Q; BiTree* e; e = (BiTree *)malloc(sizeof(BiTree)); InitQueue(&amp;Q); EnQueue(&amp;Q, T); //将根结点入队列 while (DeQueue(&amp;Q, e)){ //当队列不空时 if (!(*e)){ //若当前元素为空，则flag = 1，直接进行下一个循环 flag = 1; continue; }else if (flag){ //若当前元素不为空，且flag == 1，则证明该数不为完全二叉树 return FALSE; }else{ EnQueue(&amp;Q, (*e)-&gt;lchild); EnQueue(&amp;Q, (*e)-&gt;rchild); } } printf_s(&quot;\\n&quot;); return TRUE;} ​","link":"/2021/06/08/Courses/2017-11-27-complete-binary-tree/"},{"title":"选择排序法","text":"选择排序法分析 假设已经给定了一个无序数组，现在需要将其按照一定顺序排好。现在我们使用选择排序法，每次从数组中选出一个最大的元素并将其与数组最后一个元素交换位置，使数组最后一个元素变为最大的。 随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一个。既然如此，运行时间怎么还是O(n2)呢？这个问题问得好，这与大 O 表示法中的常数相关。第 4 章将详细解释，这里只简单地说一说。 你说得没错，并非每次都需要检查n个元素。第一次需要检查n个元素，但随后检查的元素数依次为n - 1, n – 2, …, 2 和 1。平均每次检查的元素数为 1/2 × _n_，因此运行时间为O(n × 1/2 × n)。但大 O 表示法省略诸如 1/2 这样的常数（有关这方面的完整讨论，请参阅第 4 章），因此简单地写作O(n × n)或O(n2)。 ​ — 《算法图解》 代码实现C 语言实现因为 C 中对数组的删除比较麻烦，所以我没有按照《算法图解》中的思路每次选择最小的元素，而是选择了最大的。 12345678910111213141516171819void SelectionSort(int arr[], int length){ //C在函数中传数组长度较为麻烦，所以在数组定义出就将长度定义好传了过来 int i, temp,biggest_index = 0; while (length){ biggest_index = 0; for (i = 0; i &lt; length; i++){ if (arr[biggest_index] &lt; arr[i]){ biggest_index = i; } } printf(&quot;%d\\n&quot;, arr[biggest_index]); temp = arr[biggest_index]; arr[biggest_index] = arr[length - 1]; arr[length -1] = temp; length --; }} JAVA 语言实现JAVA 实现思路同 C。 1234567891011121314151617181920public int[] SelectionSort(int[] arr) { int length = arr.length; int biggestIndex; int i, temp; while(length &gt; 0) { biggestIndex = 0; for(i = 0; i &lt; length; i ++) { if(arr[biggestIndex] &lt; arr[i]) { biggestIndex = i; } } temp = arr[biggestIndex]; arr[biggestIndex] = arr[length - 1]; arr[length - 1] = temp; System.out.println(arr[length - 1]); length --; } return arr; }","link":"/2021/06/08/Courses/2017-12-02-sort/"},{"title":"图的基本操作","text":"图的基本操作图这一章我一直觉得自己学的不是很好。。。这次就只放代码，不敢多说什么了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef char VertexType; //顶点类型应由用户定义typedef int EdgeType; //边上的权值类型应由用户定义#define MAXVEX 100typedef struct EdgeNode{ //边表结点 int adjvex; //邻接点域，存储该顶点对应的下标 EdgeType weight; //用于存储权值，对于非网图可以不需要 struct EdgeNode *next; //链域，指向下一个邻接点}EdgeNode;typedef struct VertexNode{ //顶点表结点 VertexType data; //顶点域 EdgeNode *firstedge; //边表头指针}VertexNode, AdjList[MAXVEX];typedef struct{ AdjList adjList; int numVertexes, numEdges; //图中当前顶点数和边数}GraphAdjList;/*头插法建立图的邻接表结构*/void CreatALGraph(GraphAdjList *G){ int i, j, k; EdgeNode *e; printf(&quot;请输入顶点数和边数:&quot;); scanf(&quot;%d, %d&quot;, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); //输入顶点数和边数 for (i = 0; i &lt; G-&gt;numVertexes; i++){ //读入顶点信息，建立顶点表 scanf(&quot;%c&quot;, &amp;G-&gt;adjList[i].data); //输入顶点信息 G-&gt;adjList[i].firstedge = NULL; //将边表置为空表 } for (k = 0; k &lt; G-&gt;numEdges; k++){ //建立边表 printf(&quot;输入(vi, vj)上的顶点序号：\\n&quot;); scanf(&quot;%d, %d&quot;, &amp;i, &amp;j); //输入(vi, vj)上的顶点序号 e = (EdgeNode *)malloc(sizeof(EdgeNode)); //向内存申请空间 e-&gt;adjvex = j; //邻接序号为j e-&gt;next = G-&gt;adjList[i].firstedge; //将e指针指向当前顶点所指向的结点 G-&gt;adjList[i].firstedge = e; //将当前顶点的指针指向e e = (EdgeNode *)malloc(sizeof(EdgeNode)); //向内存申请空间,生成边表结点 e-&gt;adjvex = i; //邻接序号为i e-&gt;next = G-&gt;adjList[j].firstedge; //将e指针指向当前顶点指向的结点 G-&gt;adjList[j].firstedge = e; //将当前顶点的指针指向e }}","link":"/2021/06/08/Courses/2017-12-17-basic-operation-of-graph/"},{"title":"图的广度优先遍历","text":"图的广度优先遍历图这一章我一直觉得自己没学好。。。所以这次就直接放代码，不多说什么了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576typedef int Boolean; //Boolean是布尔类型，其值为TRUE 或者FLASEBoolean visited[MAXVEX]; //访问标志的数组#define QElemType int // 元素类型定义为图结点#define MAXSIZE 1000typedef struct { QElemType data[MAXSIZE]; int front; int rear;}SqQueue;/*----------以下为队列的基本操作函数----------*//*初始化一个空队列*/Status InitQueue(SqQueue *Q){ if (!Q)return ERROR; //若空间分配失败，则返回ERROR Q-&gt;front = 0; Q-&gt;rear = 0; return OK;}/*判断SqQueue是否为空*/Status IsQueueEmpty(SqQueue Q){ if (Q.rear == Q.front)return TRUE; //若尾指针指向头指针，则为空队列，返回TRUE else{ return FALSE; } //否则返回FALSE}/*插入元素e为新的队尾元素*/Status EnQueue(SqQueue *Q, QElemType e){ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)return ERROR; // 若队列已满，则返回ERROR Q-&gt;data[Q-&gt;rear] = e; //e 入队列 Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; //队尾指针后移 return OK;}/*若队列不空，则删除队头元素，并用e返回其值*/Status DeQueue(SqQueue *Q, QElemType *e){ if (Q-&gt;front == Q-&gt;rear)return ERROR; //若队列为空，则返回ERROR *e = Q-&gt;data[Q-&gt;front]; //若队列不为空，用e接收队头元素 Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; //队头指针后移 return OK;}/*----------队列的基本操作函数完----------*//*----------以下为广度优先遍历算法---------*/void BFSTraverse(GraphAdjList G){ int i; SqQueue Q; EdgeNode* p; for (i = 0; i &lt; G.numVertexes; i++){ visited[i] = FALSE; } InitQueue(&amp;Q); //初始化一辅助用的队列 for (i = 0; i &lt; G.numVertexes; i++){ //对每一个顶点做循环 if (!visited[i]){ //若未访问过，则如下处理 visited[i] = TRUE; //将当前结点设为已访问 printf(&quot;%c&quot;, G.adjList[i].data);//打印顶点，也可以改为其它操作 EnQueue(&amp;Q, i); //将该顶点入队列 while (!IsQueueEmpty(Q)){ DeQueue(&amp;Q, &amp;i); //将队头元素出队，并赋给e p = G.adjList[i].firstedge; //找到当前顶点边表头指针 while (p){ if (!visited[p-&gt;adjvex]){//若当前结点未被访问过 printf(&quot;%c&quot;, G.adjList[p-&gt;adjvex].data); EnQueue(&amp;Q, p-&gt;adjvex); } p = p-&gt;next; //指针指向下一个邻接点 } } } }}","link":"/2021/06/08/Courses/2017-12-17-bfs/"},{"title":"图的深度优先遍历","text":"图的深度优先遍历图这一章我一直觉得自己学的不是很好。。。这次就只放代码，不敢多说什么了。 1234567891011121314151617181920212223242526typedef int Boolean; //Boolean是布尔类型，其值为TRUE 或者FLASEBoolean visited[MAXVEX]; //访问标志的数组/*邻接矩阵的深度优先递归算法*/void DFS(GraphAdjList G, int i){ EdgeNode *p; visited[i] = TRUE; printf(&quot;%c&quot;, G.adjList[i].data); //打印定点，也可以是其它操作 p = G.adjList[i].firstedge; while (p){ if (!visited[p-&gt;adjvex])DFS(G, p-&gt;adjvex); //对未访问的邻接顶点递归调用 p = p-&gt;next; }}/*邻接矩阵的深度遍历操作*/void DFSTraverse(GraphAdjList G){ int i; for (i = 0; i &lt; G.numVertexes; i++){ visited[i] = FALSE; //初始化所有顶点状态都是未访问的状态 } for (i = 0; i &lt; G.numVertexes; i++){ if (!visited[i])DFS(G, i); //对未访问过的顶点调用DFS，若连通图，只会执行一次 }}","link":"/2021/06/08/Courses/2017-12-17-dfs/"},{"title":"电路交换与分组交换","text":"一、电路交换与分组交换 电路交换 定义：电路交换是以电路连接为目的的交换方式。通信之前要在通信两方之间建立一条被两方独占的物理通道。 三个阶段： 建立连接 通信 释放连接 优点： 因为通信线路为通信两方用户专用，数据直达。所以数据传输的时延非常小； 通信两方之间的屋里通路一旦建立，两方能够随时通信，实时性强； 两方通信时按发送顺序传送数据，不存在失序问题； 电路交换既适用于传输模拟信号，也适用于传输数字信号； 电路交换的交换设备及控制均比较简单。 缺点： 电路交换平均连接建立时间对计算机通信来说较长； 电路交换家里连接后，物理通路被通信两方独占，即使通信线路空暇，也不能供其它用户使用，因而信道利用率低； 电路交换时，数据直达。不同类型、不同规格、不同速率的终端非常难相互进行通信，也难以在通信过程中进行差错控制。 分组交换 定义：分组交换是以分组为单位进行传输和交换的，它是一种存储——转发交换方式。即将到达交换机的分组先送到存储器临时存储和处理，等到对应的输出电路有空暇时再送出。 长处： 分组交换不须要为通信双反预先建立一条专用的通信线路。不存在连接建立时延，用户可随时发送分组； 因为采用存储转发方式，加之交换节点具有路径选择，当某条传输线路故障时可选择其它传输线路，提高了传输的可靠性； 通信双方不是固定地占用一条通信线路，而是在不同的时间一段一段地部分占用这条物理通路，因而大大提高了通信线路的利用率； 加速了数据在网络中的传输。因为分组是逐个传输，能够使后一个分组的存储操作与前一个分组的转发操作并行。这样的流水线式传输方式降低了传输时间，提升了效率； 分组长度固定，对应的缓冲区的大小也固定，所以简化了交换节点中存储器的管理； 分组较短，出错几率降低，每次重发的数据量也降低，不仅提高了可靠性，也降低了时延。 缺点： 因为数据进入交换节点后要经历存储转发这一过程，从而引起的转发时延（包含接受分组、检验正确性、排队、发送时间等），并且网络的通信量越大，造成的时延就越大。实时性较差； 分组交换仅仅适用于数字信号； 分组交换可能出现失序，丢失或反复分组。分组到达目的节点时，对分组按编号进行排序等工作添加了麻烦。 综上，若传输的数据量非常大，并且传送时间远大于呼叫时间。则采用电路交换较为合适；当端到端的通路有非常多段链路组成时，采用分组交换较为合适。从提高整个网络的信道利用率上看，分组交换优于电路交换。 二、协议及其三要素协议 定义：网络协议(Network protocol)： 为进行网络中的数据交换而建立的规则、标准或约定。 作用：协议明确规定了所交换的数据的格式以及有关的同步问题 组成三要素 语法，即数据与控制信息的结构或格式； 语义，即需要发出何种控制信息，完成何种动作以及做出何种响应: 同步，即事件实现顺序的详细说明。 协议为什么分层？协议各层次的功能 差错控制：使相应层次对等方的通信更加可靠。 流量控制：发送端的发送速率必须使接收端来得及接收，不要太快。 分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。 复用和分用：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。 连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。 协议为什么分层 各层之间是独立的。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口(即界面)所提供的服务。由于每一层只实现一种相对独立的功能，因而可将一个难以处理的复杂问题分解为若干个较容易处理的更小一些的问题。这样，整个问题的复杂程度就下降了。 灵活性好。当任何一层发生变化时(例如由于技术的变化)，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某 → 层提供的服务还可进行修改。当某层提供的服务不再需要时，甚至可以将这层取消。 结构上可分割开。各层都可以采用最合适的技术来实现。 易于实现和维护。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统己被分解为若干个相对独立的子系统。 易于实现和维护。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统己被分解为若干个相对独立的子系统。 分层的缺点有些功能会在不同的层次中重复出现，因而产生了额外开销。 什么是计算机网络体系结构？ 网络的体系结构(architecure)：计算机网络的各层及其协议的集合，是这个计算机网络及其构件所应完成的功能的精确定义。 体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。 具有五层协议的体系结构 应用层 任务：是通过应用进程间的交互来完成特定网络应用。 协议：应用层协议定义的是应用进程间通信和交互的规则。 报文：应用层交互的数据单元 运输层 任务：负责向两台主机中进程之间的通信提供通用的数据传输服务 协议： 传输控制协议 TCP (Transmission Control Protocol)一一提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段(segment)。 用户数据报协议 UDP (User Datagram Protocol)– 提供无连接的、尽最大努力(best-effort) 的数据传输服务(不保证数据传输的可靠性)，其数据传输的单位是用户数据报。 网络层 任务：网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。 协议：使用 IP 协议 数据链路层任务：在两个相邻结点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧(framing) ，在两个相邻结点间的链路上传送帧(frame) 。每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。 物理层任务： 在物理层上所传数据的单位是比特。 物理层要考虑用多大的电压代表 “1”或”0” ，以及接收方如何识别出发送方所发送的比特。 物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。 协议与服务的关系 实体(entity)：任何可发送或接收信息的硬件或软件进程 协议：控制两个对等实体(或多个实体)进行通信的规则的集合 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。 协议是”水平的“，即协议是控制对等实体之间通信的规则。但服务是”垂直的“，即服务是由下层向上层通过层间接口提供的。另外，并非在一个层内完成的全部功能都称为服务。只有那些能够被高一层实体”看得见”的功能才能称之为”服务”。","link":"/2021/06/08/Courses/2019-03-17-computer-network-chp-1/"},{"title":"物理层","text":"物理层 首先强调指出，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体 物理层的基本概念 物理层的主要任务：确定与传输媒体的接口有关的一些特性 机械特性：指明接口所用接线器的形状和尺寸，引脚数目和排列，固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压的范围 功能特性：指明某条线上出现的某一电平的电压表示何种意义 过程特性：指明对于不同功能的各种可能事件的出现顺序 串行传输：数据在通信线路（传输媒体）上的传输方式一般都是串行传输，即逐个比特按照时间顺序传输。因此物理层还要完成传输方式的转换。 数据通信的基础知识数据通信系统的三大部分 源系统（发送端、发送方） _源点_：源点设备产生要传输的数据，又称为源站或信源 _发送器_： 通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。 典型的发送器就是调制器。 传输系统（传输网络） 目的系统（接收端、接收方） _接收器_： 接受传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。 典型的接收器就是解调器 _终点_：终点设备从接收器获取传送来的数字比特流，然后把信息输出，又称为目的站或信宿 常用术语： 通信：目的是传送消息（Message），如话音、文字、图像、视频等 数据：是运送信息的实体，通常是有意义的符号序列 信号：是数据的电气或电磁的表现，根据信号中代表信息的参数的取值方式不同，信号可分为两大类： _模拟信号_（连续信号）——代表信息的参数的取值是连续的 _数字信号_（离散信号）——代表信息的参数的取值是离散的 码元：在使用时间域（或简称为时域）的波形表示数字信号时，则代表不同离散数值的基本波形 信道信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接受信道。 从通信的双方信息交互的方式来看，可以有以下三种基本方式： 单向通信（单工通信）：即只能有一个方向的通信而没有反方向的交互，例如电视广播 双向交替通信（半双工通信）：即通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收），是一方发送，另一方接收，过一段时间后再反过来 双向同时通信（全双工通信）：即通信的双方可以同时发送和接收信息 基带信号：来自信源的信号。基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。所以，必须对基带信号进行调制。 调制： 基带调制：仅仅对基带信号的波形进行变换，使它能够与信道特性相适应，变换后信号仍然是基带信号。因此大家更愿意把这种过程称为编码。 带通调制：需要使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为带通信号（即仅在一段频率范围内能够通过信道）。 常用编码方式 不归零制：正电平代表 1，负电平代表 0 归零制：正脉冲代笔哦啊 1，负脉冲代表 0 曼切斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1，也可以反过来定义 差分曼切斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1 基本的带通调制方法 调幅（AM）：即载波的振幅随基带数字信号而变化，例如，0 或 1 分别对应于无载波或有载波输出 调频（FM）：即载波的频率随基带数字信号而变化，例如，0 或 1 分别对应于频率 f1 或 f2 调相（PM）：即载波的初始相位随基带数字信号而，例如，0 或 1 分别对应于相位 0 度或 180 度 信道的极限容量码元传输的速率越高，或信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形的失真就越严重。从概念上讲，限制码元在信道上的传输速率有以下两个： 信道能够通过的频率范围 码间串扰： 在接收端收到的信号波形失去了码元之间的清晰界限。 奈氏准则：在任何信道中，码元传输的速率是有上限的，传输速率超过次上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。 如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。 信噪比 信噪比： 信号的平均功率和噪声的平均功率之比，常记为 S/N，并用分贝（dB）作为度量单位。 即：信噪比(dB) = 10 log10(S/N) (dB) 香农公式： 信道的极限信息传输速率 C 是:C = W log2(1+S/N) (bit/s) W为信道的带宽（以 Hz 为单位）；S为信道内所传信号的平均功率；N为信道内部的高斯噪声功率。 香农公式表明：信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。 香农公式的意义：只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 除此之外，还有一个提高信息的传输速率的方法，就是用编码的方法让每一个码元携带更多比特的信息量 物理层下面的传输媒体传输媒体传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。 导引型传输媒体：电磁波被导引沿着固定媒体（铜线或光纤）传播 非导引型传输媒体：指自由空间，常称为无线传输 导引型传输媒体 双绞线： 把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合起来就构成双绞线。 它是最古老但又是最常用的传输媒体。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。导线越粗，其通信距离就越远，但导线的价格也越高 为了提高双绞线的抗电磁干扰的能力，可以在双绞线外面再加上一层用金属丝编织成的屏蔽层，也就是屏蔽双绞线，简称 STP，价格比无屏蔽双绞线 UTP 要贵一些 现在常用的 UTP 是 5 类线 直通：A——A 异类相接 B——B 交叉：A——B 同类相接 序号 1 2 3 4 5 6 7 8 A 序 绿白 绿 橙白 蓝 蓝白 橙 棕白 棕 B 序 橙白 橙 绿白 蓝 蓝白 绿 棕白 棕 同轴电缆：由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及保护塑料外层所组成。 同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。 同轴电缆的带宽取决于电缆的质量。 50 欧姆：粗，LAN/数字传输常用 75 欧姆：细，有线电视/模拟传输常用 光缆：光纤通信就是利用光导纤维传递光脉冲来进行通信，有光脉冲相当于 1，没有光脉冲相当于 0。 光纤是光纤通信的传输媒体。 多模光纤：可以存在多条不同角度入射的光纤在一条光钎中传输 单模光钎：光钎的直径减小到只有一个光的波长，则光钎就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射 在光钎通信中常用的三个波段的中心分别位于 850nm，1310nm 和 1550nm。所以这三个波段都具有 25000-30000GHz 的宽带 光钎的优点： 通信容量大； 传输损耗小，中继距离长，对远距离传输特别经济； 抗雷电和电磁干扰性能好，这在有大电流脉冲干扰的环境下尤为重要； 无串音干扰，保密性好，也不易被窃听或截取数据； 体积小，重量轻，这在现有电缆管道已拥塞不堪的情况下特别有利。 信道复用技术（提高信道利用率） 复用：通信技术中的基本概念 频分复用： 用户在分配到一定的频带后，在通信过程中自始自终都占用这个频带。 所有用户在同样的时间占用不同的宽带资源。 时分复用： 将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 所有用户是在不同的时间占用同样的频带宽度。 由于计算机的突发性质，用户对已经分配到的子信道的利用率一般是不高的 统计时分复用：是一种改进的时分复用，它能明显地提高信道的利用率 波分复用：光的频分复用，借用传统的载波电话的频分复用的概念，使用一根光纤来同时传送多个频率很接近的光载波信号 码分复用： 每一个用户可以在同样的时间使用同样的频带进行通信。 由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。 宽带接入技术 ADSL 技术：非对称数字用户线，是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带数字业务。 光纤同轴混合网（HFC 网）：目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传送电视节目外，还能提供电话、数据和其他宽带交互型业务。 FTTx 技术：光纤到 x 技术，这里的 x 可代表不同的光纤接入点","link":"/2021/06/08/Courses/2019-03-24-computer-network-chp2/"},{"title":"《微机原理与接口技术（第五版）》第一章","text":"第一章 本总结笔记基于钱晓捷老师的《微机原理与接口技术（第五版）》 处理器 计算集的运算和控制核心，即中央处理单元（CPU, Central Process Unit） 微处理器(Micrprocessor): 一块大规模集成电路芯片 代表着整个微型机系统的性能 _微型机_：采用微处理器为核心构造的计算机 处理器性能参数 字长：处理器每个时间单位可以处理的二进制数据位数 时钟频率：表明处理器的处理速度，反映了处理器的基本时间单位 集成度：表明处理器的生产工艺水平，通常用芯片上集成的晶体管数量来表达 摩尔定律摩尔定律：每 18 个月，集成电路的性能将提高一倍，而其价格将降低一半 处理器总线 系统总线： 用于多个部件相互连接、传递信息的公共通道 任一时刻再总线上智能传送一种信息，但可以由多个部件在接收信息 数据总线： 是处理器与存储器或外设交换信息的通道 其个数（条数）就是一次能够传送数据的二进制位数，通常等于处理器字长 处理器的数据通过该组信号线输出到主存或外设，可以双向传输信号 地址总线： 用于指定存储器或外设的具体单元 其个数反映处理器能够访问的主存储器容量或外设范围 在该组信号线上，处理器单向输出将要访问的主存单元或 I/O 端口的地址信息 控制总线： 用于协调系统中各部件的操作 控制总线决定了总线的功能强弱、适应性的好坏 各类总线的特点主要取决于其控制总线 80x86 系列处理器 _8086_： 主存容量为 2^20 B = 1 MB 80286: 主存容量为 2^32 B = 4 GB 冯·诺伊曼计算机的基本思想 采用二进制形式表示数据和指令，指令由操作码和地址码组成 指令是控制计算机操作的命令，是处理器不需要翻译就能识别（直接执行）的“母语”，即机器语言 程序是由指令构成的 指令的操作码表明指令的操作 操作数是参与操作的数据，主要以寄存器或存储器地址形式指明数据的来源，所以也称地址码 “存储程序”、“程序控制” 存储程序：把指令以代码的形式事先输入到计算机的主存储器中，这些指令按一定的规则组成程序 程序控制：当计算机启动后，程序会控制计算机按规定的顺序逐条执行指令，自动完成预定的信息处理任务 指令的执行是顺序的，即一般按照指令再存储器中存放的顺序执行，程序分支由转移指令实现 计算机由存储器、运算器、控制器、输入设备和输出设备5 大基本部件组成。 数字计算机中信息的最基本单位就是二进制位，或称比特位。 半字节：4 个二进制位 一字节：8 个二进制位 字：16 位 双字：32 位 四字：64 位 处理器的主要功能 取指：从主存储器读取指令 译码：翻译指令代码的功能 执行：执行指令所规定的操作 存储器 存储器：用来存放程序和数据的部件 _主存储器_： 造价高、速度快、容量小 用来存放当前正在运行的程序和正待处理的数据 _辅助存储器_（简称辅存或外存）: 造价低、容量大、信息可长期保存、速度慢 主要用来长久保存程序和数据 计算机系统的层次结构 _用户层_： 是计算机用户看到的计算机 呈现给用户的是可执行程序和数据文件 _高级语言层_： 面向软件程序员 _汇编语言层_： 面向系统程序员 汇编语言程序员需要利用操作系统提供的功能，掌握指令系统，理解主存储器的组织 _操作系统层_： 操作系统是最主要的系统程序，也称为系统软件层 _机器语言层_： 由处理器直接识别的指令组成，面向系统结构设计师 该层具有承上启下的功能。一方面为上层软件提供硬件指令支持，另一方面是下层硬件实现的目标 _控制层_： 面向硬件设计师 这一层由微程序实现，也可以由硬布线实现 _数字电路层_： 是计算机的具体物理实现 软件与硬件的等价性原理 原则上说，任何一个由软件所完成的操作也可以直接由硬件来实现，任何一条由硬件所执行的指令也能用软件来完成。 软件与硬件的等价性原理是指软硬件在逻辑功能上的等价，并不意味着在现实中性能和成本的等价。 软件易于实现各种逻辑和运算功能，但是往往速度较慢，甚至不能满足时间要求 硬件则可以高速实现逻辑和运算功能，但是难以实现复杂功能或计算，甚至无法实现 计算机的结构、组成与实现 计算机结构： 计算机结构是指为机器编写正确的（时间无关的）程序、机器语言程序员必须理解的一种结构。 指令集结构： 计算机结构的经典定义确定了计算机系统中软件和硬件的接口，即指令集结构 它包括指令集（指令系统）、指令格式、数据类型、寄存器、寻址方式、主存访问方式和 I/O 机制等 计算机组成： 也称为计算机组织，是计算机结构的逻辑实现（逻辑设计），对应计算机层次结构的控制层。 计算机实现： 是计算机组成物理实现，对应数字电路层 软件兼容与系列机和兼容机 软件兼容：指同一个厂家生产的具有相同计算机结构，但具有不同组成和实现的一系列不同档次、不同型号的机器。 兼容机：指不同厂家生产的具有相同计算机结构（_不同的组成和实现_）的计算机 为了保证软件的向上向下、向前向后兼容，系列机和兼容机必须保持结构不变，但这又限制了计算机结构的发展","link":"/2021/06/08/Courses/2019-05-29-the-principle-of-microcomputer-chp1/"},{"title":"数据链路层","text":"数据链路层信道分类： 点对点信道：这种信道使用一对一的点对点通信方式 广播信道：这种信道使用一对多的广播通信方式 不同的链路层可能使用不同的数据链路层协议 使用点对点的数据链路层 链路： 就是从一个结点到相邻结点的一段物理线路（有线或无线） 链路只是一条路径的组成部分 数据链路： 当需要在一条线路上传送数据时，出了必须有一条物理线路外，还必须有一些的必要的通信协议来控制这些数据的传输 一般的网络适配器都包括了数据链路层和物理层这两层的功能 若把链路分为物理链路和逻辑链路： 物理链路就是上面所说的链路 逻辑链路就是上面的数据链路，即物理链路加上必要的通信协议 帧：点对点信道的数据链路层的协议数据单元 数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。 网络层协议数据单元是IP 数据报（简称数据报、分组或包） 点对点信道的数据链路层在进行通信时的主要步骤如下： 结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧 结点 A 把封装好的帧发送给结点 B 的数据链路层 若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧 数据链路层不必考虑物理层如何实现比特传输的细节。 数据链路层协议有许多种，但有三个问题则是共同的： 封装成帧：就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧 分组交换的一个重要概念：所有在互联网上传送的数据都以分组（即 IP 数据报）为传送单位 网络层的 IP 数据报传送到数据链路层就成为帧的数据部分 在帧的数据部分的前面和后面分别添加上首部和尾部，就构成了一个完整的帧 首部和尾部一个重要作用就是进行帧定界（即确定帧的界限） 首部和尾部包括许多必要的控制信息 为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度 每一种链路层协议都规定了所能传送的帧的数据部分长度上限——最大传送单元 MTU(Maximum Transfer Unit) 透明传输 由于帧的开始和结束的标记使用专门指明的控制字符。因此，所传输的数据中的任何 8 比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，_否则就会出现帧定界的错误_。 透明是指：某一个实际存在的事物看起来却好像不存在一样 “在数据链路层透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。或者说，数据链路层对这些数据来说是透明的。 差错控制 比特差错： 比特在传输过程中可能会产生差错：1 可能变成 0，0 可能变成 1 误码率 BER(Bit Error Rate)：在一段时间内，传输错误的比特占所传输比特总数的比率 若设法提高信噪比，就可以使误码率减小 凡是接收端数据链路层接收的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程没有产生差错 接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受 也可近似地表述为“凡是接收端数据链路层接受的帧均无差错” 可靠传输：数据链路层的发送端发送什么，在接收端就收到什么 传输差错可分为两类： 一类即前面的最基本的比特差错 另一类传输差错更复杂些，虽然收到的帧没有出现比特差错，但却出现了帧丢失、帧重复或帧失序 点对点协议 PPPPPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议 PPP 协议应满足的需求 简单 接收方每收到一个帧，就进行 CRC 检验。入如 CRC 检验正确，就收下这个帧；反之，就丢弃这个帧，其他什么也不做 封装成帧 PPP 协议必须规定特殊的宇符作为帧定界符(即标志一个帧的开始和结束的字符)，以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。 透明性 PPP 协议必须保证数据传输的透明性 多种网络层协议 PPP 协议必须能够在同一条物理链路上同时支持多种网络层协议 多种类型链路 除了要支持多种网络层的协议外， PPP 还必须能够在多种类型的链路上运行 差错检测 PPP 协议必须能够对接收端收到的帧进行检测，并立即丢弃有差错的帧 检测链接状态 PPP 协议必须具有一种机制能够及时(不超过几分钟)自动检测出链路是否处于正常工作状态 最大传送单元 PPP 协议必须对每 → 种类型的点对点链路设置最大传送单元 MTU 的标准默认值。这样做是为了促进各种实现之间的互操作性 MTU 是数据链路层的帧可以载荷的数据部分的最大长度，而不是帧的总长度。 网络层地址协商 - PPP 协议必须提供一种机制使通信的两个网络层(例如，两个 IP 层)的实体能够通过协商知道或能够配置彼此的网络层地址。 10.** 数据压缩协商** - PPP 协议必须提供一种方法来协商使用数据压缩算法 PPP 协议的组成 _一个将 IP 数据报封装到串行链路的方法_。 PPP 既支持异步链路(无奇偶检验的 8 比特数据)，也支持面向比特的同步链路。 IP 数据报在 PPP 帧中就是其信息部分。这个信息部分的长度受最大传送单元 MTU 的限制。 一个用来建立、配置和测试数据链路连接的链路控制协议 LCP (Link Control Protocol)。通信的双方可协商一些选项。 一套网络控制协议 NCP (Network Control Protocol)，其中的每一个协议支持不同的网络层协议。 使用广播信道的数据链路层 局域网： 最主要的特点：网络为一个单位所拥有，且地理范围和站点数目均有限 主要优点： 具有广播功能，从一个站点可很方便地访问全网 便于系统的扩展和逐渐演变，各设备的位置可灵活调整和改变 提高了系统的可靠性、可用性和生存性 共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便地共享通信媒体资源。这在技术上有两种方法： 静态划分信道。用户只要分配到了信道就不会和其他用户发生冲突。 动态媒体介入控制，又称为多点接入。 特点：信道并非在用户通信时固定分配给用户 分为两类： 随机接入 受控接入 适配器： 作用：计算机与外界局域网的连接是通过通信适配器进行的。 适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的 适配器与计算机之间的通信是通过计算机主板上的 I/O 总线以并行传输方式进行的 适配器在接收和发送各种帧时，不使用计算机的 CPU CSMA/CD 协议： CSMA/CD 指载波监听多点接入/碰撞检测（Carrier Sense Multiple Access with Collision Detection） 为了通信的简便，以太网采取以下两种措施： 采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据。 适配器对发送的数据帧不进行编号，也不要求对方发回确认。 原因：局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。 以太网提供的服务是尽最大努力的交付，即不可靠的交付 对有差错帧是否需要重传则由高层来决定 总线上，_在同一时间只能允许一台计算机发送数据_，否则各计算机之间就会相互干扰。 以太网发送的数据都使用曼彻斯特编码的信号。 曼彻斯特编码的编码方法：把每一个码元再分成两个相等的间隔 优点：保证了每一个码元的正中间出现一次电压的转换，而接收端就利用这种电压的转换很方便地把位同步信号提取出来 缺点：它所占的频带宽度比原始的基带信号增加了一倍（因为每秒传送的码元数加倍了） CSMA/CD 协议的要点： “多点接入” 许多计算机以多点接入的方式连接在一根总线上 协议的实质是：“载波监听”和“碰撞检测” “载波监听” 用电子技术检测总线上有没有其他计算机也在发送，即检测信号 不管在发送前，还是在发送中，每个站都必须不停地检测信道 “碰撞检测” “边发送边监听”。即适配器边发送数据边检测信道上的信号电压的变化情况，一边判断自己在发送数据时其他站是否也在发送数据。 在使用 CSMA/CD 协议时，一个站不可能同时进行发送和接收。因此使用该协议的以太网不可能进行全双工通信而只能进行双向交替通信（半双工通信） 集线器 双绞线以太网总是和集线器配合使用的 集线器的特点： 使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是 CSMA/CD 协议。 网络中的各站必须竞争对传输媒体的控制，并且在同一时刻至多只允许一个站发送数据 一个集线器有许多接口 集线器工作在物理层。它的每个接口仅仅简单地转发比特，不进行碰撞检测 集线器采用了专门的芯片，进行自适应传音回波抵消。 这样可以使接口转发出去的较强信号不致对该接口接收到的较弱信号产生干扰 MAC 层的硬件地址 硬件地址又称为物理地址或MAC 地址，实际上就是适配器地址 在标识系统中，地址是识别某个系统的一个非常重要的标识符 “名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处” 严格地讲，名字应当与系统所在地无关 扩展的以太网 常用方法： 网桥：对收到的额帧根据其 MAC 帧的地址进行转发和过滤 一次只能分析和转发一个帧 交换式集线器：常称为第二层交换机或以太网交换机 这种交换机工作在数据链路层 特点 实质上就是一个多接口的网桥。 每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。 具有并行性。能同时连通多对接口，使多对主机能同时通信。 相互通信的主机都是独占传输媒体，无碰撞地传输数据 以太网交换机地接口还有存储器，能在输出端口繁忙时把到来的帧进行缓存，以获取目的 MAC 地址 以太网交换机是一种即插即用设备。 以太网交换机处理帧的方法： 对收到的帧采用存储转发方式进行转发 对收到的帧采用直通交换方式 虚拟局域网 VLAN 虚拟局域网是由一些局域网网段构成的与物理位置无关的逻辑组 每一个 VLAN 帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个 VLAN","link":"/2021/06/08/Courses/2019-06-09-computer-network-chp3/"},{"title":"2019 Robocup 赛后总结","text":"2019 Robocup 赛后总结 任对方调得激烈，我方自是唠的火热。倒也是挺符合我们的队名：不管怎么样反正 NAO 就队! 一上周我们有幸代表郑州大学去绍兴参加 2019 年 Robocup 中国赛。 作为第一次参加的队伍，我们今年的准备并不充分。一开始大家并没有使用 BHuman 平台，而是从网上找的各种资料来用 Python 自己造轮子。从寒假到 3 月底，我们用了足足三个月的时间造了一个不那么圆的轮子……直到三月底政乔跟其他学校交流，我们才知道大部分队伍用的是 BHuman 平台。 四月初，在我和政乔去同济学习回来后，我们才算是真正开始准备本次比赛。而此时，距大赛开始只有不到半个月的时间。 因为只有半个月的时间，所以太过仓促了。BHuman 平台中的许多调试工具都没用上，购买的绿毯也比正式比赛的场地要硬得多……在学校调试的防守员下坐防御动作在比赛场地上根本不能用，只要下坐就会往前倒。临出发前，5 号的头部风扇一直嗡嗡响，备用机 6 号也出了问题，一直到出发也没再能拿出一台备用机。 总之，仓促之中我们就此出战。 二 初到绍兴，才发现这里不愧是南方水乡。城市中到处都有河流穿过，站在桥上迎着吹来的风还是挺凉爽的~ 这次比赛和以往比赛相比规格真的高得多。会场服务十分到位，每天都有班车接送，宾馆也提供早餐，报道注册时还送了很多小东西。 绍兴这个地方我觉得很神奇，明明人很少，住宅区看上去也不是很高大上，但是附近的商场却很漂亮。然而直到晚上，我们一群男生去寻找网吧时才明白，这附近的商业并没有看上去那么发达。好多店都关门了，不仅仅是网吧，甚至商场里的饭店也是。柯桥区的商业有种让人觉得金玉其外，败絮其中的感觉。 夜晚的宾馆也是让人觉得没有那么舒服。且不说住了这么久的宾馆第一次碰到有人塞小卡片，每晚凌晨时分都有人在走廊大声说话。住了五晚，我没有一晚是能睡踏实的…… 三比赛耗时三天，算上调试一共是四天。我们因为没有带备用机，所以只在调试那一天，针对场地适应性进行了调整，后期都是在电脑上用 SimRobot 调整参数。这也就导致了后面比赛的三天里，所有队伍都在场上紧张刺激地进行调试，只有我们坐在场边唠嗑~这一唠，就唠了三天…… 说来惭愧，因为是首秀，对其他学校的实力没有一个认知，我们在开始比赛前一直担心能否赢至少一场拿个三等奖……赢了华师的时候，又听说集美大学弃赛，这就代表我们能赢至少两场。换言之，三等奖稳了。然而对上上交，还是没能赢。怎么说呢，不愧是去年亚军。 第一天 16 进 12，我们已经觉得很幸运了，而且也已经达成了我们的预期目标，所以后来基本就没什么压力，大家唠嗑唠地更开心了~ 第二天 12 进 8。踢厦大那场基本没什么压力。但是踢武大那场状态不断。先是边裁吹哨被主裁以为是对场吹的，结果没有点 Play。我们在 set 情况下 30 多秒就踢进了一球，却没办法加分。还好李树老师裁决进球有效。然而后来我方 5 号就坏了……前期在学校调试，把 5 号散热扇摔坏了。没想到这个时候爆发出来问题了，导致对武大这场 1：2 输了……不过好在后来厦大踢赢了武大，我们也能够出线。 8 进 4 时对上南京邮电大学，当时我们已经能够稳拿二等奖，又看着南邮在场上调地热火朝天，我们在场边唠嗑的时候还想着这次已经赚了，估摸着第二天就能出去旅游了。比赛时，和身边的南邮老哥还在说估计我们明天就能出去旅游……结果后面又赢了，说来挺对不起那老哥的，毕竟当面扎心……晚上半决赛又对上了上交，毫无疑问的输了。 最后一天是和西北民族大学竞争第三名，上半场四号又坏了，被西民抓住机会抢先进了一球。下半场四号调整完毕，5 台 NAO 相互配合，算是踢进了一球，扳平了比分。之前万万没想过我们会踢出平局需要点球，不过西民也没想到，大家准备的都不充分。休息的五分钟里，我提议直接烧 BHuman 提供的例程 Striker，没想到还挺好用的，也得亏西民的守门员一直往边界走，我们才能做到三球三进，最终夺得季军。 四 这次比赛，因为是郑州大学的首秀，我们自身压力也没那么大，所以在看到别人激烈地调机器时，还能愉快地唠嗑，最终唠出季军~ 所以说这次比赛和我们没什么关系，都是 NAO 自己努力的结果~","link":"/2021/06/08/Essays/2019-04-24-2019-robocup-summary/"},{"title":"天亮了，该检查衣服洗的怎么样了","text":"天亮了，该检查衣服洗的怎么样了2019 年 12 月 22 日下午五点多，在老师把所有试卷、文具整理好之后，这场为期两天的研究生招生考试正式结束了。说是两天，其实算上前期的准备，也算是一场持续半年的“马拉松”。 之前在网上看到有人对考研的比喻，我觉得挺形象，在这里也分享给大家： “考研备考，就像在黑屋子里洗衣服，你不知道洗干净了没有，只能一遍又一遍地去洗。等到上考场的那一刻，灯光亮了，你发现，如果你认真洗过了，那件衣服光亮如新。让你以后每次穿这件衣服都会想起那段岁月。” 实际上也正是如此，尤其是对我这种没有报考研辅导班也没有和大家一起复习而是选择独自备战的人来说，根本了解不到大家在每一个阶段的水平都是什么样的，恰如“在黑屋子里洗衣服一样”。 偶尔刷各种考研群，看到大家在群里说自己数学模拟 130、140，而自己只有七八十的时候也会很焦虑，但也像黑屋子里突然有人喊了一声“看我衣服洗的多干净”一样，具体怎么样谁也不知道。 黑夜再长，也会迎来天亮，屋子里也来了人要检查衣服洗的怎么样。当我真正上了考场之后，大家的真实水平怎么样就都暴露出来。这个时候才发现，不仅有人会偷工减料、消极怠工，甚至有些位置的主人从头到尾都没有出现过。当然，认认真真地备考的人还是占大多数。 跟大家进行对比之后，才发现自己准备的其实没有想象的那么差。至少我有把政治卷子工工整整地写满，有好好的背作文模板（而且 21 日中午去考场前背的最后一篇小作文恰巧是考到的通知），对于数学和专业课也尽量把会写的都写上了，至少现在的我能够硬气地说一声“自己尽力了”。接下来的日子就只剩下期末结课的相关事宜与期待考研分数的发布。 离 2020 年只剩下不到 10 天的时间了，10 年代也就要结束。剩下的时间我打算做个新年规划，希望能不再浑浑噩噩的过日子了。","link":"/2021/06/08/Essays/2019-12-23-graduate-school-entrance-exam/"},{"title":"没了手机，有了焦虑","text":"没了手机，有了焦虑12 月 24 日平安夜，像往常一样我在玩手机，然而手机却突然自动重启了。这种情况之前也发生过，但与之不同的是这次它没能一次重启后就正常开机，而是陷入了“无限重启”中。在大约 3-5 次重启后，手机进入了异常状态。经过在网上查询，我选择了在异常状态页面进行“恢复出厂设置”，还为此花了 3G 的流量开热点下载系统更新包。可是，一切准备就绪后，它还是会无限重启。至此，陪伴了我两年多的手机宣告了报废。 尴尬的是，一时半会我还没有备用智能机，唯一的老手机也是一台五年前使用的功能机。这意味着，在接下来的一天多里我将无法随心所欲地使用支付宝、微信、QQ 等可以说是日常必须的软件。在屋里的时候因为有电脑和微信还没有显得有多不方便，然而当我 25 日上午需要去找华为售后修手机时，才发现我的生活已经倒退回了 2016 年： 因为手机坏了，没办法通过 NFC 或者支付宝乘坐地铁，我去翻箱倒柜找出了很久不用的地铁卡。幸亏地铁卡里面还有 30 多块钱，不然充值的麻烦也会随之而来——我身上连一元现金都没有。 从我居住的地方到地铁站有大约一公里的距离，当我下楼的时候下意识地想开一辆共享单车地时候才想起来手机坏了没法扫码，只好走到地铁站。 出了地铁站，我并不知道售后在哪，也不能用手机查询地图，只好去问路人。 到了售后楼下看到有小吃，想买点吃的，可是手机坏了没办法扫码也没有现金，故只能作罢。 和家人朋友们联系，只能通过电话短信，而没办法通过 QQ 微信。 说实话，在智能手机还好的时候，这些行为真的已经是日常最普遍的行为，也是最必须的。日常的大多数出行也只用带上手机和钥匙，最多再多个充电宝。 如果不是它坏了，我都没有意识到智能手机已经这么深入我们的生活，成为了必需品。 还好，这段时光只维持了不到一天，因为新手机到了~","link":"/2021/06/08/Essays/2019-12-26-my-phone-was-broken/"},{"title":"总结2019，展望2020","text":"总结 2019，展望 2020 本来应该元旦前就写好的总结，一直拖到了今天。没办法，研究生考试结束了又赶上期末结课和考试以及毕设相关事宜，元旦后放了三天假又忙了三天，就一直拖到了今天才开始写。 总结篇 2019 年上半年随队参加了 Robocup 中国赛标准平台组，拿下了大学三年来自己的最高奖项——中国赛季军，随后不久又拿下了亚洲赛亚军。 2019 年下半年主要就在准备考研。因为时间短，数学没能好好复习，但是我可以问心无愧地说一句“尽力了”。考完了之后我屏蔽了所有考研群和公众号，不对答案不参与和讨论。但行好事，莫问前程。 规划篇 做规划得做两手准备，考研上岸了一个规划，没上岸再做一个规划。 未来十年长期计划（2020-2029） 读研 读博（可选） 找一个合适的工作 结婚 有自己的房子 2020 年计划 这部分就得分为两部分了，我太难了…… 未成功上岸版 [ ] 锻炼身体 [ ] 好好学习，准备考研 成功上岸版 锻炼身体，减肥（至少到 160 斤） 试着翻译一些计算机专业英文材料 做好专业要做的事，学好该学的习 掌握一门能挣钱的副业 学习 Java Web/小程序 日语入门（可选）","link":"/2021/06/08/Essays/2020-01-03-2020-new-year-plan/"},{"title":"写于 24 岁生日时","text":"4dc7a94e7c5a545a902ed34cc5b2f1c30cb0316419a3e53372a759eec4ff5daa492038bc7698d60a66dea877b65f2a01f2a2a294bd6a7287facd4a43dc1c1f517fe73d5235de656023f825a80c7ec80f2b23bc5a6f7dcffcac86fdae7e1af2a8f6d59b37716b9c1799219639a3acbaffcd481b2ebfd2939e810bdf034f0947415529de0f490a6d7c825f81435ebe4ac685c68b3a95132884d1a73cd188c0948dc9f9381df237eb6f5e41d3da3d2ec874e611d3baa028fe6dc385c1a8deb6df8e11fb8c14b27ababa55116d096bd37a22c6f72d3d4b5c1625a31717565b500ba95f5cfb952c0f68ece63b66b9330e3e5a33fddfa6bfca772a754f658963a17b4bdd59dd04849136b4439c5aee631233e619f6521e79a7bc98dec67ce7345468b31e217097102f1d8ceaadfc1a68b282fbb3ee6252e7bd1d68edceb9a7a650adc38432cb2d26e1fa1757ea3f929d6351a7f87bc2f82db00727b1f9d11f6cc6c024127c2aabbde755f2ae70db1f298eb31a1d0fed9d85f16f057b1096abfd79cb980637e5278b8fec1a97344069b45e3f9f93cd14674e0e700d74876e7bf982961f5be493289e3b95e04309a544a6d58d5b3c24da10d1de84ef62737a7855dfe22fd0f5ee3353f28df016344729db25a34c0c1a0bf28c982ede6d03416f2dc04443f1bcba6f28d91606bc346771b135e45020f9c57e93d691bda8f663f0a5dd636c16644e5b1480d5b412ae1d3ca4d4e5d1e5027f68ba77cdb140050f19e4bb91b2f26258f13eab9df1fa97e89cf656bb19c31c1fe17a0556d1cb7d885ba481d4b09f7e7c9bd0225a4e9830fed789157b2db9227f0284dd8ecb13406eb494c487942b9a55f6a9ac1094484989a4db4e6cb42937060c10b9e993d9c371ce9ac2723dee88ba0a21751da9be99a489d8416e629e26703ac4dc94421e2377d38f5d960ef118b0a0d3fd61ea599f50eb381ea81c6e7ab2641ed48d80ea4dc5369c427baa0a0b1df851256a0ab9729548e1ca59b47c2f4a1ef129c7ff71197d930dadf575be9bea1029965b0ba4b610d759e801b1195c5cac1ae06565049ccd3718855b4065eb07acb24931fe748372c7d4ad14ebce4051bc2f8efd2a65c7a9881e5e11d4d53e5b71e261c06ad0de6db52a7bcfe1878e46cb7b7d91b24d4b1a4193b49df3ae629327b3da8a5ad0480b499252e7a43d7750336c22b6e3a8e8e2227a3fea3f0a4e6718d25f2b55a28d96ce47979a08b450e6992b30a2e3feea856009402587adca0e736a94eeaefe8b87ed3774a035688bd485c37669012381219342d21fd510423cb34206895402f4d79614e6ed0cf92767db1937a8f5856c0293b8b13ecd8c204de472d24db552c29159171f02ea919993ed2a126285c048f8e5e368581f7e2ce8a6debbf486f48c496dff3af864294d657fb7241aec4a68a909b6cc9ed62fcdec2724d325b6572d117ed27d94688f481b9720b782690083f2df3ca54d3f6c61d730d15202f541714fc0eea0aa891bebd95931c4efdcdc51dc60a804f392948d9fa2f9ffd5cf13f820795d3b2b8bc14b36b58a1750aef6f782cf887d80141e11a5e7909c63e729eb39bb35649f3b25bb7184f1f5a20cab8edda6eac5fc0b2836f83efb6bb05541dfb1dc7d25d5cf26dbd17b3163e17c4907efc0643004781ca542f598f1a423bcafacfbcd617a523cde4858e677a0fb31a1ecfd3651d677ea1e6283269eef7f83268bb1f38907a694526d4bac99de7c65db6b3ed27958d8c7e8f8e0aef3124fe2cd1d1bd68fd1b07238304089412b87a0043f43f9d4f87d7b34b32e5e9b081a4c5f7049ff1e793bccaae8d42fe4bb15b51c0250820ded35b60d5aad2b4e89fd2507793638743e28e5e09338f375fd79432ab08945bf81447a6096f62e2f51733fe425f72bc6a5d80aef7f5afd8004c0c0cdff761903993f03323ac993e0068bc33bfffe0082f7ecb7a7d2f5da73f7bcdd2e7a33137befe76973334bb126c1a633f20b0019f219115a9985ab6b2fa51aa7fbbca690e6d9dc42c7d35542c958e069913affff3353d20424e48a17992bf9c4708d8428d6812c09b3adcaa28dc70b98955c5d9ff5cd4b06db6ca4549b100b2e5022b78a9de28ece07eaca9904939a0b3ba5bd4e4dc8ad Type the password here.","link":"/2021/08/06/Essays/2021-08-06-on-my-24th-birthday/"},{"title":"Python SDK入门 (1)——让NAO说话","text":"Python SDK 入门(1)——让 NAO 说话在 python for naoqi 的环境安装完成后，我们先来尝试让 NAO 说出“Hello world”： 123from naoqi import ALProxytts = ALProxy(&quot;ALTextTpSpeech&quot;, &quot;&lt;IP of your robot&gt;&quot;, 9559)tts.say(&quot;Hello world&quot;) 这是一个很简单的程序吧？那么接下来稍微增加一些难度，让它说一段绕口令： 1234567891011121314151617#!/usr/bin/python# -*- coding: utf-8 -*-from naoqi import ALProxytts = ALProxy(&quot;ALTextToSpeech&quot;, &quot;192.168.1.112&quot;, 9559)tts.setLanguage(&quot;Chinese&quot;)tts.say(&quot;你好，我是NAO&quot;)tts.say(&quot;我不仅会说你好，我还会说绕口令&quot;)tts.say(&quot;牛郎恋刘娘，刘娘念牛郎&quot;)tts.say(&quot;牛郎年年恋刘娘&quot;)tts.say(&quot;郎恋娘来娘念郎&quot;)tts.say(&quot;念娘恋娘&quot;)tts.say(&quot;念郎恋郎&quot;)tts.say(&quot;念恋娘郎&quot;) ALTextToSpeech 是 NAOqi 中能使说话的接口，我们通过 ALProxy 将其导入给对象 tts，而 say()、setLanguage()都是该类下的成员函数，分别起到传入要说的文字和设置语言的作用。","link":"/2021/06/08/Techniques/2018-04-24-make-nao-speak/"},{"title":"Python SDK入门（2）——让NAO行走并说话","text":"Python SDK 入门（2）——让 NAO 行走并说话１. 使 NAO 刚化 除非你将 NAO 的 stiffness 的值设为非 0 数，否则它是不会移动的 而要做到这点其实很简单，只要通过调用ALMotionProxy::setStiffnesses()进行设置即可： 123from naoqi import ALProxymotion = ALProxy(&quot;ALMotion&quot;, &quot;nao.local&quot;, 9559)motion.setStiffnesses(&quot;Body&quot;, 1.0) 2. 使 NAO 移动为了让 NAO 移动，我们应该使用 ALMotionProxy::moveInit()函数（以使 NAO 处于合适的姿势），然后再调用ALMotionProxy::moveTo()： 1234from naoqi import ALProxymotion = ALProxy(&quot;ALMotion&quot;, &quot;nao.local&quot;, 9559)motion.moveInit()motion.moveTo(0.5, 0, 0) 3. 使 NAO 同时说话并行走我们创建的每一个代理(proxy)都有一个叫做”post”的属性，且可以通过使用它在后台调用很多方法。 这可以帮助我们使机器人同时做很多事： 123456from naoqi import ALProxymotion = ALProxy(&quot;ALMotion&quot;, &quot;nao.local&quot;, 9559)tts = ALProxy(&quot;ALTextToSpeech&quot;, &quot;nao.local&quot;, 9559)motion.moveInit()motion.post.moveTo(0.5, 0, 0)tts.say(&quot;I'm walking&quot;) 当然，如果需要等待一个任务结束，我们可以使用 ALProxy 中的等待方法，使用寄出的方法(the post usage)所返回的任务 ID: 12345from naoqi import ALProxymotion = ALProxy(&quot;ALMotion&quot;, &quot;nao.local&quot;, 9559)motion.moveInit()id = motion.post.moveTo(0.5, 0, 0)motion.wait(id, 0) 完整的程序12345678910111213141516171819202122232425262728293031from naoqi import ALProxyimport argparsemotion = ALProxy(&quot;ALMotion&quot;, &quot;192.168.1.114&quot;, 9559) #NAO的动作对象tts = ALProxy(&quot;ALTextToSpeech&quot;, &quot;192.168.1.114&quot;, 9559) #NAO的语言对象posture = ALProxy(&quot;ALRobotPosture&quot;, &quot;192.168.1.114&quot;, 9559) #NAO的姿势对象#首先唤醒NAOmotion.wakeUp()#让NAO站好posture.goToPosture(&quot;StandInit&quot;, 0.5)#将其刚化motion.setStiffnesses(&quot;Body&quot;, 1.0)#初始化motion.moveInit()#让NAO向前走1米，同时返回任务ID给idid = motion.post.moveTo(1, 0, 0)tts.say(&quot;I'm walking&quot;)#直到id传过来了，再执行wait()函数motion.wait(id, 0)tts.say(&quot;I will not walk anymore&quot;)#让NAO休眠motion.rest()","link":"/2021/06/08/Techniques/2018-04-25-make-nao-speak-and-move/"},{"title":"Python SDK入门（3）——对事件做出反应","text":"Python SDK 入门（3）——对事件做出反应​ 这一节，我想让 NAO 在每一次侦测到人脸的时候都说一句“你好，人类”。为了达到这一点，我们需要使用 ALFacedetection 模型下的”FaceDetected”事件。 ​ 所以我们需要用 Python 写一个 NAOqi 模型出来。而要创建模型，我们首先需要一个中间件(Broker)。 ​ 下面是一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# -*- encoding: UTF-8 -*-&quot;&quot;&quot;每当侦测到人脸时都要说一声“你好，人类”&quot;&quot;&quot;import sysimport timefrom naoqi import ALProxyfrom naoqi import ALBrokerfrom naoqi import ALModulefrom optparse import OptionParserpip = &quot;nao.local&quot;# 用全局变量来存储&quot;HumanGreeter&quot;模型中的实例HumanGreeter = Nonememory = Noneclass HumanGreeterModule(ALModule): def __init__(self, name): ALmodule.__init__(self, name) #在这里不需要IP和端口， #因为我们可以在之后用自己写的中间件去连NAOqi中的中间件 #创建一个ALTextToSpeech稍后使用 self.tts = ALProxy(&quot;ALTextToSpeech&quot;) #使用FaceDetected事件 global memory memory = ALProxy(&quot;ALMemory&quot;) memory.subscribeToEvent(&quot;FaceDetected&quot;, &quot;HumanGreeter&quot;, &quot;onFaceDetected&quot;) def onFaceDetected(self,*_args): #这个方法将会在每次侦测到人脸的时候被调用 #当走路的时候不使用该事件 #以避免多次重复 memory.unsubscribeToEvent(&quot;FaceDetected&quot;, &quot;HumanGreeter&quot;) self.tts.setLanguage(&quot;Chinese&quot;) self.tts.say(&quot;你好，人类&quot;) #再次使用上面那个方法 memory.subscribeToEvent(&quot;FaceDetected&quot;, &quot;HumanGreeter&quot;, &quot;onFaceDetected&quot;)def main(): &quot;&quot;&quot; Main entry point &quot;&quot;&quot; parser = OptionParser() parser.add_option(&quot;--pip&quot;, help=&quot;Parent broker port. The IP address or your robot&quot;, dest=&quot;pip&quot;) parser.add_option(&quot;--pport&quot;, help=&quot;Parent broker port. The port NAOqi is listening to&quot;, dest=&quot;pport&quot;, type=&quot;int&quot;) parser.set_defaults( pip=NAO_IP, pport=9559) (opts, args_) = parser.parse_args() pip = opts.pip pport = opts.pport #我们需要用这个中间件来构建NAOqi模型并使用其他模型 #这个中间件必须在运行期间始终有效 myBroker = ALBroker(&quot;myBroker&quot;, &quot;0.0.0.0&quot;, # 监听所有的 0, # 找到一个空端口并使用它 pip, # 父类中间件IP pport) # 父类中间件端口 #注意：HumanGreeter必须是全局变量 #传入结构体的名字必须是这个变量的名字 global HumanGreeter HumanGreeter = HumanGreeterModule(&quot;HumanGreeter&quot;) try: while True: time.sleep(1) except KeyboardInterrupt: print print &quot;Interrupted by user, shutting down&quot; myBroker.shutdown() sys.exit(0)if __name__ == &quot;__main__&quot;: main() 一些注意事项： 要确保我们对实例使用的是全局变量 要确保我们传入 ALModule 的结构体的名字是自己的变量的名字 如果我们为此方法编写了文档字符串，且它不以下划线开头，则我们的类的方法会自动转换为绑定方法。（The method of your class are automatically transform into bound methods, providing that you wrote a doc string for this method, and it does not start with an underscore.） 一旦建立了 ALBroker 对象，我们需要使这个对象一直有效，以使订阅（the subscribing）工作。 我们还需要中间件处于有效状态才能创建代理而不必指定 IP 或端口。 脚本必须有–pip 和–pport 才能工作 补充内容： 让 Python 脚本在 NAO 上运行的方法： ​ 将脚本传到 NAO 上，如/home/nao/reacting_to_events.py，然后编辑/home/nao/naoqi/preferences 下的 autoload.ini 文件，加上： 12[python]/home/nao/reacting_to_events.py 请注意，在运行脚本时 NAOqi 会自动设置-pip 和-pport 值。 最后，运行这个脚本，然后把你的脸放在 NAO 的面前，你将会听到一声”你好，人类“。","link":"/2021/06/08/Techniques/2018-04-27-react-to-event/"},{"title":"Python SDK入门（4）——记录数据","text":"Python SDK 入门（4）—— 记录数据对于 NAO 来说，记录下它众多传感器的数据是很容易的。让我们来看一个简单的例子吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*- UTF-8 -*-&quot;&quot;&quot;记录下一些传感器的数据，并将它们写入到一个文本中&quot;&quot;&quot;# MEMORY_VALUE_NAMES 是我们想要存储的ALMemory的值的列表ALMEMORY_KEY_NAMES = [ &quot;Device/SubDeviceList/HeadYaw/Position/Sensor/Value&quot; &quot;Device/SubDeviceList/HeadYaw/Position/Actuator/value&quot;]NAO_IP = &quot;nao.local&quot;import osimport sysimport timefrom naoqi import ALProxydef recordData(nao_ip): &quot;&quot;&quot;记录ALMemory中的数据，并返回一个值的矩阵&quot;&quot;&quot; print &quot;Recording data...&quot; memory = ALProxy(&quot;ALMemory&quot;, nao_ip, 9559) data = list() for i in range(1, 100): line = list() for key in ALMEMORY_KEY_NAMES: value = memory.getData(key) line.append(value) data.append(line) time.sleep(0.05) return datadef main(): &quot;&quot;&quot;解析命令行参数， 运行recordData并将结果写进一个csv文件中 &quot;&quot;&quot; if len(sys.argv) &lt; 2: nao_ip = ROBOT_IP else: nao_ip = sys.argv[1] motion = ALProxy(&quot;ALMotion&quot;, nao_ip, 9559) # 设置头部马达的刚化 motion.setSetiffnesses(&quot;Head&quot;, 1.0) # 将会在两秒钟内从1.0弧度到0弧度 motion.post.angleInterpolation( [&quot;HeadYaw&quot;], [1.0, 0.0], [1, 2], False ) data = recordData(nao_ip) # 轻轻的将头部点击固定 motion.setSetiffnesses(&quot;Head&quot;, 0.0) output = os.path.abspath(&quot;record.csv&quot;) with open(output, &quot;w&quot;) as fp: for lint in data: fp.write(&quot;;&quot;.join(str(x) for x in line)) fp.write(&quot;\\n&quot;) print &quot;Results written to&quot;, outputif __name__ = &quot;__main__&quot;: main() 接下来我们将会没 50ms 调用一次ALMemoryProxy::getData() 来将值存进一个矩阵中，然后将这个矩阵写入一个文件。 注意： 这个方法相当的慢！但是不要尝试更高的频率去获取数据，这会给 NAO 的 CPU 带来很大的负担！","link":"/2021/06/08/Techniques/2018-04-27-record-data/"},{"title":"对NAO的手臂控简单控制","text":"对 NAO 的手臂控简单控制开启/关闭走路时手臂的摆动如何才能控制 NAO 的手臂呢？官方文档中给出了一段代码介绍： 这段代码中给出了如何控制 NAO 走路时是否摆动手臂，可以说是很简单了。难点在于怎么控制它的手臂固定在自己想要的角度呢？这就要用到另外的代码了。 设置角度文档中有个在ALMotion 库下的 API 叫做angleInterpolationWithSpeed可以通过传入一些参数进行控制，样式如下： 1motionProxy.angleInterpolation(names, angleLists, targetAngles, maxSpeedFraction) 其中names可以是身体或关节名，targetAngles是弧度制下的一串角度，maxSpeedFraction可以通过传入小数控制动作速度。 那么问题就来了，如果我们想给手臂设置姿势，那么就需要对它传值，可这个 list 该怎么写呢？ 从图片中我们可以看出，NAO 的一个手臂上有六个关节控制，也就是说我们要传的 list 应该有 6 个值。经过我的测试，顺序如下： 1Arm = [LShoudlerPitch，LShoudlerRoll，LElbowYaw，LElbowRoll，LWristYaw，LHandle] 以左臂为例，我们只要将部位名称、角度值列表、速度传入即可： 1motionProxy.angleInterpolationWithSpeed(&quot;LArm&quot;,Arm, 0.1) 但是后来我又发现了另一种方法同样可以控制手臂的角度，虽然比这个函数好理解一些，但是稍微有些麻烦，即通过setAngles函数设置角度值。但是因为时间关系，我并没有去实现，希望有人可以自己实现一下。","link":"/2021/06/08/Techniques/2018-04-30-control-nao-arms/"},{"title":"PIL库的简单使用","text":"PIL 库的简单使用Python 中的图像处理库 PIL(Python Imaging Library)应用广泛，在这里先做一个简单的介绍和使用。 安装可以通过pip install PIL进行安装，在这里不再多说。 使用加载图像为了能够从文件中加载我们想要使用的图像，应该调用 PIL 库中 Image 模块下的 open()函数： 12from PIL import Imageimg = Image.open(&quot;test.jpg&quot;) 如果加载成功了，那么这个时候我们能从img中获得图片的一些属性： 1print img.format, img.size, img.mode 会得到类似JPEG (640, 640) RGB这样的输出，就证明图片已经成功加载。 如果图片未能成功加载，img的format属性会设置为 None；size属性是一个二元组，其中包含了图片像素单位的宽度和高度；mode属性定义了图像中波段的数量和名称，以及像素类型和深度。如果图片打不开，IOError方法就会被调用。 当上述都成立时，我们就已经得到了一个实例img，通过img.show()就可以将图片展示出来。 操作图像通过这个库，我们能只用三四行代码完成图像的缩放操作： 12345678910from PIL import Image# 打开图像文件img = Image.open('test.jpg')# 获得图像尺寸:width, height = img.size# 缩放到原图的50%im.thumbnail((w//2, h//2))# 把缩放后的图像用jpeg格式保存:im.save('thumbnail.jpg', 'jpeg') PIL 库下的ImageDraw模型中还提供了多种绘图方法，可以通过官方文档自行阅读使用，在这里因时间限制就不再多述。","link":"/2021/06/08/Techniques/2018-05-06-pil/"},{"title":"Python练手小项目（一）——在图片上加上数字","text":"Python 练手小项目（一）——在图片上加上数字当一门语言学到了一定程度，我们就需要不断地做项目以加强对其的理解及应用。github 上有一个很有意思的练手项目合集：show-me-the-code。今天要写的就是其中的第 0000 题，下面我们来看下它的要求： 将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 类似于图中效果： 这里我们要用到昨天博客中所提到的PIL 库下的一些模块： from PIL import Image, ImageDraw, ImageFont 其中ImageDraw模块可以用来创建新的图像、对现有图像进行注释或修饰等，更多详细介绍请看：ImageDraw。 接下来定义函数add_num(img)来对图片进行操作： 12345678910111213141516171819202122def add_num(img): # ImageDraw.Draw()函数会创建一个用来对image进行操作的对象， # 对所有即将使用ImageDraw中操作的图片都要先进行这个对象的创建。 draw = ImageDraw.Draw(img) # 设置字体和字号 myfont = ImageFont.truetype('C:/windows/fonts/ARLRDBD.TTF', size=60) # 设置要添加的数字的颜色为红色 fillcolor = &quot;#ff0000&quot; # 昨天博客中提到过的获取图片的属性 width, height = img.size #设置添加数字的位置，具体参数可以自己设置 draw.text((width/1.2, 20), '99', font=myfont, fill=fillcolor) # 将修改后的图片以JPEG格式存储 img.save('result.jpg','jpeg') return 0 代码效果如下：","link":"/2021/06/08/Techniques/2018-05-27-an-easy-python-excerse-1/"},{"title":"正则表达式","text":"正则表达式 正则表达式为高级的文本模式匹配、抽取、与/或文本形式的搜索和替换功能提供了基础 正则表达式（简称 regex）是一些由字符和特殊符号组成的字符串，它们描述了模式的重复或者表述多个字符 正则表达式能按照某种模式匹配多个字符串 Python 通过标准库中的 re 模块来支持正则表达式 举例说明：[A-Za-z]\\w+的含义： 第一个字符是字母也就是说要么是 AZ，要么是 az 后面是至少一个（+）由字母数字组成的字符（\\w） 1.2 特殊符号和字符 _元字符_：即特殊符号和字符，给予了正则表达式强大的功能和灵活性 正则表达式中常用个特殊符号和字符有哪些？ 特殊符号 描述 示例 示例意义 | 管道符号，表示选择其中一个进行匹配 re1| re2 选择匹配正则表达式 re1 或者 re2 . 匹配除去\\n 之外的任意字符 d.d 表示匹配 d 与 d 之间为任意字符的情况，如“did”“d2d”等 ^ 匹配字符串起始部分 ^my 表示任何以 my 作为开始的字符串 $ 匹配字符串终止符 bye$ 表示匹配任何以 bye 结束的字符串 * 匹配 0 或者多次左端出现的正则表达式 [0-9]* 表示匹配以任意个数字开始的字符串 + 匹配 1 次或者多次左端出现的正则表达式 [0-9]+ 表示匹配以 1 个或者多个数字开始的字符串 ？ 匹配 0 次或者 1 次左端出现的正则表达式 [0-9]？ 表示匹配以 0 个或者 1 个数字开始的字符串 {N} 匹配 N 次左端出现的正则表达式 [0-9]{N} 匹表示配以 N 个数字开始的字符串 {M，N} 匹配 M 次到 N 次左端出现的正则表达式 [0-9]{M，N} 匹表示配以 M 个到 N 个数字开始的字符串 […] 匹配来自括号中字符集的任意一个 [abcd] 表示匹配 a 或者 b 或者 c 或者 d [.-.] 匹配从.到.之间的任意一个字符 [a-g] 表示匹配 a 到 g 之间的任意一个字符，如 a 或 b… [^…] 不匹配此字符集中的任何一个字符 [^abc] 表示匹配不是字符 a 或 b 或 c 的任意字符 （） 对正则表达式进行分组或者匹配子组 （[0-9]{3}）? 表示匹配三个数字出现一次或者不出现的情况 特殊字符 描述 示例 示例意义 \\d (\\D) \\d 匹配任何一个十进制数字，\\D 不匹配任何数字 \\d\\d\\d 匹配三个数字的字符串 \\w (\\W) \\w 匹配任何一个字母字符，\\W 不匹配任何字母字符 \\w+ 匹配一个由字母字符组成的字符串 \\s (\\S) \\s 匹配任何空格字符，\\S 不匹配任何空格字符 of\\sthe 匹配 of 和 the 之间有任何空格字符的情况 \\b(\\B) \\b 匹配任何单词边界,\\B 不匹配任何单词边界 \\bthe 任何以 the 开始的字符串 \\N 匹配已保存的子组 N price：\\N 匹配 price:后面加已保存的子组 N 的形式 \\c 仅按照 c 的字面意思进行匹配 * 匹配字符* \\A(\\Z) \\A 匹配字符串的开始，\\Z 匹配字符串的结尾 \\Acar 匹配以 car 开始的字符串 我们发现在特殊字符中大写往往表示与小写意义相反，可以用来帮助记忆。 1.2.1 使用择一匹配符号匹配多个正则表达式模式 择一匹配有时候也称作并（union）或者逻辑或（logical OR） 表示择一匹配的管道符号（|）表示一个“从多个模式中选择其一”的操作。 它用于分割不同的正则表达式 例如，正则表达式模式at|home，匹配到的字符串为at、home 1.2.2 匹配任意单个字符 点号（.）符号匹配除了换行符（\\n）以外的任何字符。 例如，正则表达式模式f.o能够匹配在字母”f”和”o”之间的任意一个字符，像 fao, f9o, f#o 等 注意：如要匹配句点符号（.），必须使用反斜线转义句点符号的功能，比如”\\.” 1.2.3 从字符串起始或者结尾或者单词边界匹配 如果要匹配字符串的开始位置，就必须使用脱字符（^）或者特殊字符\\A。后者主要用于那些没有脱字符的减排 美元符号（$）或者\\Z 将用于匹配字符串的末尾位置 特殊字符\\b 和\\B 可以用来匹配字符边界。 \\b 将用于匹配一个单词的边界，这一位这如果一个模式必须位于单词的起始部分，就不管该单词前面是否有任何字符 \\B 将匹配出现在一个单词中间的模式（即不是单词边界） 例如： 正则表达式模式 匹配的字符串 ^From 任何以 From 作为起始的字符串 /bin/tcsh$ 任何以/bin/tcsh 作为结尾的字符串 ^Subject:hi$ 任何由单独的字符串 Subject:hi 构成的字符串","link":"/2021/06/08/Techniques/2018-05-28-regular-expression/"},{"title":"NAO学习——在ROS上安装NAO","text":"NAO 学习——在 ROS 上安装 NAO1. 安装1.1 配置 NAOqi在从[Aldebaran Nao官网软件库](https://community.ald.softbankrobotics.com/en/resources/software)下载NAOqi SDK时，需要先注册账户 不知道为什么，我们实验室中现在只能用 2.1.2 版本的 SDK，装其他的都会报错。各位读者可以自己尝试一下别的版本。下载好之后，我们先解压压缩包： 1$ tar xzf pynaoqi-python2.7-2.1.2.17-linux64.tar 然后讲压缩包中的所有文件直接复制到 Python2.7 的 site-packages 文件中。为了检验是否成功导入，我们可以运行 Python： 12$ python&gt;&gt;&gt; import naoqi 若没有报错，则证明导入成功。注：也可按照ROS 官方教程或NAO 官方文档来配置 1.2 安装 NAO 机器人的 ROS 包在 ROS 上连接 NAO 需要一些额外的包，安装如下： 1sudo apt-get install ros-indigo-driver-base ros-indigo-move-base-msgs ros-indigo-octomap ros-indigo-octomap-msgs ros-indigo-humanoid-msgs ros-indigo-humanoid-nav-msgs ros-indigo-camera-info-manager ros-indigo-camera-info-manager-py 如果只是想使用 RViz 或者其他支持的 ROS 工具，则只需要安装:sudo apt-get install ros-indigo-nao-robot注：版本号 indigo 可以换成自己安装的版本（如：kinetic/hydro 等） 至此，我们就已基本配置完了 NAO 的环境。","link":"/2021/06/08/Techniques/2018-08-03-install-naoqi-ros/"},{"title":"NAO学习——ROS的安装","text":"Nao 学习——ROS 的安装搬运自在 Ubuntu 中安装 ROS Kinetic 1. 安装ROS Kinetic 只 支持Wily (Ubuntu 15.10), Xenial (Ubuntu 16.04) 和Jessie (Debian 8) 的debian包。 1.1 配置 Ubuntu 软件仓库配置你Ubuntu 软件仓库(repositories) 以允许 &quot;restricted&quot;、&quot;universe&quot; 和 &quot;multiverse&quot;这三种安装模式 1.2 添加 sources.list sudo sh -c 'echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list' 注：强烈建议使用国内或者新加波的镜像源，这样能够大大提高安装下载速度。 1.3 添加 keys sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 1.4 安装首先，确保你的 Debian 软件包索引是最新的：sudo apt-get update在 ROS 中，有很多不同的库和工具，官方提供了四种默认的配置： 桌面完整版: (推荐) : 包含 ROS、rqt、rviz、机器人通用库、2D/3D 模拟器、导航以及 2D/3D 感知 sudo apt-get install ros-kinetic-desktop-full 桌面版安装: 包含 ROS、rqt、rviz 以及通用机器人函数库。sudo apt-get install ros-kinetic-desktop ** 基础版安装: (简版**) 包含 ROS 核心软件包、构建工具以及通信相关的程序库，无 GUI 工具。sudo apt-get install ros-kinetic-ros-base 单个软件包安装: 你也可以安装某个指定的 ROS 软件包（使用软件包名称替换掉下面的 PACKAGE）:sudo apt-get install ros-kinetic-PACKAGE 要查找可用软件包，请运行：apt-cache search ros-kinetic 1.5 初始化 rosdep在开始使用 ROS 之前你还需要初始化 rosdep。rosdep 可以方便在你需要编译某些源码的时候为其安装一些系统依赖，同时也是某些 ROS 核心功能组件所必需用到的工具。 12sudo rosdep initrosdep update 1.6 环境配置如果每次打开一个新的终端时 ROS 环境变量都能够自动配置好（即添加到 bash 会话中），那将会方便很多： 12echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 如果你安装有多个 ROS 版本, ~/.bashrc 必须只能 source 你当前使用版本所对应的 setup.bash。如果你只想改变当前终端下的环境变量，可以执行以下命令： source /opt/ros/kinetic/setup.bash 如果你使用 zsh，替换其中的 bash， 可以用以下命令来设置 shell: 12echo &quot;source /opt/ros/kinetic/setup.zsh&quot; &gt;&gt; ~/.zshrcsource ~/.zshrc 1.7 构建工厂依赖到目前为止，已经安装了运行核心 ROS 包所需的内容。为了创建和管理自己的 ROS 工作区，有各种各样的工具和需求分别分布。例如：rosinstall 是一个经常使用的命令行工具，它使你能够轻松地从一个命令下载许多 ROS 包的源树。 要安装这个工具和其他构建 ROS 包的依赖项，请运行: sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential","link":"/2021/06/08/Techniques/2018-08-03-install-ros/"},{"title":"NAO学习——从NAOqi和rviz开始学习在ROS上运行NAO","text":"NAO 学习——从 NAOqi 和 rviz 开始学习在 ROS 上运行 NAO1. 开始连接一个实体 NAO1.1 运行 nao_bringup在开始之前，我们首先要确定三个必须的依赖包 naoqi_driver_，_naoqi_bridge 和 nao_description 是否满足。这三个包可以通过包管理器或者从 github 上 clone。 为了运行nao_bringup， 需要执行下列命令： $ roslaunch nao_bringup nao_full.launch nao_ip:=&lt;robot_ip&gt; roscore_ip:=&lt;roscore_ip&gt; 如果用的是 Python SDK，则需要执行： $ roslaunch nao_bringup nao_full_py.launch nao_ip:=&lt;robot_ip&gt; roscore_ip:=&lt;roscore_ip&gt; &lt;robot_ip&gt;是 NAO 的地址，’‘是运行 roscore 的电脑 IP 地址。因为 roscore 并不是在 NAO 上运行的，所以用这两个参数来让 NAO 找到 roscore 运行的位置是很必要的。将这两个参数修改为正确的 IP 地址，以在 NAO 和电脑之间建立正确连接。 当 nao_bringup 成功运行之后，我们就可以打开 rviz 了。 1.2 在 RVIZ 上显示 NAO首先打开 RVIZ： $ rosrun rviz rviz ROS 上提供了一个预先设置好的 RVIZ 配置文件urdf.rviz，保存在~/catkin_ws/src/nao_robot/nao_description/config/下。 如果想要看到完整的 NAO 的 3D 模型，我们需要安装一个包： $ sudo apt-get install ros-indigo-nao-meshes 在安装过程中，我们需要接受它的许可信息。安装完成后，重启一下 RVIZ。 2. 控制 NAO如果上面的步骤都成功了，我们这个时候就已经能在 RVIZ 中看见 NAO 了。 接下来我们将用 ROS 命令来控制 NAO。 首先执行$ rosnode list，我们应该能找到/nao_walker结点。这证明 NAO 的 walker 结点已经运行。 很重要的一点是，在开始控制实体 NAO 之前，需要先将其刚化： $ rosservice call /body_stiffness/enable &quot;{}&quot; 注：刚化之后，就不能再用手去移动 NAO 的关节。 若想解除刚化，则只需执行： $ rosservice call /body_stiffness/disable &quot;{}&quot; 刚化之后，我们就可以向 NAO 发送一个行走的命令： $ rostopic pub -1 /cmd_vel geometry_msgs/Twist '{linear: {x: 1.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' 这条指令将会使 NAO 不断沿 x 轴方向行走，每个循环都会走一米。 若需要停止，则只需将linear中的x: 1.0修改为x: 0.0： $ rostopic pub -1 /cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' 我们也可通过 ROS 一些已有的远程控制工具（如:ROS telep）来用键盘控制 NAO。 3. 在 ROS 上运行虚拟的 NAOqi3.1 加载环境首先，需要确保 roscore 已经运行。 然后在一个新的终端中，输入下列指令来在本地电脑运行 NAOqi，以模拟出一个 NAO： $ ~/naoqi/naoqi-sdk-1.12.3-linux32/naoqi --verbose --broker-ip 127.0.0.1 broker-ip 地址127.0.0.1是连接本地电脑的回路地址。只有在本地安装的 ROS 才能连接 NAOqi。NAOqi API 将可以通过 broker-ip 地址访问，而 nao_driver 将成为 NAOqi API 的包装器。 接下来在一个新的终端中加载ros_driver包，以连接本地的虚拟 NAO： $ LD_LIBRARY_PATH=~/naoqi/naoqi-sdk-1.14.5-linux64/lib:$LD_LIBRARY_PATH NAO_IP=127.0.0.1 roslaunch naoqi_driver naoqi_driver.launch force_python:=true 注：ROS 官网上英文教程中的这一指令貌似有错误，我用的是ROS 论坛中的解决方法。 如果运行成功，那么会看到与下列相似的输出： 123Walker online....nao_controller running... 注：不要将这个路径添加到全局LD_LIBRARY_PATH中，不然可能会在运行其他程序时出错。 3.2 在 RVIZ 中查看虚拟的 NAO首先退出之前所有正在运行的终端应用。 然后安装rospack： $ sudo apt-get install ros-fuerte-rospack 再安装一些 ROS 的可视化工具： $ sudo apt-get install ros-fuerte-visualization 接下来重新启动roscore、NAOqi 和 _nao_driver_。 现在我们需要启动 robot_state_publisher 并让其加载 NAO 的 URDF 模型： $ roslaunch nao_description nao_state_publisher.launch 然后重新启动 RVIZ 即可。 在 RVIZ 中，将左部的”Displays”中的”Fixed Frame”修改为”/base_link”。若只有”/map”选项，则证明 URDF 模型没有成功加载。 右部的”Target Frame”应该是&lt;Fixed Frame&gt;。 运行第二节中行走命令，我们就能看到 RVIZ 中的 NAO 开始行走了。","link":"/2021/06/08/Techniques/2018-08-07-run-naoqi-on-ros/"},{"title":"Java通过Cookie模拟登录微博","text":"Java 通过 Cookie 模拟登录微博 笔者从开始了解到写出这篇博客一共只用了几天的时间，所以本文更适合小白参考本文以 weibo.cn 为例，但只需修改 Request Header 中的部分参数，也可用与模拟登录 weibo.com 浏览器端操作 firefox 下有款插件挺好用的，但笔者只安装了 Chrome，故本文只介绍 Chrome 下的操作。 在 Chrome 中打开”weibo.cn”，按下F12，在”Network”中勾选”Preserve log” 点击”登录”，输入自己的帐号密码并登录 登录之后查看刚才的”Network”，下面出现了许多文件，从中找到以自己首页地址命名或命名为”home”的文件并点击，找到”Request Headers”一栏 浏览器端的操作基本就是这样，接下来我们开始写代码 代码部分 为了方便操作，笔者将部分操作封装成了实体类。首先是操作 Cookie 的实体： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.BasicCookieStore;public class CookieInfo { private HttpClient client; private HttpPost post; private HttpGet get; private BasicCookieStore cookieStore; public HttpClient getClient() { return client; } public void setClient(HttpClient client) { this.client = client; } public HttpPost getPost() { return post; } public void setPost(HttpPost post) { this.post = post; } public HttpGet getGet() { return get; } public void setGet(HttpGet get) { this.get = get; } public BasicCookieStore getCookieStore() { return cookieStore; } public void setCookieStore(BasicCookieStore cookieStore) { this.cookieStore = cookieStore; }} 接下来定义 WeiboLogin 类，在里面写入登录操作方法。首先需要实例化```eInfo: private CookieInfo cookieInfo = new CookieInfo(); 接下来设置 Cookie 登录策略，不设置的话微博会拒绝登录 1234567891011121314151617public WeiboLogin(){ //Cookie策略，不设置会拒绝Cookie Rejected, 设置策略保存Cookie信息 cookieInfo.setCookieStore(new BasicCookieStore()); CookieSpecProvider myCookie = new CookieSpecProvider() { public CookieSpec create(HttpContext httpContext) { return new DefaultCookieSpec(); } }; Registry&lt;CookieSpecProvider&gt; rg = RegistryBuilder.&lt;CookieSpecProvider&gt;create(). register(&quot;myCookie&quot;, myCookie).build(); cookieInfo.setClient(HttpClients.custom().setDefaultCookieSpecRegistry(rg).build()); cookieInfo.setGet(new HttpGet()); cookieInfo.setPost(new HttpPost());} 再写一个方法，将浏览器中刚才看到的”Request Headers”中的参数填入保存，同时加入一个输出语句，用于检验是否成功登录 123456789101112131415161718192021222324252627public void Login() throws ClientProtocolException, IOException, URISyntaxException{ String LoginUrl = &quot;https://weibo.cn/?luicode=20000174&quot;; //添加Request Header，用于模拟登陆 cookieInfo.getGet().setURI(new URI(LoginUrl)); cookieInfo.getGet().addHeader(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); cookieInfo.getGet().addHeader(&quot;Host&quot;, &quot;weibo.cn&quot;); cookieInfo.getGet().addHeader(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&quot;); cookieInfo.getGet().addHeader(&quot;API-RemoteIP&quot;, &quot;192.168.0.1&quot;); //模拟登录IP cookieInfo.getGet().addHeader(&quot;X-Forwarded-For&quot;,&quot;192.168.0.1&quot;); cookieInfo.getGet().addHeader(&quot;CLIENT-IP&quot;, &quot;192.168.0.1&quot;); cookieInfo.getGet().addHeader(&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;); cookieInfo.getGet().addHeader(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;); cookieInfo.getGet().addHeader(&quot;Accept-Encoding&quot;, &quot;gzip, deflate, br&quot;); cookieInfo.getGet().addHeader(&quot;Referer&quot;, &quot; https://passport.weibo.cn/signin/login?entry=mweibo&amp;r=https%3A%2F%2Fweibo.cn%2F%3Fluicode%3D20000174&amp;backTitle=%CE%A2%B2%A9&amp;vt=&quot;); cookieInfo.getGet().addHeader(&quot;Connection&quot;, &quot;keep-alive&quot;); cookieInfo.getGet().addHeader(&quot;Cookie&quot;, &quot;自己的Cookie信息&quot;); HttpResponse response = cookieInfo.getClient().execute(cookieInfo.getGet()); HttpEntity entity = response.getEntity(); //将获取到的网页信息打印出来，检验是否登录成功 String context = EntityUtils.toString(entity); System.out.println(&quot;获取的微博内容&quot;+context); } 最后新建 Test 类，写入 Main 主方法，调用 Login()方法即可。如果代码没有问题，那么到这里就能看到自己的首页源代码了。","link":"/2021/06/08/Techniques/2018-10-17-use-cookie-signin-weibo/"},{"title":"Github常见操作及问题","text":"Github 常见操作及问题 笔者每次新建仓库后首次同步都记不住操作，故干脆开篇博客记录一下 本地仓库首次推送 git init touch README.md git add .也可以git remote add origin git@github.com:xxxxx/yyyyy.git git commit -m &quot;first commit&quot; git push -u origin master 如果推送失败，但是上面又没有什么必要的，可以使用强制推送git push -f origin master 删除 github 仓库上的文件夹 git pull orint master将远程仓库拉下来; dir查看目录; git rm -r --cached 文件夹名将指定文件夹删除; git commit -m '删除了XXX文件夹'提交并添加操作说明; git push -u origin master将本次操作推送到 github 上 遇到的问题 同步时出现Permanently added the RSA host key for IP address 'xxx.xxx.xxx.xxx' to the list of known host这个提示只是一个警告，对实际操作没有影响。若要取消这个提示，只需在 hosts 文件下添加一条记录就可以了： sudo vim /etc/hosts 打开之后，添加xxx.xxx.xxx.xxx github.com，保存并关闭即可","link":"/2021/06/08/Techniques/2018-11-07-github/"},{"title":"Faster-RCNN环境配置","text":"Faster-RCNN 环境配置步骤 创建虚拟环境 12conda create --name &lt;env_name&gt; &lt;package_names&gt;# 例如: conda create --name lzw python=3.6 激活虚拟环境 source activate &lt;env_name&gt;(太老)使用conda activate &lt;env_name&gt;替代 退出虚拟环境 source deactivate(太老)使用conda deactivate替代 查看已创建环境 conda env list 安装 pytorch0.4 版本 12conda install pytorch=0.4.0 cuda80 -c pytorchpip install torch==0.4.0 -f https://download.pytorch.org/whl/cu80/stable #CUDA 8.0 build 克隆 Faster-RCNN.Pytorch 库 123456789101112# 1. 从Git上克隆git clone https://github.com/jwyang/faster-rcnn.pytorch.git# 2. 打开文件夹并创建文件夹‘data’cd faster-rcnn.pytorch &amp;&amp; mkdir data# 3. 安装所需依赖pip install -r requirements.txt# 4. 编译环境cd libsh make.sh 测试库中用例，检查是否能跑通 在”faster-rcnn.pytorch”文件夹中打开终端 指定 GPU 训练 1CUDA_VIDIBLE_DEVICES=$GPU_ID python trainval_net.py \\ --dataset pascal_voc --net res101 \\ --bs $BATCH_SIZE --nw $WORKER_NUMBER \\ --lr $LEARING_RATE --lr_decay_step $DECAY_STEP \\ --cuda 多 GPU 训练 12python trainval_net.py \\ --dataset pascal_voc --net res101 \\ --bs 24 --nw 8 \\ --lr $LEARING_RATE --lr_decay_step $DECAY_STEP \\ --cuda --mGPUs# (pascal_voc.py self._classes 类别修改) 问题 问题一： 在 Anaconda 虚拟环境中，命令python默认指向 python2 版本,需要修改为 python3 版本 解决： 1234# 删除原来指向python2的软链接mv /home/ciisr/anaconda3/envs/lzw/bin/python /home/ciisr/anaconda3/envs/lzw/bin/python.bak# 按照自己的实际情况进行更改ln -s /home/ciisr/anaconda3/envs/lzw/bin/python3.6 /home/ciisr/anaconda3/envs/lzw/bin/python 问题二： 明明import torch已经没有问题，但sh make.sh时会提示找不到 torch 模块 解决：注释”make.sh”中首行#! /usr/bin/env bash 问题三： 在运行上述第 7 步时“指定 GPU 训练”提示AttributeError: module 'torch.nn' has no attribute 'ModuleDict' 解决： torch 0.4.0 版本中不包含”torch.nn”,需要卸载后重新安装 0.4.1及以上版本（只能是 0.4.1，不然会导致问题五的发生）在 2020-01-08 的实验中我发现 torch 只能安装 0.4.0 版本的… 12pip uninstall torchpip install torch==0.4.0 问题四：在运行上述第 7 步时“指定 GPU 训练”提示from scipy.misc import imread. ImportError: cannot import name 'imread' 解决：scipy 需要安装 1.2.1 左右的版本，同时 pillow 版本不能高于 7.0.0，否则会导致ImportError: cannot import name 'PILLOW_VERSION'错误 12pip uninstall scipy pillowpip install scipy==1.2.1 pillow==5.2.0 问题五：在运行上述第 7 步时“指定 GPU 训练”提示ImportError: torch.utils.ffi is deprecated. Please use cpp extensions instead. 解决： torch 的版本只能安装 0.4.1在 2020-01-08 的实验中我发现 torch 只能安装 0.4.0 版本的… 问题六：在运行上述第 7 步时“指定 GPU 训练”提示torch.jit.frontend.NotSupportedError: slicing multiple dimensions at the same time isn't supported yet 解决： 重新安装 torchvision0.2.2 版本. **注意**：不能把 torch 版本升级到 1.0.0，不然会导致问题五的发生。","link":"/2021/06/08/Techniques/2020-01-07-faster-rcnn-env/"},{"title":"使用Faster-RCNN进行指定GPU训练","text":"使用 Faster-RCNN 进行指定 GPU 训练实验内容 解决了昨日环境配置剩下的问题（三~六），接着昨日第 7 步继续 测试库中用例，检查是否能跑通 在”faster-rcnn.pytorch”文件夹中打开终端 指定 GPU 训练 12345CUDA_VISIBLE_DEVICES=$GPU_ID python trainval_net.py \\ --dataset pascal_voc --net res101 \\ --bs $BATCH_SIZE --nw $WORKER_NUMBER \\ --lr $LEARNING_RATE --lr_decay_step $DECAY_STEP \\ --cuda 参数意义： CUDA_VISIBLE_DEVICES=$GPU_ID：指明所使用的 GPU ID，$GPU_ID需修改为指定 ID --dataset pascal_voc --net res101：在 pascal_voc 上使用 resnet101 进行训练 --bs $BATCH_SIZE --nw $WORKER_NUMBER：可以根据 GPU 内存大小来自适应地设置 BATCH_SIZE(批处理尺寸)和 WORKER_NUMBER。在具有 12G 内存的 Titan Xp 上，它最多可以为 4 --lr $LEARNING_RATE --lr_decay_step $DECAY_STEP ：**学习率(Learning rate)**作为监督学习以及深度学习中重要的超参，其决定着目标函数能否收敛到局部最小值以及何时收敛到最小值。合适的学习率能够使目标函数在合适的时间内收敛到局部最小值。 多 GPU 训练(这一步实验没有做，“指定 GPU 实验”居然从下午三点多跑到了晚上 11 点多…) 12python trainval_net.py \\ --dataset pascal_voc --net res101 \\ --bs 24 --nw 8 \\ --lr $LEARING_RATE --lr_decay_step $DECAY_STEP \\ --cuda --mGPUs# (pascal_voc.py self._classes 类别修改) 问题 问题一：RuntimeError: The expanded size of the tensor (2) must match the existing size (0) at non-singleton dimension 1 解决：原因在于计算二分类交叉熵损失函数时是在每个 batch 中进行的，而总的图片数量并不能被所设置的 batch_size 整除，造成最后一个 batch 的图片数量与 batch_size 不相等。 问题二：AttributeError: 'int' object has no attribute 'astype' 解决：将/lib/roi_data_layer/roibatchLoader.py中第 52 行的target_ratio = 1改为target_ratio = np.array(1) 问题三：AttributeError: 'Tensor' object has no attribute 'index' 解决： 将 torch 的版本改为 0.4.0…所以昨天的错误到时出在哪个依赖上了？？？","link":"/2021/06/08/Techniques/2020-01-08-train-with-resnet101-on-pascal_voc/"},{"title":"使用Faster-RCNN进行指定GPU训练（续）","text":"使用 Faster-RCNN 进行指定 GPU 训练（续） 今天接着昨天的实验继续跑“多 GPU 训练” 12python trainval_net.py \\ --dataset pascal_voc --net res101 \\ --bs 24 --nw 8 \\ --lr $LEARING_RATE --lr_decay_step $DECAY_STEP \\ --cuda --mGPUs# (pascal_voc.py self._classes 类别修改) 训练自己的数据集（步骤与之前样例中相同） 训练完成后对数据集进行处理，发现有些图片因为亮度不够或模糊而识别有误。下一步考虑怎么提高图片的清晰度，使识别率提高。 目前有个想法： 计算图片清晰度，如果清晰度不在某个范围的话，进行第二步操作； 调整图片的亮度和对比度，然后再进行清晰度计算。若清晰度达到要求，则输出；否则，继续调整，直到符合要求。 问题 问题一：“多 GPU 训练”中出现ctx.input_sizes = tuple(map(lambda i: i.size(ctx.dim), inputs)) RuntimeError: dimension specified as 0 but tensor has no dimensions错误 解决：在faster-rcnn.pytorch中的issue: multi gpu train errors!可以看到这个问题出现的比较多，其中有两条解决方案： the pytorch 1.0 branch works fine with multi GPU training（pytorch 1.0 分支可以正常进行多 GPU 训练）。但因为太麻烦，我没有尝试。 在faster-rcnn.pytorch/lib/model/faster_rcnn/faster_rcnn.py中加入以下几行（经测试可行）： 1234rpn_loss_cls = torch.Tensor([0]).cuda() + rpn_loss_clsrpn_loss_bbox = torch.Tensor([0]).cuda() + rpn_loss_bboxRCNN_loss_cls = torch.Tensor([0]).cuda() + RCNN_loss_clsRCNN_loss_bbox = torch.Tensor([0]).cuda() + RCNN_loss_bbox 问题二：assert (boxes[:, 2] &gt;= boxes[:, 0]).all() AssertionError 解决：将datasets/pascal_voc.py中的如下代码的”-1”删掉 1234567bbox = obj.find('bndbox')# Make pixel indexes 0-basedx1 = float(bbox.find('xmin').text) - 1y1 = float(bbox.find('ymin').text) - 1x2 = float(bbox.find('xmax').text) - 1y2 = float(bbox.find('ymax').text) - 1 问题三：raise ValueError(&quot;bg_num_rois = 0 and fg_num_rois = 0, this should not happen!&quot;) 解决： 玄学解决，按照ValueError: bg_num_rois = 0 and fg_num_rois = 0, this should not happen! 中的方法都试了一遍，莫名其妙的就跑通了。。。","link":"/2021/06/08/Techniques/2020-01-09-train-with-resnet101-on-pascal_voc/"},{"title":"利用Hexo打造属于自己的网页版简历","text":"利用 Hexo 打造属于自己的网页版简历最近想着做一个网页版的个人简历，想着要满足一下几个需求： 简洁直观不花里胡哨的 方便修改内容，能根据修改后的内容自动生成网页 这就要求我最好能用静态博客框架来做，如：Hexo、Hugo 等。 但是找了许多主题，都没有一个很能令我满意的。 最接近的一个是Crisp Minimal Résumé。 但是该主题的 Hexo 版本中存在许多 BUG，而且排版松懈、没有照片。 所以趁着春节无处可去，干脆在家做了个 Hexo 的简历主题——Mtics-Resume。 本主题在Crisp Minimal Résumé上做了许多修改，使它更符合我的喜好。 本主题具有以下特点： 简洁直观 配置简单 可定制性强 响应式布局 在隐藏了 footer 后，可直接打印成为纸质简历 欢迎各位使用 Hexo 或者对本主题有兴趣的大佬试用，并向我提出建议或与我一起开发。 项目地址：https://github.com/mtics/hexo-mtics-resume 在线演示：https://mtics.netlify.com/ Ps: 因本项目及演示都放在 Github 上，通过 Netlify 进行部署，所以访问速度可能较慢，敬请谅解。","link":"/2021/06/08/Techniques/2020-01-27-mtics-resume-template/"},{"title":"为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢","text":"为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢","link":"/2021/06/08/Techniques/2020-03-02-introduction-of-gamification/"},{"title":"使用Python实现平台自动打卡","text":"使用 Python 实现平台自动打卡 众所周知，人的懒惰是技术发展的一大动力。现在正处疫情期间，因为我总是忘记及时健康打卡而导致被年级群通报，故干脆写了个 Python 脚本来自动打卡。若之后我的身体状态、所在地等信息都没有改变的话，这个脚本就能帮我完成一个小任务嘞。 代码部分代码整体并不难。 通过使用 Selenium 库，能够将一切网页端的操作模拟成一个真正的用户在操作。 Selenium 安装库本身并不难安装，只需要运行以下指令即可： pip install selenium 但要注意，要想使用它还需要安装浏览器驱动。比如我用的是 Chrome，就需要安装ChromeDriver。 ChromeDriver 的版本号要与本机安装的 Chrome 浏览器的版本相同。打开 Chrome，可以通过点击右上角的菜单按钮（即三个竖直排列的”.”），然后选择&quot;帮助&quot; &gt; &quot;关于 Google Chrome&quot;，即可看到浏览器的版本号： 按照 Chrome 的版本下载 ChromeDriver，然后还需要将其安装到 Python 环境中。打开命令行界面，通过where python查询 Python 环境位置，将下载好的chromedriver.exe复制到Scripts文件夹中。 之后在命令行界面中通过chromedriver命令可查看 ChromeDriver 是否正常安装。若正常，则会出现如下类似输出： 123Starting ChromeDriver 80.0.3987.106 (f68069574609230cf9b635cd784cfb1bf81bb53a-refs/branch-heads/3987@{#882}) on port ****Only local connections are allowed.Please protect ports used by ChromeDriver and related test frameworks to prevent access by malicious code. 签到部分Selenium 的一个好处是所有的操作都是直接运行再浏览器中，和真正的用户操作是一样的。因此就不需要设置伪装头文件了。 浏览器模拟123456# 这部分用来设置运行时不显示浏览器窗口chrome_options = Options()chrome_options.add_argument(&quot;--headless&quot;)# 模拟浏览器进行访问browser = webdriver.Chrome(options=chrome_options)browser.get(&quot;https://jksb.v.zzu.edu.cn/vls6sss/zzujksb.dll/first0&quot;) 进行签到123# 通过find_element_by_xpath来定位用户名和密码的输入框browser.find_element_by_xpath(&quot;//*[@id='mt_5']/div[1]/div[3]/input&quot;).send_keys(uid)browser.find_element_by_xpath(&quot;//*[@id='mt_5']/div[2]/div[3]/input&quot;).send_keys(pwd) 为了防止加载不完全的错误，可以设置time.sleep(2)来阻塞两秒等待加载。 通过以下代码可以获取到签到完成后的提示信息，用作之后的通知邮件的内容： 1final_text = browser.find_element_by_xpath(&quot;//*[@id='bak_0']/div[2]/div[2]/div[2]/div[2]&quot;).text 邮件通知签到后会通过邮件来告知我是否成功。 这里我用的是 QQ 邮箱： 123456789101112131415def mail(mail_text, mail_to): # 设置邮件内容，用的是之前签到返回的提示信息 msg = MIMEText(mail_text) # 设置邮件主题、发送方和接收方 msg['Subject'] = &quot;每日健康打卡通知&quot; msg['From'] = MAIL_USER msg['To'] = mail_to # 发送邮件 send = smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465) send.login(MAIL_USER, MAIL_PWD) send.send_message(msg) # 退出邮件 send.quit() 私人信息因这部分牵涉到了个人信息，我单独建了一个private_info.py来存储，并没有公开，故用户在使用时需要自行创建。内容如下： 1234567891011MAIL_USER = &quot;your-notice@email.address&quot; # 用于发送通知的邮箱MAIL_PWD = &quot;your-authorization-code&quot; # 该邮箱的授权码# 单用户UID = &quot;your-id&quot; # 学号PWD = &quot;your-password&quot; # 密码MAIL_TO = &quot;your-email&quot; # 接受通知的邮箱# 多用户users = list()users.append(User(&quot;your-id&quot;, &quot;your-password&quot;, &quot;your-email&quot;)) 其中多用户添加账户信息时，使用的是自定义类 User()，代码如下： 123456789class User: uid = &quot;&quot; pwd = &quot;&quot; email = &quot;&quot; def __init__(self, uid, pwd, email): self.uid = uid self.pwd = pwd self.email = email 完整代码放在了Github上，如果读者有兴趣，不妨试一试。 任务定时现在，程序本身已经支持定时了！ 通过修改auto_sign.py中第 72 行代码中==后的数字就可以自定义时间了： 1if now.hour == 6 and now.minute == 0: 代价就是程序必须一直运行着。 作为补偿，我将编码修改为了 GBK，这样可以运行在 Linux 服务器上了，通过以下命令即可： 1nohup python auto_sign.py &amp; 我看了几个 Python 实现的定时运行方法，感觉都不是很好。 在尝试了几种后，最终选择了使用 Win10 自带的“任务计划程序”。 单击右侧“创建基本任务”： ![创建基本任务](C:\\Users\\lizw9\\Pictures\\Saved Pictures\\创建基本任务.png) 输入名称、描述后单击下一步，选择“每天”，开始时间我设置在了“06:00”。 之后选择“启动程序”，继续下一步。 接下来会到“启动程序界面”，在“程序或脚本”处选择自己的 python 环境所在位置，然后在“添加参数处”输入auto_sign.py的路径，如图所示： 继续“下一步”后，单击“完成”即可。","link":"/2021/06/08/Techniques/2020-04-08-auto-sign-zzu-jksb/"}],"tags":[{"name":"Data Structure and Agorithms","slug":"Data-Structure-and-Agorithms","link":"/tags/Data-Structure-and-Agorithms/"},{"name":"Computers and Digital Systems","slug":"Computers-and-Digital-Systems","link":"/tags/Computers-and-Digital-Systems/"},{"name":"Computer Network","slug":"Computer-Network","link":"/tags/Computer-Network/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"Personal","slug":"Personal","link":"/tags/Personal/"},{"name":"NAO","slug":"NAO","link":"/tags/NAO/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Deep Learning","slug":"Deep-Learning","link":"/tags/Deep-Learning/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Gamify","slug":"Gamify","link":"/tags/Gamify/"}],"categories":[{"name":"Courses","slug":"Courses","link":"/categories/Courses/"},{"name":"Essays","slug":"Essays","link":"/categories/Essays/"},{"name":"Techniques","slug":"Techniques","link":"/categories/Techniques/"}]}