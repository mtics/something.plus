<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浪漫生活手册</title>
  
  <subtitle>Romantic Life Handbook</subtitle>
  <link href="https://something.plus/atom.xml" rel="self"/>
  
  <link href="https://something.plus/"/>
  <updated>2022-04-20T03:10:59.576Z</updated>
  <id>https://something.plus/</id>
  
  <author>
    <name>一颗荔枝味的汤圆</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分查找法</title>
    <link href="https://something.plus/2021/06/08/Courses/2017-11-25-binary-find/"/>
    <id>https://something.plus/2021/06/08/Courses/2017-11-25-binary-find/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><p>最近学校事比较多，自己好久没写过 JAVA 了，趁着这次开《算法图解》，可以好好的把 JAVA 基础再过一遍。</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>毕竟是《算法图解》的笔记，所以正好把算法是什么也解释一下吧。</p><blockquote><p><strong>算法</strong>是一组完成任务的指令。 —-《算法图解》</p></blockquote><p>嗯，就是这个样子（嘿嘿嘿）。</p><blockquote><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰<a href="https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4">指令</a>，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5">输入</a>，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用<a href="https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">空间复杂度</a>与<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a>来衡量。</p><p>​ —-摘自百度百科词条“算法”</p></blockquote><p>根据百度百科中对“算法”的解释，可以看出算法就是为了能够更好更优的解决问题而存在的，简单来说就是使程序运行速度更快，占的空间更小。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote><p>二分查找是一种算法，其输入是一个有序的元素列表。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回<code>null</code>。 —-《算法图解》</p></blockquote><p>_有序_：是为了在查找时，让数据有序可循，以便于直知道二分点的数据与要查找的数据之间的关系。</p><p>二分查找的时间复杂度是 O(logn)</p><h3 id="程序主体"><a href="#程序主体" class="headerlink" title="程序主体"></a>程序主体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//查找范围的头部位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;<span class="comment">//查找范围的尾部位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid;<span class="comment">//二分点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(low &lt; high) &#123;<span class="comment">//如果low &lt; high，则始终进行比较，直到找到该数或low &gt;= high</span></span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n == arr[mid]) &#123;<span class="comment">//若找到该数，则将该处位置返回，结束查找</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &gt; arr[mid]) &#123;<span class="comment">//若二分点的数字小于目标数</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &lt; arr[mid] ) &#123;<span class="comment">//若二分点的数字大于目标数</span></span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//若始终没能查到目标数字，则返回-1，证明该数字不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二分查找法&quot;&gt;&lt;a href=&quot;#二分查找法&quot; class=&quot;headerlink&quot; title=&quot;二分查找法&quot;&gt;&lt;/a&gt;二分查找法&lt;/h1&gt;&lt;p&gt;最近学校事比较多，自己好久没写过 JAVA 了，趁着这次开《算法图解》，可以好好的把 JAVA 基础再过一遍。&lt;/p</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Data Structure and Agorithms" scheme="https://something.plus/tags/Data-Structure-and-Agorithms/"/>
    
  </entry>
  
  <entry>
    <title>求二叉树两结点最近的共同祖先结点</title>
    <link href="https://something.plus/2021/06/08/Courses/2017-11-27-common-father/"/>
    <id>https://something.plus/2021/06/08/Courses/2017-11-27-common-father/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求二叉树两结点最近的共同祖先结点"><a href="#求二叉树两结点最近的共同祖先结点" class="headerlink" title="求二叉树两结点最近的共同祖先结点"></a>求二叉树两结点最近的共同祖先结点</h1><h2 id="题目要求及思路分析"><a href="#题目要求及思路分析" class="headerlink" title="题目要求及思路分析"></a>题目要求及思路分析</h2><ul><li>题目要求：已知在二叉树中，_ root 为根结点，_ p 和* q 为二叉树中两个结点，试编写求距离它们最近的共同祖先的算法。 —《数据结构习题集（C 语言版）》</li><li>思路：<ul><li>显然在这个题目中，递归遍历不适用。同时先中后三种顺序，先序遍历比较合适。</li><li>要利用栈的特性来存储访问目标结点的路径，以便于最后查找它的祖先结点。</li><li>当* p 和* q 的路径都找到后，我们可以看到根结点在栈底，而目标结点在栈顶，这样的话不利于我们比较两条路径上共同的祖先结点。所以，要将两个目标结点的路径栈逆置，使栈顶元素都为根结点，这样在出栈的时候可以比较两个栈顶元素指向的结点。直到出现第一个不同的结点时，取上一个出栈元素，即为距两目标结点最近的共同祖先结点。</li></ul></li></ul><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ol><li><p>两种数据类型的结构体定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------二叉树的二叉链结点结构定义------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TElemType char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">TElemType data;<span class="comment">// 结点数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右 孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">/------栈的数据结构预定义------/</span><br><span class="line">define MAXSIZE <span class="number">100</span>       <span class="comment">// 存储空间初始分配量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   BiTree data[MAXSIZE];</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> top;<span class="comment">//用于栈顶指针</span></span><br><span class="line"></span><br><span class="line">   &#125;SqStack;</span><br><span class="line"></span><br><span class="line">/---------------------------/</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>用到的栈的基本操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------栈的基本操作函数-------*/</span></span><br><span class="line"></span><br><span class="line">   Status <span class="title function_">Push</span><span class="params">(SqStack *S, BiTree e)</span>&#123;</span><br><span class="line">   <span class="comment">//插入元素e 为新的栈顶元素</span></span><br><span class="line">   <span class="keyword">if</span> (S-&gt;top = MAXSIZE - <span class="number">1</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">   S-&gt;top++;</span><br><span class="line">   S-&gt;data[S-&gt;top] = e;<span class="comment">//将新插入元素赋值给栈顶空间</span></span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BiTree <span class="title function_">Pop</span><span class="params">(SqStack *S)</span>&#123;</span><br><span class="line">   <span class="comment">//若栈不空，则删除S的栈顶元素，用e返回其值，变返回oK;否则返回ERROR</span></span><br><span class="line">   <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">   BiTree e = S-&gt;data[S-&gt;top];<span class="comment">//将要删除的栈顶元素赋给e</span></span><br><span class="line">   S-&gt;top--;<span class="comment">//栈顶指针减一</span></span><br><span class="line">   <span class="keyword">return</span> e;</span><br><span class="line">   &#125;   <span class="comment">//pop</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*-----栈的基本操作函数结束-----*/</span></span><br></pre></td></tr></table></figure></li><li><p>用到的树的基本操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------树的基本操作的函数------*/</span></span><br><span class="line"><span class="comment">//按照二叉树的定义初始化一个空树</span></span><br><span class="line">Status <span class="title function_">InitBiTree</span><span class="params">(BiTree *bt)</span>&#123;</span><br><span class="line"></span><br><span class="line">*bt = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"><span class="keyword">if</span> (!bt)<span class="keyword">return</span> OVERFLOW;</span><br><span class="line"></span><br><span class="line">*bt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造二叉链表表示的二叉树T</span></span><br><span class="line"><span class="comment">//按先序次序输入二叉树中结点的值（一个字符）,空格字符表示空树</span></span><br><span class="line">Status <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span>&#123;</span><br><span class="line">TElemType ch;</span><br><span class="line"></span><br><span class="line">printf_s(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">getchar();<span class="comment">//getchar()用于处理回车占字符的问题</span></span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">*T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">*T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!T)<span class="keyword">return</span> OVERFLOW;<span class="comment">// 若内存分配失败，则返回OVERFLOW</span></span><br><span class="line"></span><br><span class="line">(*T)-&gt;data = ch;<span class="comment">// 生成根结点</span></span><br><span class="line">CreateBiTree(&amp;((*T)-&gt;lchild));<span class="comment">//构建左子树</span></span><br><span class="line">CreateBiTree(&amp;((*T)-&gt;rchild));<span class="comment">//构建右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----树的基本操作的函数结束----*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>利用栈来存储访问目标结点的路径</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求距两个子结点最近的共同祖先结点*/</span></span><br><span class="line">Status <span class="title function_">FindPath</span><span class="params">(BiTree root, BiTree target, SqStack *path)</span>&#123;</span><br><span class="line"></span><br><span class="line">SqStack* s;</span><br><span class="line">s = (SqStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqStack));</span><br><span class="line"></span><br><span class="line">BiTree node = root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">Push(path, node);<span class="comment">//将当前结点入栈</span></span><br><span class="line"><span class="keyword">if</span> (node == target)<span class="keyword">return</span> OK;<span class="comment">//若当前结点即为目标结点，则可直接结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若左孩子存在，则再看右孩子。若右孩子也存在，将右孩子存入栈s；若右孩子不存在，则直接访问下一个左孩子。</span></span><br><span class="line"><span class="comment">//若左孩子不存在，则访问右孩子。若左右孩子都不存在，则去查看栈s中的栈顶元素所指结点。</span></span><br><span class="line"><span class="comment">//重复操作，直到找到目标结点。这时栈path中存储的元素为访问到目标结点的所有元素。</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;lchild)&#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;rchild)&#123;</span><br><span class="line">Push(s, node-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">node = node-&gt;lchild;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;rchild)&#123;</span><br><span class="line">node = node-&gt;rchild;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (s)&#123;</span><br><span class="line"><span class="keyword">while</span> (path-&gt;data[path-&gt;top]-&gt;rchild != s-&gt;data[s-&gt;top])&#123;</span><br><span class="line">Pop(path);</span><br><span class="line">&#125;</span><br><span class="line">node = s-&gt;data[s-&gt;top];</span><br><span class="line">Pop(s);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对* p、* q 分别调用第 4 步中的函数，将得到的两个路径栈逆置，在逆置后的栈中出栈顶元素同时进行比较，得到公共祖先结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">CommentParent</span><span class="params">(BiTree* parent, BiTree root, BiTree p, BiTree q)</span>&#123;</span><br><span class="line">SqStack *path_p, *path_q;</span><br><span class="line">path_p = (SqStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqStack));</span><br><span class="line">path_q = (SqStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqStack));</span><br><span class="line"></span><br><span class="line">FindPath(root, p, path_p);</span><br><span class="line">FindPath(root, q, path_q);</span><br><span class="line"></span><br><span class="line">SqStack *reverse_p, *reverse_q;</span><br><span class="line">reverse_p = (SqStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqStack));</span><br><span class="line">reverse_q = (SqStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqStack));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (path_p)&#123;</span><br><span class="line">Push(reverse_p, Pop(path_p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (path_q)&#123;</span><br><span class="line">Push(reverse_q, Pop(path_q));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (reverse_p-&gt;data[reverse_p-&gt;top] == reverse_q-&gt;data[reverse_q-&gt;top])&#123;</span><br><span class="line">*parent = reverse_p-&gt;data[reverse_p-&gt;top];</span><br><span class="line">Pop(reverse_p);</span><br><span class="line">Pop(reverse_q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;求二叉树两结点最近的共同祖先结点&quot;&gt;&lt;a href=&quot;#求二叉树两结点最近的共同祖先结点&quot; class=&quot;headerlink&quot; title=&quot;求二叉树两结点最近的共同祖先结点&quot;&gt;&lt;/a&gt;求二叉树两结点最近的共同祖先结点&lt;/h1&gt;&lt;h2 id=&quot;题目要求及思路分析</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Data Structure and Agorithms" scheme="https://something.plus/tags/Data-Structure-and-Agorithms/"/>
    
  </entry>
  
  <entry>
    <title>判断是否为完全二叉树</title>
    <link href="https://something.plus/2021/06/08/Courses/2017-11-27-complete-binary-tree/"/>
    <id>https://something.plus/2021/06/08/Courses/2017-11-27-complete-binary-tree/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断是否为完全二叉树"><a href="#判断是否为完全二叉树" class="headerlink" title="判断是否为完全二叉树"></a>判断是否为完全二叉树</h1><h2 id="题目要求及思路分析"><a href="#题目要求及思路分析" class="headerlink" title="题目要求及思路分析"></a>题目要求及思路分析</h2><ul><li>题目：编写算法判别给定二叉树是否为完全二叉树。 —《数据结构习题集（C 语言版）》</li><li>思路：<ul><li>使用层序遍历二叉树</li><li>若完全二叉树中的某个结点没有左孩子，则其一定没有右孩子</li><li>若完全二叉树中的某个结点缺左孩子或右孩子，则其一定没有后继结点</li></ul></li></ul><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ol><li><p>二叉树及队列的结构体定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------二叉树的二叉链结点结构定义------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TElemType char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">TElemType data;<span class="comment">// 结点数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右 孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------队列的数据结构定义------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">BiTree data[MAXSIZE];</span><br><span class="line"><span class="type">int</span> front;</span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>队列的基本操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------以下为队列的基本操作函数----------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化一个空队列*/</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Q)<span class="keyword">return</span> ERROR;             <span class="comment">//若空间分配失败，则返回ERROR</span></span><br><span class="line">Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断SqQueue是否为空*/</span></span><br><span class="line">Status <span class="title function_">IsQueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.rear == Q.front)<span class="keyword">return</span> TRUE;           <span class="comment">//若尾指针指向头指针，则为空队列，返回TRUE</span></span><br><span class="line"><span class="keyword">else</span>&#123; <span class="keyword">return</span> FALSE; &#125;                        <span class="comment">//否则返回FALSE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入元素e为新的队尾元素*/</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q, BiTree e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>)  == MAXSIZE)<span class="keyword">return</span> ERROR;    <span class="comment">// 若队列已满，则返回ERROR</span></span><br><span class="line">Q-&gt;data[Q-&gt;rear] = e;           <span class="comment">//e 入队列</span></span><br><span class="line">Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>);                      <span class="comment">//队尾指针后移</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若队列不空，则删除队头元素，并用e返回其值*/</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q, BiTree *e)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)<span class="keyword">return</span> ERROR;    <span class="comment">//若队列为空，则返回ERROR</span></span><br><span class="line">*e = Q-&gt;data[Q-&gt;front];<span class="comment">//若队列不为空，用e接收队头元素</span></span><br><span class="line">Q-&gt;front = Q-&gt;front + <span class="number">1</span>;        <span class="comment">//队头指针后移</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------队列的基本操作函数结束----------*/</span></span><br></pre></td></tr></table></figure></li><li><p>二叉树的基本操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------基本操作的函数-------------*/</span></span><br><span class="line"><span class="comment">//按照二叉树的定义初始化一个空树</span></span><br><span class="line">Status <span class="title function_">InitBiTree</span><span class="params">(BiTree *bt)</span>&#123;</span><br><span class="line"></span><br><span class="line">*bt = (BiTree )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"><span class="keyword">if</span> (!bt)<span class="keyword">return</span> OVERFLOW;</span><br><span class="line"></span><br><span class="line">*bt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造二叉链表表示的二叉树T</span></span><br><span class="line"><span class="comment">//按先序次序输入二叉树中结点的值（一个字符）,空格字符表示空树</span></span><br><span class="line">Status <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span>&#123;</span><br><span class="line">TElemType ch;</span><br><span class="line"></span><br><span class="line">printf_s(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">getchar();<span class="comment">//getchar()用于处理回车占字符的问题</span></span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">*T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">*T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!T)<span class="keyword">return</span> OVERFLOW;<span class="comment">// 若内存分配失败，则返回OVERFLOW</span></span><br><span class="line"></span><br><span class="line">(*T)-&gt;data = ch;<span class="comment">// 生成根结点</span></span><br><span class="line">CreateBiTree(&amp;((*T)-&gt;lchild));<span class="comment">//构建左子树</span></span><br><span class="line">CreateBiTree(&amp;((*T)-&gt;rchild));<span class="comment">//构建右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>判断二叉树是否为完全二叉树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">IsCompleteBiTree</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!T)<span class="keyword">return</span> TRUE;<span class="comment">// 若为一个空树，则直接结束</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;<span class="comment">//设立一个flag，若某结点有左右孩子则为0;若某一个空了，则为1</span></span><br><span class="line"></span><br><span class="line">SqQueue Q;</span><br><span class="line">BiTree* e;</span><br><span class="line">e = (BiTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line"></span><br><span class="line">InitQueue(&amp;Q);</span><br><span class="line">EnQueue(&amp;Q, T);<span class="comment">//将根结点入队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (DeQueue(&amp;Q, e))&#123;<span class="comment">//当队列不空时</span></span><br><span class="line"><span class="keyword">if</span> (!(*e))&#123;<span class="comment">//若当前元素为空，则flag = 1，直接进行下一个循环</span></span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (flag)&#123;<span class="comment">//若当前元素不为空，且flag == 1，则证明该数不为完全二叉树</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">EnQueue(&amp;Q, (*e)-&gt;lchild);</span><br><span class="line">EnQueue(&amp;Q, (*e)-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf_s(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断是否为完全二叉树&quot;&gt;&lt;a href=&quot;#判断是否为完全二叉树&quot; class=&quot;headerlink&quot; title=&quot;判断是否为完全二叉树&quot;&gt;&lt;/a&gt;判断是否为完全二叉树&lt;/h1&gt;&lt;h2 id=&quot;题目要求及思路分析&quot;&gt;&lt;a href=&quot;#题目要求及思路分析&quot; c</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Data Structure and Agorithms" scheme="https://something.plus/tags/Data-Structure-and-Agorithms/"/>
    
  </entry>
  
  <entry>
    <title>选择排序法</title>
    <link href="https://something.plus/2021/06/08/Courses/2017-12-02-sort/"/>
    <id>https://something.plus/2021/06/08/Courses/2017-12-02-sort/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序法"><a href="#选择排序法" class="headerlink" title="选择排序法"></a>选择排序法</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p>假设已经给定了一个无序数组，现在需要将其按照一定顺序排好。现在我们使用选择排序法，每次从数组中选出一个最大的元素并将其与数组最后一个元素交换位置，使数组最后一个元素变为最大的。</p></li><li><blockquote><p>随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一个。既然如此，运行时间怎么还是<em>O</em>(<em>n</em>2)呢？这个问题问得好，这与大 O 表示法中的常数相关。第 4 章将详细解释，这里只简单地说一说。</p><p>你说得没错，并非每次都需要检查<em>n</em>个元素。第一次需要检查<em>n</em>个元素，但随后检查的元素数依次为<em>n</em> - 1, <em>n</em> – 2, …, 2 和 1。平均每次检查的元素数为 1&#x2F;2 × _n_，因此运行时间为<em>O</em>(<em>n</em> × 1&#x2F;2 × <em>n</em>)。但大 O 表示法省略诸如 1&#x2F;2 这样的常数（有关这方面的完整讨论，请参阅第 4 章），因此简单地写作<em>O</em>(<em>n</em> × <em>n</em>)或<em>O</em>(<em>n</em>2)。</p><p>​ — 《算法图解》</p></blockquote></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="C-语言实现"><a href="#C-语言实现" class="headerlink" title="C 语言实现"></a>C 语言实现</h3><p>因为 C 中对数组的删除比较麻烦，所以我没有按照《算法图解》中的思路每次选择最小的元素，而是选择了最大的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line">  <span class="comment">//C在函数中传数组长度较为麻烦，所以在数组定义出就将长度定义好传了过来</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, temp,biggest_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (length)&#123;</span><br><span class="line">         biggest_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[biggest_index] &lt; arr[i])&#123;</span><br><span class="line">biggest_index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[biggest_index]);</span><br><span class="line">temp = arr[biggest_index];</span><br><span class="line">arr[biggest_index] = arr[length - <span class="number">1</span>];</span><br><span class="line">arr[length <span class="number">-1</span>] = temp;</span><br><span class="line">length --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JAVA-语言实现"><a href="#JAVA-语言实现" class="headerlink" title="JAVA 语言实现"></a>JAVA 语言实现</h3><p>JAVA 实现思路同 C。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] SelectionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span> biggestIndex;</span><br><span class="line"><span class="type">int</span> i, temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">biggestIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[biggestIndex] &lt; arr[i]) &#123;</span><br><span class="line">biggestIndex = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">temp = arr[biggestIndex];</span><br><span class="line">arr[biggestIndex] = arr[length - <span class="number">1</span>];</span><br><span class="line">arr[length - <span class="number">1</span>] = temp;</span><br><span class="line">System.out.println(arr[length - <span class="number">1</span>]);</span><br><span class="line">length --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;选择排序法&quot;&gt;&lt;a href=&quot;#选择排序法&quot; class=&quot;headerlink&quot; title=&quot;选择排序法&quot;&gt;&lt;/a&gt;选择排序法&lt;/h1&gt;&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Data Structure and Agorithms" scheme="https://something.plus/tags/Data-Structure-and-Agorithms/"/>
    
  </entry>
  
  <entry>
    <title>图的基本操作</title>
    <link href="https://something.plus/2021/06/08/Courses/2017-12-17-basic-operation-of-graph/"/>
    <id>https://something.plus/2021/06/08/Courses/2017-12-17-basic-operation-of-graph/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h1><p>图这一章我一直觉得自己学的不是很好。。。这次就只放代码，不敢多说什么了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;<span class="comment">//顶点类型应由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;<span class="comment">//边上的权值类型应由用户定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//邻接点域，存储该顶点对应的下标</span></span><br><span class="line">EdgeType weight;<span class="comment">//用于存储权值，对于非网图可以不需要</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span><span class="comment">//链域，指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>&#123;</span><span class="comment">//顶点表结点</span></span><br><span class="line">VertexType data;<span class="comment">//顶点域</span></span><br><span class="line">EdgeNode *firstedge;<span class="comment">//边表头指针</span></span><br><span class="line">&#125;VertexNode, AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">AdjList adjList;</span><br><span class="line"><span class="type">int</span> numVertexes, numEdges;<span class="comment">//图中当前顶点数和边数</span></span><br><span class="line">&#125;GraphAdjList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头插法建立图的邻接表结构*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatALGraph</span><span class="params">(GraphAdjList *G)</span>&#123;</span><br><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line">EdgeNode *e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入顶点数和边数:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d, %d&quot;</span>, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);<span class="comment">//输入顶点数和边数</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)&#123;<span class="comment">//读入顶点信息，建立顶点表</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;G-&gt;adjList[i].data);<span class="comment">//输入顶点信息</span></span><br><span class="line">G-&gt;adjList[i].firstedge = <span class="literal">NULL</span>;<span class="comment">//将边表置为空表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G-&gt;numEdges; k++)&#123;<span class="comment">//建立边表</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入(vi, vj)上的顶点序号：\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d, %d&quot;</span>, &amp;i, &amp;j);<span class="comment">//输入(vi, vj)上的顶点序号</span></span><br><span class="line">e = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));<span class="comment">//向内存申请空间</span></span><br><span class="line">e-&gt;adjvex = j;<span class="comment">//邻接序号为j</span></span><br><span class="line">e-&gt;next = G-&gt;adjList[i].firstedge;<span class="comment">//将e指针指向当前顶点所指向的结点</span></span><br><span class="line">G-&gt;adjList[i].firstedge = e;<span class="comment">//将当前顶点的指针指向e</span></span><br><span class="line"></span><br><span class="line">e = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));<span class="comment">//向内存申请空间,生成边表结点</span></span><br><span class="line">e-&gt;adjvex = i;<span class="comment">//邻接序号为i</span></span><br><span class="line">e-&gt;next = G-&gt;adjList[j].firstedge;<span class="comment">//将e指针指向当前顶点指向的结点</span></span><br><span class="line">G-&gt;adjList[j].firstedge = e;<span class="comment">//将当前顶点的指针指向e</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图的基本操作&quot;&gt;&lt;a href=&quot;#图的基本操作&quot; class=&quot;headerlink&quot; title=&quot;图的基本操作&quot;&gt;&lt;/a&gt;图的基本操作&lt;/h1&gt;&lt;p&gt;图这一章我一直觉得自己学的不是很好。。。这次就只放代码，不敢多说什么了。&lt;/p&gt;
&lt;figure class</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Data Structure and Agorithms" scheme="https://something.plus/tags/Data-Structure-and-Agorithms/"/>
    
  </entry>
  
  <entry>
    <title>图的广度优先遍历</title>
    <link href="https://something.plus/2021/06/08/Courses/2017-12-17-bfs/"/>
    <id>https://something.plus/2021/06/08/Courses/2017-12-17-bfs/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h1><p>图这一章我一直觉得自己没学好。。。所以这次就直接放代码，不多说什么了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Boolean;<span class="comment">//Boolean是布尔类型，其值为TRUE 或者FLASE</span></span><br><span class="line">Boolean visited[MAXVEX];<span class="comment">//访问标志的数组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QElemType int      <span class="comment">// 元素类型定义为图结点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">QElemType data[MAXSIZE];</span><br><span class="line"><span class="type">int</span> front;</span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------以下为队列的基本操作函数----------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化一个空队列*/</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Q)<span class="keyword">return</span> ERROR;             <span class="comment">//若空间分配失败，则返回ERROR</span></span><br><span class="line">Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断SqQueue是否为空*/</span></span><br><span class="line">Status <span class="title function_">IsQueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.rear == Q.front)<span class="keyword">return</span> TRUE;           <span class="comment">//若尾指针指向头指针，则为空队列，返回TRUE</span></span><br><span class="line"><span class="keyword">else</span>&#123; <span class="keyword">return</span> FALSE; &#125;                        <span class="comment">//否则返回FALSE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入元素e为新的队尾元素*/</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q, QElemType e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front)<span class="keyword">return</span> ERROR;    <span class="comment">// 若队列已满，则返回ERROR</span></span><br><span class="line">Q-&gt;data[Q-&gt;rear] = e;           <span class="comment">//e 入队列</span></span><br><span class="line">Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;                      <span class="comment">//队尾指针后移</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若队列不空，则删除队头元素，并用e返回其值*/</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q, QElemType *e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)<span class="keyword">return</span> ERROR;    <span class="comment">//若队列为空，则返回ERROR</span></span><br><span class="line">*e = Q-&gt;data[Q-&gt;front];                 <span class="comment">//若队列不为空，用e接收队头元素</span></span><br><span class="line">Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;        <span class="comment">//队头指针后移</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------队列的基本操作函数完----------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------以下为广度优先遍历算法---------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(GraphAdjList G)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">SqQueue Q;</span><br><span class="line">EdgeNode* p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.numVertexes; i++)&#123;</span><br><span class="line">visited[i] = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InitQueue(&amp;Q);<span class="comment">//初始化一辅助用的队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.numVertexes; i++)&#123;<span class="comment">//对每一个顶点做循环</span></span><br><span class="line"><span class="keyword">if</span> (!visited[i])&#123;<span class="comment">//若未访问过，则如下处理</span></span><br><span class="line">visited[i] = TRUE;<span class="comment">//将当前结点设为已访问</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.adjList[i].data);<span class="comment">//打印顶点，也可以改为其它操作</span></span><br><span class="line">EnQueue(&amp;Q, i);<span class="comment">//将该顶点入队列</span></span><br><span class="line"><span class="keyword">while</span> (!IsQueueEmpty(Q))&#123;</span><br><span class="line">DeQueue(&amp;Q, &amp;i);<span class="comment">//将队头元素出队，并赋给e</span></span><br><span class="line">p = G.adjList[i].firstedge;<span class="comment">//找到当前顶点边表头指针</span></span><br><span class="line"><span class="keyword">while</span> (p)&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[p-&gt;adjvex])&#123;<span class="comment">//若当前结点未被访问过</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.adjList[p-&gt;adjvex].data);</span><br><span class="line">EnQueue(&amp;Q, p-&gt;adjvex);</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;<span class="comment">//指针指向下一个邻接点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图的广度优先遍历&quot;&gt;&lt;a href=&quot;#图的广度优先遍历&quot; class=&quot;headerlink&quot; title=&quot;图的广度优先遍历&quot;&gt;&lt;/a&gt;图的广度优先遍历&lt;/h1&gt;&lt;p&gt;图这一章我一直觉得自己没学好。。。所以这次就直接放代码，不多说什么了&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Data Structure and Agorithms" scheme="https://something.plus/tags/Data-Structure-and-Agorithms/"/>
    
  </entry>
  
  <entry>
    <title>电路交换与分组交换</title>
    <link href="https://something.plus/2021/06/08/Courses/2019-03-17-computer-network-chp-1/"/>
    <id>https://something.plus/2021/06/08/Courses/2019-03-17-computer-network-chp-1/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、电路交换与分组交换"><a href="#一、电路交换与分组交换" class="headerlink" title="一、电路交换与分组交换"></a>一、电路交换与分组交换</h1><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><ol><li>定义：<br>电路交换是以电路连接为目的的交换方式。通信之前要在通信两方之间建立一条被两方独占的物理通道。</li><li>三个阶段：<ol><li>建立连接</li><li>通信</li><li>释放连接</li></ol></li><li>优点：<ol><li>因为通信线路为通信两方用户专用，数据直达。所以数据传输的时延非常小；</li><li>通信两方之间的屋里通路一旦建立，两方能够随时通信，实时性强；</li><li>两方通信时按发送顺序传送数据，不存在失序问题；</li><li>电路交换既适用于传输模拟信号，也适用于传输数字信号；</li><li>电路交换的交换设备及控制均比较简单。</li></ol></li><li>缺点：<ol><li>电路交换平均连接建立时间对计算机通信来说较长；</li><li>电路交换家里连接后，物理通路被通信两方独占，即使通信线路空暇，也不能供其它用户使用，因而信道利用率低；</li><li>电路交换时，数据直达。不同类型、不同规格、不同速率的终端非常难相互进行通信，也难以在通信过程中进行差错控制。</li></ol></li></ol><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><ol><li>定义：<br>分组交换是以分组为单位进行传输和交换的，它是一种<em>存储——转发</em>交换方式。即将到达交换机的分组先送到存储器临时存储和处理，等到对应的输出电路有空暇时再送出。</li><li>长处：<ol><li>分组交换不须要为通信双反预先建立一条专用的通信线路。不存在连接建立时延，用户可随时发送分组；</li><li>因为采用存储转发方式，加之交换节点具有路径选择，当某条传输线路故障时可选择其它传输线路，提高了传输的可靠性；</li><li>通信双方不是固定地占用一条通信线路，而是在不同的时间一段一段地部分占用这条物理通路，因而大大提高了通信线路的利用率；</li><li>加速了数据在网络中的传输。因为分组是逐个传输，能够使后一个分组的存储操作与前一个分组的转发操作并行。这样的流水线式传输方式降低了传输时间，提升了效率；</li><li>分组长度固定，对应的缓冲区的大小也固定，所以简化了交换节点中存储器的管理；</li><li>分组较短，出错几率降低，每次重发的数据量也降低，不仅提高了可靠性，也降低了时延。</li></ol></li><li>缺点：<ol><li>因为数据进入交换节点后要经历存储转发这一过程，从而引起的转发时延（包含接受分组、检验正确性、排队、发送时间等），并且网络的通信量越大，造成的时延就越大。实时性较差；</li><li>分组交换仅仅适用于数字信号；</li><li>分组交换可能出现失序，丢失或反复分组。分组到达目的节点时，对分组按编号进行排序等工作添加了麻烦。</li></ol></li></ol><p>综上，若传输的数据量非常大，并且传送时间远大于呼叫时间。则采用<em>电路交换</em>较为合适；当端到端的通路有非常多段链路组成时，采用<em>分组交换</em>较为合适。从提高整个网络的信道利用率上看，<strong>分组交换优于电路交换</strong>。</p><h1 id="二、协议及其三要素"><a href="#二、协议及其三要素" class="headerlink" title="二、协议及其三要素"></a>二、协议及其三要素</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ol><li>定义：<br><strong>网络协议</strong>(Network protocol)： 为进行网络中的数据交换而建立的规则、标准或约定。</li><li>作用：<br>协议明确规定了所交换的数据的格式以及有关的同步问题</li></ol><h2 id="组成三要素"><a href="#组成三要素" class="headerlink" title="组成三要素"></a>组成三要素</h2><ol><li><strong>语法</strong>，即数据与控制信息的结构或格式；</li><li><strong>语义</strong>，即需要发出何种控制信息，完成何种动作以及做出何种响应:</li><li><strong>同步</strong>，即事件实现顺序的详细说明。</li></ol><h1 id="协议为什么分层？"><a href="#协议为什么分层？" class="headerlink" title="协议为什么分层？"></a>协议为什么分层？</h1><h2 id="协议各层次的功能"><a href="#协议各层次的功能" class="headerlink" title="协议各层次的功能"></a>协议各层次的功能</h2><ol><li><strong>差错控制</strong>：使相应层次对等方的通信更加可靠。</li><li><strong>流量控制</strong>：发送端的发送速率必须使接收端来得及接收，不要太快。</li><li><strong>分段和重装</strong>：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li><strong>复用和分用</strong>：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li><strong>连接建立和释放</strong>：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li></ol><h2 id="协议为什么分层"><a href="#协议为什么分层" class="headerlink" title="协议为什么分层"></a>协议为什么分层</h2><ol><li><strong>各层之间是独立的</strong>。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口(即界面)所提供的服务。由于每一层只实现一种相对独立的功能，因而可将一个难以处理的复杂问题分解为若干个较容易处理的更小一些的问题。这样，整个问题的复杂程度就下降了。</li><li><strong>灵活性好</strong>。当任何一层发生变化时(例如由于技术的变化)，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某 → 层提供的服务还可进行修改。当某层提供的服务不再需要时，甚至可以将这层取消。</li><li><strong>结构上可分割开</strong>。各层都可以采用最合适的技术来实现。</li><li><strong>易于实现和维护</strong>。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统己被分解为若干个相对独立的子系统。</li><li><strong>易于实现和维护</strong>。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统己被分解为若干个相对独立的子系统。</li></ol><h2 id="分层的缺点"><a href="#分层的缺点" class="headerlink" title="分层的缺点"></a>分层的缺点</h2><p>有些功能会在不同的层次中重复出现，因而产生了额外开销。</p><h1 id="什么是计算机网络体系结构？"><a href="#什么是计算机网络体系结构？" class="headerlink" title="什么是计算机网络体系结构？"></a>什么是计算机网络体系结构？</h1><ol><li><strong>网络的体系结构</strong>(architecure)：计算机网络的各层及其协议的集合，是这个计算机网络及其构件所应完成的功能的精确定义。</li><li>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。</li></ol><h2 id="具有五层协议的体系结构"><a href="#具有五层协议的体系结构" class="headerlink" title="具有五层协议的体系结构"></a>具有五层协议的体系结构</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机网络体系结构"></p><ol><li>应用层<ol><li>任务：是通过应用进程间的交互来完成特定网络应用。</li><li>协议：应用层协议定义的是应用进程间通信和交互的规则。</li><li><strong>报文</strong>：应用层交互的数据单元</li></ol></li><li>运输层<ol><li>任务：负责向两台主机中进程之间的通信提供通用的数据传输服务</li><li>协议：<ol><li><strong>传输控制协议 TCP</strong> (Transmission Control Protocol)一一提供面向连接的、可靠的数据传输服务，其数据传输的单位是<em>报文段</em>(segment)。</li><li><strong>用户数据报协议 UDP</strong> (User Datagram Protocol)– 提供无连接的、尽最大努力(best-effort) 的数据传输服务(不保证数据传输的可靠性)，其数据传输的单位是<em>用户数据报</em>。</li></ol></li></ol></li><li>网络层<ol><li>任务：网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</li><li>协议：使用 IP 协议</li></ol></li><li>数据链路层<br>任务：在两个相邻结点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成<em>帧</em>(framing) ，在两个相邻结点间的链路上传送<em>帧</em>(frame) 。每一<strong>帧</strong>包括<em>数据</em>和必要的<em>控制信息</em>(如同步信息、地址信息、差错控制等)。</li><li>物理层<br>任务：<ol><li>在物理层上所传数据的单位是<strong>比特</strong>。</li><li>物理层要考虑用多大的电压代表 “1”或”0” ，以及接收方如何识别出发送方所发送的比特。</li><li>物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。</li></ol></li></ol><h1 id="协议与服务的关系"><a href="#协议与服务的关系" class="headerlink" title="协议与服务的关系"></a>协议与服务的关系</h1><ol><li><strong>实体</strong>(entity)：任何可发送或接收信息的硬件或软件进程</li><li><strong>协议</strong>：控制两个对等实体(或多个实体)进行通信的规则的集合</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</li><li>协议是”<em>水平的</em>“，即协议是控制对等实体之间通信的规则。但服务是”<em>垂直的</em>“，即服务是由下层向上层通过层间接口提供的。另外，并非在一个层内完成的全部功能都称为服务。只有那些能够被高一层实体”看得见”的功能才能称之为”服务”。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、电路交换与分组交换&quot;&gt;&lt;a href=&quot;#一、电路交换与分组交换&quot; class=&quot;headerlink&quot; title=&quot;一、电路交换与分组交换&quot;&gt;&lt;/a&gt;一、电路交换与分组交换&lt;/h1&gt;&lt;h2 id=&quot;电路交换&quot;&gt;&lt;a href=&quot;#电路交换&quot; class=&quot;</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Computers and Digital Systems" scheme="https://something.plus/tags/Computers-and-Digital-Systems/"/>
    
  </entry>
  
  <entry>
    <title>图的深度优先遍历</title>
    <link href="https://something.plus/2021/06/08/Courses/2017-12-17-dfs/"/>
    <id>https://something.plus/2021/06/08/Courses/2017-12-17-dfs/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h1><p>图这一章我一直觉得自己学的不是很好。。。这次就只放代码，不敢多说什么了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Boolean;<span class="comment">//Boolean是布尔类型，其值为TRUE 或者FLASE</span></span><br><span class="line">Boolean visited[MAXVEX];<span class="comment">//访问标志的数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先递归算法*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphAdjList G, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">EdgeNode *p;</span><br><span class="line">visited[i] = TRUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.adjList[i].data);<span class="comment">//打印定点，也可以是其它操作</span></span><br><span class="line">p = G.adjList[i].firstedge;</span><br><span class="line"><span class="keyword">while</span> (p)&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[p-&gt;adjvex])DFS(G, p-&gt;adjvex);<span class="comment">//对未访问的邻接顶点递归调用</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接矩阵的深度遍历操作*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(GraphAdjList G)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.numVertexes; i++)&#123;</span><br><span class="line">visited[i] = FALSE;<span class="comment">//初始化所有顶点状态都是未访问的状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.numVertexes; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[i])DFS(G, i);<span class="comment">//对未访问过的顶点调用DFS，若连通图，只会执行一次</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图的深度优先遍历&quot;&gt;&lt;a href=&quot;#图的深度优先遍历&quot; class=&quot;headerlink&quot; title=&quot;图的深度优先遍历&quot;&gt;&lt;/a&gt;图的深度优先遍历&lt;/h1&gt;&lt;p&gt;图这一章我一直觉得自己学的不是很好。。。这次就只放代码，不敢多说什么了。&lt;/p&gt;
&lt;figu</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Data Structure and Agorithms" scheme="https://something.plus/tags/Data-Structure-and-Agorithms/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://something.plus/2021/06/08/Courses/2019-03-24-computer-network-chp2/"/>
    <id>https://something.plus/2021/06/08/Courses/2019-03-24-computer-network-chp2/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><blockquote><p>首先强调指出，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体</p></blockquote><h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><ol><li><p>物理层的主要任务：确定与传输媒体的接口有关的一些特性</p><ol><li><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸，引脚数目和排列，固定和锁定装置等。</li><li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压的范围</li><li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压表示何种意义</li><li><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序</li></ol></li><li><p><strong>串行传输</strong>：数据在通信线路（传输媒体）上的传输方式一般都是串行传输，即逐个比特按照时间顺序传输。因此物理层还要完成传输方式的转换。</p></li></ol><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="数据通信系统的三大部分"><a href="#数据通信系统的三大部分" class="headerlink" title="数据通信系统的三大部分"></a>数据通信系统的三大部分</h3><ol><li><p><strong>源系统</strong>（发送端、发送方）</p><ol><li>_源点_：源点设备产生要传输的数据，又称为源站或信源</li><li>_发送器_：<ul><li>通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。</li><li>典型的发送器就是调制器。</li></ul></li></ol></li><li><p><strong>传输系统</strong>（传输网络）</p></li><li><p><strong>目的系统</strong>（接收端、接收方）</p><ol><li>_接收器_：<ul><li>接受传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。</li><li>典型的接收器就是解调器</li></ul></li><li>_终点_：终点设备从接收器获取传送来的数字比特流，然后把信息输出，又称为<em>目的站</em>或<em>信宿</em></li></ol></li></ol><h4 id="常用术语："><a href="#常用术语：" class="headerlink" title="常用术语："></a>常用术语：</h4><ul><li><p><strong>通信</strong>：目的是传送消息（Message），如话音、文字、图像、视频等</p></li><li><p><strong>数据</strong>：是运送信息的实体，通常是有意义的符号序列</p></li><li><p><strong>信号</strong>：是数据的电气或电磁的表现，根据信号中代表信息的参数的取值方式不同，信号可分为两大类：</p><ol><li><p>_模拟信号_（连续信号）——代表信息的参数的取值是连续的</p></li><li><p>_数字信号_（离散信号）——代表信息的参数的取值是离散的</p></li></ol></li><li><p><strong>码元</strong>：在使用时间域（或简称为时域）的波形表示数字信号时，则代表不同离散数值的基本波形</p></li></ul><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条<em>发送信道</em>和一条<em>接受信道</em>。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ol><li><p><strong>单向通信（单工通信）</strong>：即只能有一个方向的通信而没有反方向的交互，例如电视广播</p></li><li><p><strong>双向交替通信（半双工通信）</strong>：即通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收），是一方发送，另一方接收，过一段时间后再反过来</p></li><li><p><strong>双向同时通信（全双工通信）</strong>：即通信的双方可以同时发送和接收信息</p></li></ol><p><strong>基带信号</strong>：来自信源的信号。基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。所以，必须对基带信号进行<em>调制</em>。</p><p><strong>调制</strong>：</p><ol><li><p><strong>基带调制</strong>：仅仅对基带信号的波形进行变换，使它能够与信道特性相适应，变换后信号仍然是基带信号。因此大家更愿意把这种过程称为<strong>编码</strong>。</p></li><li><p><strong>带通调制</strong>：需要使用<em>载波</em>进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>（即仅在一段频率范围内能够通过信道）。</p></li></ol><h4 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h4><p><img src="http://storage.qiniu.aspi.tech/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="数字信号常用的编码方式"></p><ol><li><p><strong>不归零制</strong>：正电平代表 1，负电平代表 0</p></li><li><p><strong>归零制</strong>：正脉冲代笔哦啊 1，负脉冲代表 0</p></li><li><p><strong>曼切斯特编码</strong>：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1，也可以反过来定义</p></li><li><p><strong>差分曼切斯特编码</strong>：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1</p></li></ol><h4 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h4><p><img src="http://storage.qiniu.aspi.tech/%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95.png" alt="最基本的三种调制方式"></p><ol><li><p><strong>调幅（AM）</strong>：即载波的振幅随基带数字信号而变化，例如，0 或 1 分别对应于无载波或有载波输出</p></li><li><p><strong>调频（FM）</strong>：即载波的频率随基带数字信号而变化，例如，0 或 1 分别对应于频率 f1 或 f2</p></li><li><p><strong>调相（PM）</strong>：即载波的初始相位随基带数字信号而，例如，0 或 1 分别对应于相位 0 度或 180 度</p></li></ol><h4 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h4><p>码元传输的速率越高，或信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形的失真就越严重。从概念上讲，限制码元在信道上的传输速率有以下两个：</p><ol><li><p>信道能够通过的频率范围</p><ul><li><strong>码间串扰</strong>：<ul><li>在接收端收到的信号波形失去了码元之间的清晰界限。</li></ul></li><li><strong>奈氏准则</strong>：在任何信道中，码元传输的速率是有上限的，传输速率超过次上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li><li>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</li></ul></li><li><p>信噪比</p><ol><li><strong>信噪比</strong>：<ul><li>信号的平均功率和噪声的平均功率之比，常记为 S&#x2F;N，并用分贝（dB）作为度量单位。</li><li>即：信噪比(dB) &#x3D; 10 log10(S&#x2F;N) (dB)</li></ul></li><li><strong>香农公式</strong>：<ul><li>信道的极限信息传输速率 C 是:C &#x3D; W log2(1+S&#x2F;N) (bit&#x2F;s)</li><li><em>W</em>为信道的带宽（以 Hz 为单位）；<em>S</em>为信道内所传信号的平均功率；<em>N</em>为信道内部的高斯噪声功率。</li><li>香农公式表明：<em>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</em></li><li>香农公式的意义：<em>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</em></li><li>除此之外，还有一个提高信息的传输速率的方法，就是用编码的方法让每一个码元携带更多比特的信息量</li></ul></li></ol></li></ol><h3 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h3><h4 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h4><p><strong>传输媒体</strong>也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。</p><ol><li><p>导引型传输媒体：电磁波被导引沿着固定媒体（铜线或光纤）传播</p></li><li><p>非导引型传输媒体：指自由空间，常称为无线传输</p></li></ol><h5 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h5><ol><li><p>双绞线：</p><ul><li><p>把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合起来就构成双绞线。</p></li><li><p>它是最古老但又是最常用的传输媒体。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。导线越粗，其通信距离就越远，但导线的价格也越高</p></li><li><p>为了提高双绞线的抗电磁干扰的能力，可以在双绞线外面再加上一层用金属丝编织成的屏蔽层，也就是<strong>屏蔽双绞线</strong>，简称 STP，价格比无屏蔽双绞线 UTP 要贵一些</p></li><li><p>现在常用的 UTP 是 5 类线</p></li><li><p>直通：A——A 异类相接 B——B</p></li><li><p>交叉：A——B 同类相接</p></li></ul></li></ol><table><thead><tr><th>序号</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>A 序</td><td>绿白</td><td>绿</td><td>橙白</td><td>蓝</td><td>蓝白</td><td>橙</td><td>棕白</td><td>棕</td></tr><tr><td>B 序</td><td>橙白</td><td>橙</td><td>绿白</td><td>蓝</td><td>蓝白</td><td>绿</td><td>棕白</td><td>棕</td></tr></tbody></table><ol start="2"><li><p><strong>同轴电缆</strong>：由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及保护塑料外层所组成。</p><ul><li><p>同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。</p></li><li><p>同轴电缆的带宽取决于电缆的质量。</p></li><li><p>50 欧姆：粗，LAN&#x2F;数字传输常用</p></li><li><p>75 欧姆：细，有线电视&#x2F;模拟传输常用</p></li></ul></li><li><p><strong>光缆</strong>：光纤通信就是利用光导纤维传递光脉冲来进行通信，有光脉冲相当于 1，没有光脉冲相当于 0。 光纤是光纤通信的传输媒体。</p><ul><li><p>多模光纤：可以存在多条不同角度入射的光纤在一条光钎中传输</p></li><li><p>单模光钎：光钎的直径减小到只有一个光的波长，则光钎就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射</p></li></ul><p>在光钎通信中常用的三个波段的中心分别位于 850nm，1310nm 和 1550nm。所以这三个波段都具有 25000-30000GHz 的宽带</p><ul><li><p>光钎的优点：</p><ol><li><p>通信容量大；</p></li><li><p>传输损耗小，中继距离长，对远距离传输特别经济；</p></li><li><p>抗雷电和电磁干扰性能好，这在有大电流脉冲干扰的环境下尤为重要；</p></li><li><p>无串音干扰，保密性好，也不易被窃听或截取数据；</p></li><li><p>体积小，重量轻，这在现有电缆管道已拥塞不堪的情况下特别有利。</p></li></ol></li></ul></li></ol><h3 id="信道复用技术（提高信道利用率）"><a href="#信道复用技术（提高信道利用率）" class="headerlink" title="信道复用技术（提高信道利用率）"></a>信道复用技术（提高信道利用率）</h3><ul><li><p><strong>复用</strong>：通信技术中的基本概念</p></li><li><p><strong>频分复用</strong>：</p><ul><li>用户在分配到一定的频带后，在通信过程中自始自终都占用这个频带。</li><li>所有用户在同样的时间占用不同的宽带资源。</li></ul></li><li><p><strong>时分复用</strong>：</p><ul><li>将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>所有用户是在不同的时间占用同样的频带宽度。</li><li>由于计算机的<strong>突发性质</strong>，用户对已经分配到的子信道的利用率一般是不高的</li></ul></li><li><p><strong>统计时分复用</strong>：是一种改进的时分复用，它能明显地提高信道的利用率</p></li><li><p><strong>波分复用</strong>：光的频分复用，借用传统的载波电话的频分复用的概念，使用一根光纤来同时传送多个频率很接近的光载波信号</p></li><li><p><strong>码分复用</strong>：</p><ul><li>每一个用户可以在同样的时间使用同样的频带进行通信。</li><li>由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</li></ul></li></ul><h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><ul><li><p><strong>ADSL 技术</strong>：非对称数字用户线，是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带数字业务。</p></li><li><p><strong>光纤同轴混合网（HFC 网）</strong>：目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传送电视节目外，还能提供电话、数据和其他宽带交互型业务。</p></li><li><p><strong>FTTx 技术</strong>：光纤到 x 技术，这里的 x 可代表不同的光纤接入点</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;物理层&quot;&gt;&lt;a href=&quot;#物理层&quot; class=&quot;headerlink&quot; title=&quot;物理层&quot;&gt;&lt;/a&gt;物理层&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;首先强调指出，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体&lt;/</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Computer Network" scheme="https://something.plus/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>《微机原理与接口技术（第五版）》第一章</title>
    <link href="https://something.plus/2021/06/08/Courses/2019-05-29-the-principle-of-microcomputer-chp1/"/>
    <id>https://something.plus/2021/06/08/Courses/2019-05-29-the-principle-of-microcomputer-chp1/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><blockquote><p>本总结笔记基于钱晓捷老师的《微机原理与接口技术（第五版）》</p></blockquote><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><ul><li>计算集的运算和控制核心，即<em>中央处理单元</em>（CPU, Central Process Unit）</li><li><em>微处理器</em>(Micrprocessor):<ul><li>一块大规模集成电路芯片</li><li>代表着整个微型机系统的性能</li><li>_微型机_：采用微处理器为核心构造的计算机</li></ul></li></ul><h2 id="处理器性能参数"><a href="#处理器性能参数" class="headerlink" title="处理器性能参数"></a>处理器性能参数</h2><ul><li><strong>字长</strong>：处理器每个时间单位可以处理的二进制数据位数</li><li><strong>时钟频率</strong>：表明处理器的处理速度，反映了处理器的基本时间单位</li><li><strong>集成度</strong>：表明处理器的生产工艺水平，通常用芯片上集成的晶体管数量来表达</li></ul><h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><p><strong>摩尔定律</strong>：每 18 个月，集成电路的性能将提高一倍，而其价格将降低一半</p><h2 id="处理器总线"><a href="#处理器总线" class="headerlink" title="处理器总线"></a>处理器总线</h2><ul><li><strong>系统总线</strong>：<ul><li>用于多个部件相互连接、传递信息的公共通道</li><li>任一时刻再总线上智能传送一种信息，但可以由多个部件在接收信息</li></ul></li><li><strong>数据总线</strong>：<ul><li>是处理器与存储器或外设交换信息的通道</li><li>其个数（条数）就是一次能够传送数据的二进制位数，通常<em>等于处理器字长</em></li><li>处理器的数据通过该组信号线输出到主存或外设，可以<em>双向传输</em>信号</li></ul></li><li><strong>地址总线</strong>：<ul><li>用于指定存储器或外设的具体单元</li><li>其个数反映处理器能够访问的主存储器容量或外设范围</li><li>在该组信号线上，处理器<em>单向输出</em>将要访问的主存单元或 I&#x2F;O 端口的地址信息</li></ul></li><li><strong>控制总线</strong>：<ul><li>用于协调系统中各部件的操作</li><li>控制总线决定了总线的功能强弱、适应性的好坏</li><li>各类总线的特点主要取决于其控制总线</li></ul></li></ul><h2 id="80x86-系列处理器"><a href="#80x86-系列处理器" class="headerlink" title="80x86 系列处理器"></a>80x86 系列处理器</h2><ul><li>_8086_：<ul><li>主存容量为 2^20 B &#x3D; 1 MB</li></ul></li><li><em>80286</em>:<ul><li>主存容量为 2^32 B &#x3D; 4 GB</li></ul></li></ul><h2 id="冯·诺伊曼计算机的基本思想"><a href="#冯·诺伊曼计算机的基本思想" class="headerlink" title="冯·诺伊曼计算机的基本思想"></a>冯·诺伊曼计算机的基本思想</h2><ul><li>采用<em>二进制</em>形式表示数据和指令，指令由<em>操作码</em>和<em>地址码</em>组成<ul><li>指令是控制计算机操作的命令，是处理器不需要翻译就能识别（直接执行）的“母语”，即机器语言</li><li>程序是由指令构成的</li><li>指令的操作码表明指令的操作</li><li><em>操作数</em>是参与操作的数据，主要以寄存器或存储器地址形式指明数据的来源，所以也称<strong>地址码</strong></li></ul></li><li>“<strong>存储程序</strong>”、“<strong>程序控制</strong>”<ul><li>存储程序：把指令以代码的形式事先输入到计算机的主存储器中，这些指令按一定的规则组成程序</li><li>程序控制：当计算机启动后，程序会控制计算机按规定的顺序逐条执行指令，自动完成预定的信息处理任务</li></ul></li><li>指令的执行是<em>顺序</em>的，即一般按照指令再存储器中存放的顺序执行，程序分支由转移指令实现</li><li>计算机由<em>存储器、运算器、控制器、输入设备和输出设备</em>5 大基本部件组成。</li></ul><p>数字计算机中信息的最基本单位就是<em>二进制位</em>，或称<em>比特位</em>。</p><ul><li>半字节：4 个二进制位</li><li>一字节：8 个二进制位</li><li>字：16 位</li><li>双字：32 位</li><li>四字：64 位</li></ul><h2 id="处理器的主要功能"><a href="#处理器的主要功能" class="headerlink" title="处理器的主要功能"></a>处理器的主要功能</h2><ul><li><strong>取指</strong>：从主存储器读取指令</li><li><strong>译码</strong>：翻译指令代码的功能</li><li><strong>执行</strong>：执行指令所规定的操作</li></ul><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><ul><li>存储器：用来存放程序和数据的部件</li><li>_主存储器_：<ul><li>造价高、速度快、容量小</li><li>用来存放当前正在运行的程序和正待处理的数据</li></ul></li><li>_辅助存储器_（简称<em>辅存</em>或<em>外存</em>）:<ul><li>造价低、容量大、信息可长期保存、速度慢</li><li>主要用来长久保存程序和数据</li></ul></li></ul><h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p><img src="http://storage.qiniu.aspi.tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机系统的层次结构"></p><ul><li>_用户层_：<ul><li>是计算机用户看到的计算机</li><li>呈现给用户的是可执行程序和数据文件</li></ul></li><li>_高级语言层_：<ul><li>面向软件程序员</li></ul></li><li>_汇编语言层_：<ul><li>面向系统程序员</li><li>汇编语言程序员需要利用操作系统提供的功能，掌握指令系统，理解主存储器的组织</li></ul></li><li>_操作系统层_：<ul><li>操作系统是最主要的系统程序，也称为系统软件层</li></ul></li><li>_机器语言层_：<ul><li>由处理器直接识别的指令组成，面向系统结构设计师</li><li>该层具有承上启下的功能。一方面为上层软件提供硬件指令支持，另一方面是下层硬件实现的目标</li></ul></li><li>_控制层_：<ul><li>面向硬件设计师</li><li>这一层由微程序实现，也可以由硬布线实现</li></ul></li><li>_数字电路层_：<ul><li>是计算机的具体物理实现</li></ul></li></ul><h2 id="软件与硬件的等价性原理"><a href="#软件与硬件的等价性原理" class="headerlink" title="软件与硬件的等价性原理"></a>软件与硬件的等价性原理</h2><ul><li>原则上说，任何一个由软件所完成的操作也可以直接由硬件来实现，任何一条由硬件所执行的指令也能用软件来完成。</li><li>软件与硬件的等价性原理是指<em>软硬件在逻辑功能上的等价</em>，并<em>不意味</em>着在现实中性能和成本的等价。<ul><li>软件易于实现各种逻辑和运算功能，但是往往速度较慢，甚至不能满足时间要求</li><li>硬件则可以高速实现逻辑和运算功能，但是难以实现复杂功能或计算，甚至无法实现</li></ul></li></ul><h2 id="计算机的结构、组成与实现"><a href="#计算机的结构、组成与实现" class="headerlink" title="计算机的结构、组成与实现"></a>计算机的结构、组成与实现</h2><ul><li><strong>计算机结构</strong>：<ul><li>计算机结构是指为机器编写正确的（时间无关的）程序、机器语言程序员必须理解的一种结构。</li><li><strong>指令集结构</strong>：<ul><li>计算机结构的经典定义确定了计算机系统中软件和硬件的接口，即<em>指令集结构</em></li><li>它包括指令集（指令系统）、指令格式、数据类型、寄存器、寻址方式、主存访问方式和 I&#x2F;O 机制等</li></ul></li></ul></li><li><strong>计算机组成</strong>：<ul><li>也称为<em>计算机组织</em>，是计算机结构的逻辑实现（逻辑设计），对应计算机层次结构的控制层。</li></ul></li><li><strong>计算机实现</strong>：<ul><li>是计算机组成物理实现，对应<em>数字电路层</em></li></ul></li></ul><h2 id="软件兼容与系列机和兼容机"><a href="#软件兼容与系列机和兼容机" class="headerlink" title="软件兼容与系列机和兼容机"></a>软件兼容与系列机和兼容机</h2><ul><li><strong>软件兼容</strong>：指<em>同一个厂家</em>生产的具有<em>相同计算机结构</em>，但具有<em>不同组成和实现</em>的一系列不同档次、不同型号的机器。</li><li><strong>兼容机</strong>：指<em>不同厂家</em>生产的具有<em>相同计算机结构</em>（_不同的组成和实现_）的计算机</li><li>为了保证软件的<strong>向上向下、向前向后兼容</strong>，系列机和兼容机必须保持结构不变，但这又限制了计算机结构的发展</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本总结笔记基于钱晓捷老师的《微机原理与接口技术（第五版）》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Computers and Digital Systems" scheme="https://something.plus/tags/Computers-and-Digital-Systems/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://something.plus/2021/06/08/Courses/2019-06-09-computer-network-chp3/"/>
    <id>https://something.plus/2021/06/08/Courses/2019-06-09-computer-network-chp3/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>信道分类：</p><ul><li><strong>点对点信道</strong>：这种信道使用<em>一对一</em>的点对点通信方式</li><li><strong>广播信道</strong>：这种信道使用<em>一对多</em>的广播通信方式</li></ul><p><img src="http://storage.qiniu.aspi.tech/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%9C%B0%E4%BD%8D%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%9C%A8%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E6%B5%81%E5%8A%A8.png" alt="数据链路层的位置及数据在数据链路层的流动"></p><blockquote><p><em>不同的链路层可能使用不同的数据链路层协议</em></p></blockquote><h2 id="使用点对点的数据链路层"><a href="#使用点对点的数据链路层" class="headerlink" title="使用点对点的数据链路层"></a>使用点对点的数据链路层</h2><ul><li><strong>链路</strong>：<ul><li>就是从一个结点到相邻结点的一段物理线路（有线或无线）</li><li>链路只是一条路径的组成部分</li><li><strong>数据链路</strong>：<ul><li>当需要在一条线路上传送数据时，出了必须有一条物理线路外，还必须有一些的必要的通信协议来控制这些数据的传输</li><li>一般的网络适配器都包括了<em>数据链路层</em>和<em>物理层</em>这两层的功能</li></ul></li><li>若把链路分为物理链路和逻辑链路：<ul><li><strong>物理链路</strong>就是上面所说的链路</li><li><strong>逻辑链路</strong>就是上面的数据链路，即物理链路加上必要的通信协议</li></ul></li></ul></li><li><strong>帧</strong>：点对点信道的数据链路层的协议数据单元<ul><li>数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，以及把接收到的<strong>帧</strong>中的数据取出并上交给网络层。</li><li>网络层协议数据单元是<strong>IP 数据报</strong>（简称<strong>数据报</strong>、<strong>分组</strong>或<strong>包</strong>）</li></ul></li></ul><p><img src="http://storage.qiniu.aspi.tech/%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png" alt="使用点对点信道的数据链路层"></p><p>点对点信道的数据链路层在进行通信时的主要步骤如下：</p><ol><li>结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成<em>帧</em></li><li>结点 A 把封装好的帧发送给结点 B 的数据链路层</li><li>若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧</li></ol><p>数据链路层不必考虑物理层如何实现比特传输的细节。</p><p>数据链路层协议有许多种，但有三个问题则是共同的：</p><ol><li><strong>封装成帧</strong>：就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧<ul><li>分组交换的一个重要概念：所有在互联网上传送的数据都以<em>分组（即 IP 数据报）</em>为传送单位</li><li>网络层的 IP 数据报传送到数据链路层就成为帧的数据部分</li><li>在帧的数据部分的前面和后面分别添加上首部和尾部，就构成了一个完整的帧<ul><li>首部和尾部一个重要作用就是进行<strong>帧定界</strong>（即确定帧的界限）</li><li>首部和尾部包括许多必要的控制信息</li><li>为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度</li></ul></li><li>每一种链路层协议都规定了所能传送的帧的数据部分长度上限——<strong>最大传送单元 MTU</strong>(Maximum Transfer Unit)</li></ul></li><li><strong>透明传输</strong><ul><li>由于帧的开始和结束的标记使用专门指明的控制字符。因此，所传输的数据中的任何 8 比特的组合一定<strong>不允许</strong>和用作帧定界的控制字符的比特编码一样，_否则就会出现帧定界的错误_。</li><li><strong>透明</strong>是指：某一个实际存在的事物看起来却好像不存在一样</li><li>“在数据链路层透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。或者说，数据链路层对这些数据来说是透明的。</li></ul></li><li><strong>差错控制</strong><ul><li><strong>比特差错</strong>：<ul><li>比特在传输过程中可能会产生差错：1 可能变成 0，0 可能变成 1</li></ul></li><li><strong>误码率 BER</strong>(Bit Error Rate)：在一段时间内，传输错误的比特占所传输比特总数的比率<ul><li>若设法提高信噪比，就可以使误码率减小</li></ul></li><li><em>凡是接收端数据链路层接收的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程没有产生差错</em><ul><li>接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受</li><li>也可近似地表述为“凡是接收端数据链路层接受的帧均无差错”</li></ul></li><li><strong>可靠传输</strong>：数据链路层的发送端发送什么，在接收端就收到什么</li><li>传输差错可分为两类：<ul><li>一类即前面的最基本的比特差错</li><li>另一类传输差错更复杂些，虽然收到的帧没有出现比特差错，但却出现了<strong>帧丢失</strong>、<strong>帧重复</strong>或<strong>帧失序</strong></li></ul></li></ul></li></ol><h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><p>PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议</p><ul><li>PPP 协议应满足的需求<ol><li><strong>简单</strong><ul><li>接收方每收到一个帧，就进行 CRC 检验。入如 CRC 检验正确，就收下这个帧；反之，就丢弃这个帧，其他什么也不做</li></ul></li><li><strong>封装成帧</strong><ul><li>PPP 协议必须规定特殊的宇符作为<strong>帧定界符</strong>(即标志一个帧的开始和结束的字符)，以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。</li></ul></li><li><strong>透明性</strong><ul><li>PPP 协议必须保证数据传输的透明性</li></ul></li><li><strong>多种网络层协议</strong><ul><li>PPP 协议必须能够在<strong>同一条物理链路上同时支持多种网络层协议</strong></li></ul></li><li><strong>多种类型链路</strong><ul><li>除了要支持多种网络层的协议外， PPP 还必须能够在多种类型的链路上运行</li></ul></li><li><strong>差错检测</strong><ul><li>PPP 协议必须能够对接收端收到的帧进行检测，并<strong>立即丢弃有差错的帧</strong></li></ul></li><li><strong>检测链接状态</strong><ul><li>PPP 协议必须具有一种机制能够及时(不超过几分钟)自动检测出链路是否处于正常工作状态</li></ul></li><li><strong>最大传送单元</strong><ul><li>PPP 协议必须对每 → 种类型的点对点链路设置最大传送单元 MTU 的标准默认值。这样做是为了<strong>促进各种实现之间的互操作性</strong></li><li>MTU 是数据链路层的帧可以载荷的<strong>数据部分</strong>的最大长度，而<strong>不是帧的总长度</strong>。</li></ul></li><li><strong>网络层地址协商</strong> - PPP 协议必须提供一种机制使通信的两个网络层(例如，两个 IP 层)的实体能够通过协商知道或能够配置彼此的网络层地址。 10.** 数据压缩协商** - PPP 协议必须提供一种方法来协商使用数据压缩算法</li></ol></li><li>PPP 协议的组成<ol><li>_一个将 IP 数据报封装到串行链路的方法_。 PPP 既支持异步链路(无奇偶检验的 8 比特数据)，也支持面向比特的同步链路。 IP 数据报在 PPP 帧中就是其信息部分。这个信息部分的长度受最大传送单元 MTU 的限制。</li><li><em>一个用来建立、配置和测试数据链路连接的链路控制协议 LCP</em> (Link Control Protocol)。通信的双方可协商一些选项。</li><li><em>一套网络控制协议 NCP</em> (Network Control Protocol)，其中的每一个协议支持不同的网络层协议。</li></ol></li></ul><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><ul><li><strong>局域网</strong>：<ul><li>最主要的<strong>特点</strong>：网络为一个单位所拥有，且地理范围和站点数目均有限</li><li>主要优点：<ol><li>具有广播功能，从一个站点可很方便地访问全网</li><li>便于系统的扩展和逐渐演变，各设备的位置可灵活调整和改变</li><li>提高了系统的可靠性、可用性和生存性</li></ol></li><li>共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便地共享通信媒体资源。这在技术上有两种方法：<ul><li><strong>静态划分信道</strong>。用户只要分配到了信道就不会和其他用户发生冲突。</li><li><strong>动态媒体介入控制</strong>，又称为<strong>多点接入</strong>。<ul><li>特点：信道并非在用户通信时固定分配给用户</li><li>分为两类：<ul><li>随机接入</li><li>受控接入</li></ul></li></ul></li></ul></li></ul></li><li><strong>适配器</strong>：<ul><li><strong>作用</strong>：计算机与外界局域网的连接是通过通信适配器进行的。<ul><li>适配器和局域网之间的通信是通过电缆或双绞线以<em>串行传输</em>方式进行的</li><li>适配器与计算机之间的通信是通过计算机主板上的 I&#x2F;O 总线以<em>并行传输</em>方式进行的</li></ul></li><li>适配器在接收和发送各种帧时，不使用计算机的 CPU</li></ul></li><li>CSMA&#x2F;CD 协议：<ul><li>CSMA&#x2F;CD 指<strong>载波监听多点接入&#x2F;碰撞检测</strong>（Carrier Sense Multiple Access with Collision Detection）</li><li>为了通信的简便，以太网采取以下两种措施：<ol><li>采用较为灵活的<strong>无连接</strong>的工作方式，即<em>不必先建立连接就可以直接发送数据</em>。<ul><li>适配器对发送的数据帧<strong>不进行编号，也不要求对方发回确认</strong>。<ul><li>原因：局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。</li><li>以太网提供的服务是<em>尽最大努力的交付</em>，即<strong>不可靠的交付</strong></li></ul></li><li>对有差错帧是否需要重传则由高层来决定</li><li>总线上，_在同一时间只能允许一台计算机发送数据_，否则各计算机之间就会相互干扰。</li></ul></li><li>以太网发送的数据都使用<strong>曼彻斯特编码</strong>的信号。<ul><li>曼彻斯特编码的编码方法：把每一个码元再分成两个相等的间隔</li><li>优点：保证了每一个码元的正中间出现一次电压的转换，而接收端就利用这种电压的转换很方便地把位同步信号提取出来</li><li>缺点：它所占的频带宽度比原始的基带信号增加了一倍（因为每秒传送的码元数加倍了）</li></ul></li></ol></li><li>CSMA&#x2F;CD 协议的要点：<ul><li><strong>“多点接入”</strong><ul><li>许多计算机以多点接入的方式连接在一根总线上</li><li>协议的实质是：“载波监听”和“碰撞检测”</li></ul></li><li><strong>“载波监听”</strong><ul><li>用电子技术检测总线上有没有其他计算机也在发送，即<strong>检测信号</strong></li><li>不管在发送前，还是在发送中，每个站都必须不停地检测信道</li></ul></li><li><strong>“碰撞检测”</strong><ul><li>“边发送边监听”。即适配器边发送数据边检测信道上的信号电压的变化情况，一边判断自己在发送数据时其他站是否也在发送数据。</li></ul></li></ul></li><li>在使用 CSMA&#x2F;CD 协议时，一个站<em>不可能同时进行发送和接收</em>。因此使用该协议的以太网不可能进行全双工通信而只能进行<strong>双向交替通信（半双工通信）</strong></li></ul></li><li><strong>集线器</strong><ul><li>双绞线以太网总是和集线器配合使用的</li><li>集线器的特点：<ul><li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是 CSMA&#x2F;CD 协议。<ul><li>网络中的各站必须竞争对传输媒体的控制，并且在同一时刻至多只允许一个站发送数据</li></ul></li><li>一个集线器有许多接口</li><li>集线器工作在物理层。它的每个接口<strong>仅仅简单地转发比特</strong>，<strong>不进行碰撞检测</strong></li><li>集线器采用了专门的芯片，进行自适应传音回波抵消。<ul><li>这样可以使接口转发出去的较强信号不致对该接口接收到的较弱信号产生干扰</li></ul></li></ul></li></ul></li><li>MAC 层的硬件地址<ul><li><strong>硬件地址</strong>又称为<em>物理地址</em>或<em>MAC 地址</em>，实际上就是适配器地址</li><li>在标识系统中，地址是识别某个系统的一个非常重要的标识符</li><li>“名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处”</li><li>严格地讲，名字应当与系统所在地无关</li></ul></li></ul><h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><ul><li>常用方法：<ul><li><strong>网桥</strong>：对收到的额帧根据其 MAC 帧的地址进行<em>转发</em>和<em>过滤</em><ul><li>一次只能分析和转发一个帧</li></ul></li><li><strong>交换式集线器</strong>：常称为第二层交换机或以太网交换机<ul><li>这种交换机<strong>工作在数据链路层</strong></li><li>特点<ul><li>实质上就是一个<strong>多接口的网桥</strong>。<ul><li>每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。</li></ul></li><li>具有并行性。能同时连通多对接口，使多对主机能同时通信。</li><li>相互通信的主机都是<strong>独占传输媒体，无碰撞地传输数据</strong></li><li>以太网交换机地接口还有存储器，能在输出端口繁忙时<em>把到来的帧进行缓存</em>，以获取目的 MAC 地址</li><li>以太网交换机是一种即插即用设备。</li></ul></li><li>以太网交换机处理帧的方法：<ol><li>对收到的帧采用<strong>存储转发</strong>方式进行转发</li><li>对收到的帧采用<strong>直通</strong>交换方式</li></ol></li></ul></li></ul></li><li>虚拟局域网 VLAN<ul><li>虚拟局域网是由一些局域网网段构成的<em>与物理位置无关的逻辑组</em></li><li>每一个 VLAN 帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个 VLAN</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;p&gt;信道分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;点对点信道&lt;/strong&gt;：这种信道使用&lt;em&gt;一对一&lt;/e</summary>
      
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Computer Network" scheme="https://something.plus/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>2019 Robocup 赛后总结</title>
    <link href="https://something.plus/2021/06/08/Essays/2019-04-24-2019-robocup-summary/"/>
    <id>https://something.plus/2021/06/08/Essays/2019-04-24-2019-robocup-summary/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019-Robocup-赛后总结"><a href="#2019-Robocup-赛后总结" class="headerlink" title="2019 Robocup 赛后总结"></a>2019 Robocup 赛后总结</h1><p><img src="http://storage.qiniu.aspi.tech/2019robocup/%E8%B5%9B%E5%90%8E%E5%90%88%E7%85%A7.jpg"></p><blockquote><p>任对方调得激烈，我方自是唠的火热。倒也是挺符合我们的队名：不管怎么样反正 NAO 就队!</p></blockquote><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>上周我们有幸代表郑州大学去绍兴参加 2019 年 Robocup 中国赛。</p><p>作为第一次参加的队伍，我们今年的准备并不充分。一开始大家并没有使用 BHuman 平台，而是从网上找的各种资料来用 Python 自己造轮子。从寒假到 3 月底，我们用了足足三个月的时间造了一个不那么圆的轮子……直到三月底政乔跟其他学校交流，我们才知道大部分队伍用的是 BHuman 平台。</p><p>四月初，在我和政乔去同济学习回来后，我们才算是真正开始准备本次比赛。而此时，距大赛开始只有不到半个月的时间。</p><p>因为只有半个月的时间，所以太过仓促了。BHuman 平台中的许多调试工具都没用上，购买的绿毯也比正式比赛的场地要硬得多……在学校调试的防守员下坐防御动作在比赛场地上根本不能用，只要下坐就会往前倒。临出发前，5 号的头部风扇一直嗡嗡响，备用机 6 号也出了问题，一直到出发也没再能拿出一台备用机。</p><p>总之，仓促之中我们就此出战。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p><img src="http://storage.qiniu.aspi.tech/2019robocup/%E4%BC%9A%E5%9C%BA%E5%90%88%E7%85%A7.jpg" alt="会场合照"></p><p>初到绍兴，才发现这里不愧是南方水乡。城市中到处都有河流穿过，站在桥上迎着吹来的风还是挺凉爽的~</p><p>这次比赛和以往比赛相比规格真的高得多。会场服务十分到位，每天都有班车接送，宾馆也提供早餐，报道注册时还送了很多小东西。</p><p>绍兴这个地方我觉得很神奇，明明人很少，住宅区看上去也不是很高大上，但是附近的商场却很漂亮。然而直到晚上，我们一群男生去寻找网吧时才明白，这附近的商业并没有看上去那么发达。好多店都关门了，不仅仅是网吧，甚至商场里的饭店也是。柯桥区的商业有种让人觉得金玉其外，败絮其中的感觉。</p><p><img src="http://storage.qiniu.aspi.tech/2019robocup/%E5%AE%BE%E9%A6%86%E5%B0%8F%E5%8D%A1%E7%89%87.jpg" alt="宾馆小卡片"><br>夜晚的宾馆也是让人觉得没有那么舒服。且不说住了这么久的宾馆第一次碰到有人塞小卡片，每晚凌晨时分都有人在走廊大声说话。住了五晚，我没有一晚是能睡踏实的……</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>比赛耗时三天，算上调试一共是四天。我们因为没有带备用机，所以只在调试那一天，针对场地适应性进行了调整，后期都是在电脑上用 SimRobot 调整参数。这也就导致了后面比赛的三天里，所有队伍都在场上紧张刺激地进行调试，只有我们坐在场边唠嗑~这一唠，就唠了三天……</p><p>说来惭愧，因为是首秀，对其他学校的实力没有一个认知，我们在开始比赛前一直担心能否赢至少一场拿个三等奖……赢了华师的时候，又听说集美大学弃赛，这就代表我们能赢至少两场。换言之，三等奖稳了。然而对上上交，还是没能赢。怎么说呢，不愧是去年亚军。</p><p>第一天 16 进 12，我们已经觉得很幸运了，而且也已经达成了我们的预期目标，所以后来基本就没什么压力，大家唠嗑唠地更开心了~</p><p>第二天 12 进 8。踢厦大那场基本没什么压力。但是踢武大那场状态不断。先是边裁吹哨被主裁以为是对场吹的，结果没有点 Play。我们在 set 情况下 30 多秒就踢进了一球，却没办法加分。还好李树老师裁决进球有效。然而后来我方 5 号就坏了……前期在学校调试，把 5 号散热扇摔坏了。没想到这个时候爆发出来问题了，导致对武大这场 1：2 输了……不过好在后来厦大踢赢了武大，我们也能够出线。</p><p>8 进 4 时对上南京邮电大学，当时我们已经能够稳拿二等奖，又看着南邮在场上调地热火朝天，我们在场边唠嗑的时候还想着这次已经赚了，估摸着第二天就能出去旅游了。比赛时，和身边的南邮老哥还在说估计我们明天就能出去旅游……结果后面又赢了，说来挺对不起那老哥的，毕竟当面扎心……晚上半决赛又对上了上交，毫无疑问的输了。</p><p>最后一天是和西北民族大学竞争第三名，上半场四号又坏了，被西民抓住机会抢先进了一球。下半场四号调整完毕，5 台 NAO 相互配合，算是踢进了一球，扳平了比分。之前万万没想过我们会踢出平局需要点球，不过西民也没想到，大家准备的都不充分。休息的五分钟里，我提议直接烧 BHuman 提供的例程 Striker，没想到还挺好用的，也得亏西民的守门员一直往边界走，我们才能做到三球三进，最终夺得季军。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p><img src="http://storage.qiniu.aspi.tech/2019robocup/%E5%A5%96%E6%9D%AF.jpg" alt="奖杯"></p><p>这次比赛，因为是郑州大学的首秀，我们自身压力也没那么大，所以在看到别人激烈地调机器时，还能愉快地唠嗑，最终唠出季军~</p><p>所以说这次比赛和我们没什么关系，都是 NAO 自己努力的结果~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2019-Robocup-赛后总结&quot;&gt;&lt;a href=&quot;#2019-Robocup-赛后总结&quot; class=&quot;headerlink&quot; title=&quot;2019 Robocup 赛后总结&quot;&gt;&lt;/a&gt;2019 Robocup 赛后总结&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="Essays" scheme="https://something.plus/categories/Essays/"/>
    
    
    <category term="Life" scheme="https://something.plus/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>天亮了，该检查衣服洗的怎么样了</title>
    <link href="https://something.plus/2021/06/08/Essays/2019-12-23-graduate-school-entrance-exam/"/>
    <id>https://something.plus/2021/06/08/Essays/2019-12-23-graduate-school-entrance-exam/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="天亮了，该检查衣服洗的怎么样了"><a href="#天亮了，该检查衣服洗的怎么样了" class="headerlink" title="天亮了，该检查衣服洗的怎么样了"></a>天亮了，该检查衣服洗的怎么样了</h1><p>2019 年 12 月 22 日下午五点多，在老师把所有试卷、文具整理好之后，这场为期两天的研究生招生考试正式结束了。说是两天，其实算上前期的准备，也算是一场持续半年的“马拉松”。</p><p>之前在网上看到有人对考研的比喻，我觉得挺形象，在这里也分享给大家：</p><blockquote><p>“考研备考，就像在黑屋子里洗衣服，你不知道洗干净了没有，只能一遍又一遍地去洗。等到上考场的那一刻，灯光亮了，你发现，如果你认真洗过了，那件衣服光亮如新。让你以后每次穿这件衣服都会想起那段岁月。”</p></blockquote><p>实际上也正是如此，尤其是对我这种没有报考研辅导班也没有和大家一起复习而是选择独自备战的人来说，根本了解不到大家在每一个阶段的水平都是什么样的，恰如“在黑屋子里洗衣服一样”。</p><p>偶尔刷各种考研群，看到大家在群里说自己数学模拟 130、140，而自己只有七八十的时候也会很焦虑，但也像黑屋子里突然有人喊了一声“看我衣服洗的多干净”一样，具体怎么样谁也不知道。</p><p>黑夜再长，也会迎来天亮，屋子里也来了人要检查衣服洗的怎么样。当我真正上了考场之后，大家的真实水平怎么样就都暴露出来。这个时候才发现，不仅有人会偷工减料、消极怠工，甚至有些位置的主人从头到尾都没有出现过。当然，认认真真地备考的人还是占大多数。</p><p>跟大家进行对比之后，才发现自己准备的其实没有想象的那么差。至少我有把政治卷子工工整整地写满，有好好的背作文模板（而且 21 日中午去考场前背的最后一篇小作文恰巧是考到的通知），对于数学和专业课也尽量把会写的都写上了，至少现在的我能够硬气地说一声“自己尽力了”。接下来的日子就只剩下期末结课的相关事宜与期待考研分数的发布。</p><p>离 2020 年只剩下不到 10 天的时间了，10 年代也就要结束。剩下的时间我打算做个新年规划，希望能不再浑浑噩噩的过日子了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;天亮了，该检查衣服洗的怎么样了&quot;&gt;&lt;a href=&quot;#天亮了，该检查衣服洗的怎么样了&quot; class=&quot;headerlink&quot; title=&quot;天亮了，该检查衣服洗的怎么样了&quot;&gt;&lt;/a&gt;天亮了，该检查衣服洗的怎么样了&lt;/h1&gt;&lt;p&gt;2019 年 12 月 22 日下午</summary>
      
    
    
    
    <category term="Essays" scheme="https://something.plus/categories/Essays/"/>
    
    
    <category term="Life" scheme="https://something.plus/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>没了手机，有了焦虑</title>
    <link href="https://something.plus/2021/06/08/Essays/2019-12-26-my-phone-was-broken/"/>
    <id>https://something.plus/2021/06/08/Essays/2019-12-26-my-phone-was-broken/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="没了手机，有了焦虑"><a href="#没了手机，有了焦虑" class="headerlink" title="没了手机，有了焦虑"></a>没了手机，有了焦虑</h1><p>12 月 24 日平安夜，像往常一样我在玩手机，然而手机却突然自动重启了。这种情况之前也发生过，但与之不同的是这次它没能一次重启后就正常开机，而是陷入了“无限重启”中。在大约 3-5 次重启后，手机进入了异常状态。经过在网上查询，我选择了在异常状态页面进行“恢复出厂设置”，还为此花了 3G 的流量开热点下载系统更新包。可是，一切准备就绪后，它还是会无限重启。至此，陪伴了我两年多的手机宣告了报废。</p><p>尴尬的是，一时半会我还没有备用智能机，唯一的老手机也是一台五年前使用的功能机。这意味着，在接下来的一天多里我将无法随心所欲地使用支付宝、微信、QQ 等可以说是日常必须的软件。在屋里的时候因为有电脑和微信还没有显得有多不方便，然而当我 25 日上午需要去找华为售后修手机时，才发现我的生活已经倒退回了 2016 年：</p><ol><li>因为手机坏了，没办法通过 NFC 或者支付宝乘坐地铁，我去翻箱倒柜找出了很久不用的地铁卡。幸亏地铁卡里面还有 30 多块钱，不然充值的麻烦也会随之而来——我身上连一元现金都没有。</li><li>从我居住的地方到地铁站有大约一公里的距离，当我下楼的时候下意识地想开一辆共享单车地时候才想起来手机坏了没法扫码，只好走到地铁站。</li><li>出了地铁站，我并不知道售后在哪，也不能用手机查询地图，只好去问路人。</li><li>到了售后楼下看到有小吃，想买点吃的，可是手机坏了没办法扫码也没有现金，故只能作罢。</li><li>和家人朋友们联系，只能通过电话短信，而没办法通过 QQ 微信。</li></ol><p>说实话，在智能手机还好的时候，这些行为真的已经是日常最普遍的行为，也是最必须的。日常的大多数出行也只用带上手机和钥匙，最多再多个充电宝。</p><p>如果不是它坏了，我都没有意识到智能手机已经这么深入我们的生活，成为了必需品。</p><p>还好，这段时光只维持了不到一天，因为新手机到了~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;没了手机，有了焦虑&quot;&gt;&lt;a href=&quot;#没了手机，有了焦虑&quot; class=&quot;headerlink&quot; title=&quot;没了手机，有了焦虑&quot;&gt;&lt;/a&gt;没了手机，有了焦虑&lt;/h1&gt;&lt;p&gt;12 月 24 日平安夜，像往常一样我在玩手机，然而手机却突然自动重启了。这种情况之</summary>
      
    
    
    
    <category term="Essays" scheme="https://something.plus/categories/Essays/"/>
    
    
    <category term="Life" scheme="https://something.plus/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>总结2019，展望2020</title>
    <link href="https://something.plus/2021/06/08/Essays/2020-01-03-2020-new-year-plan/"/>
    <id>https://something.plus/2021/06/08/Essays/2020-01-03-2020-new-year-plan/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结-2019，展望-2020"><a href="#总结-2019，展望-2020" class="headerlink" title="总结 2019，展望 2020"></a>总结 2019，展望 2020</h1><blockquote><p>本来应该元旦前就写好的总结，一直拖到了今天。没办法，研究生考试结束了又赶上期末结课和考试以及毕设相关事宜，元旦后放了三天假又忙了三天，就一直拖到了今天才开始写。</p></blockquote><h2 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h2><ol><li>2019 年上半年随队参加了 Robocup 中国赛标准平台组，拿下了大学三年来自己的最高奖项——中国赛季军，随后不久又拿下了亚洲赛亚军。</li><li>2019 年下半年主要就在准备考研。因为时间短，数学没能好好复习，但是我可以问心无愧地说一句“尽力了”。考完了之后我屏蔽了所有考研群和公众号，不对答案不参与和讨论。但行好事，莫问前程。</li></ol><h2 id="规划篇"><a href="#规划篇" class="headerlink" title="规划篇"></a>规划篇</h2><blockquote><p>做规划得做两手准备，考研上岸了一个规划，没上岸再做一个规划。</p></blockquote><h3 id="未来十年长期计划（2020-2029）"><a href="#未来十年长期计划（2020-2029）" class="headerlink" title="未来十年长期计划（2020-2029）"></a>未来十年长期计划（2020-2029）</h3><ol><li><input checked="" disabled="" type="checkbox"> 读研</li><li><input disabled="" type="checkbox"> 读博（可选）</li><li><input disabled="" type="checkbox"> 找一个合适的工作</li><li><input disabled="" type="checkbox"> 结婚</li><li><input disabled="" type="checkbox"> 有自己的房子</li></ol><h3 id="2020-年计划"><a href="#2020-年计划" class="headerlink" title="2020 年计划"></a>2020 年计划</h3><blockquote><p>这部分就得分为两部分了，我太难了……</p></blockquote><h4 id="未成功上岸版"><a href="#未成功上岸版" class="headerlink" title="未成功上岸版"></a><del>未成功上岸版</del></h4><ol><li><del>[ ] 锻炼身体</del></li><li><del>[ ] 好好学习，准备考研</del></li></ol><h4 id="成功上岸版"><a href="#成功上岸版" class="headerlink" title="成功上岸版"></a>成功上岸版</h4><ol><li><input checked="" disabled="" type="checkbox"> 锻炼身体，减肥（至少到 160 斤）</li><li><input checked="" disabled="" type="checkbox"> 试着翻译一些计算机专业英文材料</li><li><input checked="" disabled="" type="checkbox"> 做好专业要做的事，学好该学的习</li><li><input disabled="" type="checkbox"> 掌握一门能挣钱的副业</li><li><input disabled="" type="checkbox"> 学习 Java Web&#x2F;小程序</li><li><input disabled="" type="checkbox"> 日语入门（可选）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;总结-2019，展望-2020&quot;&gt;&lt;a href=&quot;#总结-2019，展望-2020&quot; class=&quot;headerlink&quot; title=&quot;总结 2019，展望 2020&quot;&gt;&lt;/a&gt;总结 2019，展望 2020&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本来应该元</summary>
      
    
    
    
    <category term="Essays" scheme="https://something.plus/categories/Essays/"/>
    
    
    <category term="Life" scheme="https://something.plus/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>写于 24 岁生日时</title>
    <link href="https://something.plus/2021/06/08/Essays/2021-08-06-on-my-24th-birthday/"/>
    <id>https://something.plus/2021/06/08/Essays/2021-08-06-on-my-24th-birthday/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写于-24-岁生日时"><a href="#写于-24-岁生日时" class="headerlink" title="写于 24 岁生日时"></a>写于 24 岁生日时</h1><blockquote><p>1997 年 08 月 06 日 09 时 20 分，我于河南省郑州市郑纺机医院出生；</p><p>2021 年 08 月 06 日 09 时 07 分，我于上海科技大学 1A305 办公室写下这篇文章。</p></blockquote><p>说起来，一眨眼 24 年过去了。“光阴似箭，岁月如梭”现在看上去确实是这么回事。12 岁时的场景都还历历在目，我怎么就 24 岁了呢？</p><p>在过去的这段日子里，我一直在想一个问题：“大家都是怎么成熟起来的呢？”</p><p>明明感觉自己还是一个小孩子，里里外外都充满了不成熟的气息，可同龄人甚至都有了孩子。</p><p>而我的生活仍旧充满了不确定性：我不知道自己 3 年后会在哪里；不知道自己会有谁来陪伴；不知道自己什么时候能够成熟到担负起责任……</p><p>23 岁到 24 岁这一年中其实也经历了很多事：来到了新的地方；减肥 50 斤；尝试让自己变得更好；试着找到自己感兴趣的事情；试着去承担责任……</p><p>时至今日，我也确实还会经常迷茫，可迷茫才代表了未来仍有期盼。如果一切都已成定数，那才是“活到头”了。</p><p>且写到这里吧，我还很忙，未来的路也还很长。</p><p>且让我慢慢地把每一步路都走好吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写于-24-岁生日时&quot;&gt;&lt;a href=&quot;#写于-24-岁生日时&quot; class=&quot;headerlink&quot; title=&quot;写于 24 岁生日时&quot;&gt;&lt;/a&gt;写于 24 岁生日时&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1997 年 08 月 06 日 09 时 20 </summary>
      
    
    
    
    <category term="Essays" scheme="https://something.plus/categories/Essays/"/>
    
    
    <category term="Life" scheme="https://something.plus/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Python SDK入门 (1)——让NAO说话</title>
    <link href="https://something.plus/2021/06/08/Techniques/2018-04-24-make-nao-speak/"/>
    <id>https://something.plus/2021/06/08/Techniques/2018-04-24-make-nao-speak/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-SDK-入门-1-——让-NAO-说话"><a href="#Python-SDK-入门-1-——让-NAO-说话" class="headerlink" title="Python SDK 入门(1)——让 NAO 说话"></a>Python SDK 入门(1)——让 NAO 说话</h1><p>在 python for naoqi 的环境安装完成后，我们先来尝试让 NAO 说出“Hello world”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALProxy</span><br><span class="line">tts = ALProxy(<span class="string">&quot;ALTextTpSpeech&quot;</span>, <span class="string">&quot;&lt;IP of your robot&gt;&quot;</span>, <span class="number">9559</span>)</span><br><span class="line">tts.say(<span class="string">&quot;Hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是一个很简单的程序吧？那么接下来稍微增加一些难度，让它说一段绕口令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALProxy</span><br><span class="line">tts = ALProxy(<span class="string">&quot;ALTextToSpeech&quot;</span>, <span class="string">&quot;192.168.1.112&quot;</span>, <span class="number">9559</span>)</span><br><span class="line"></span><br><span class="line">tts.setLanguage(<span class="string">&quot;Chinese&quot;</span>)</span><br><span class="line"></span><br><span class="line">tts.say(<span class="string">&quot;你好，我是NAO&quot;</span>)</span><br><span class="line">tts.say(<span class="string">&quot;我不仅会说你好，我还会说绕口令&quot;</span>)</span><br><span class="line">tts.say(<span class="string">&quot;牛郎恋刘娘，刘娘念牛郎&quot;</span>)</span><br><span class="line">tts.say(<span class="string">&quot;牛郎年年恋刘娘&quot;</span>)</span><br><span class="line">tts.say(<span class="string">&quot;郎恋娘来娘念郎&quot;</span>)</span><br><span class="line">tts.say(<span class="string">&quot;念娘恋娘&quot;</span>)</span><br><span class="line">tts.say(<span class="string">&quot;念郎恋郎&quot;</span>)</span><br><span class="line">tts.say(<span class="string">&quot;念恋娘郎&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ALTextToSpeech 是 NAOqi 中能使说话的接口，我们通过 ALProxy 将其导入给对象 tts，而 say()、setLanguage()都是该类下的成员函数，分别起到传入要说的文字和设置语言的作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python-SDK-入门-1-——让-NAO-说话&quot;&gt;&lt;a href=&quot;#Python-SDK-入门-1-——让-NAO-说话&quot; class=&quot;headerlink&quot; title=&quot;Python SDK 入门(1)——让 NAO 说话&quot;&gt;&lt;/a&gt;Python S</summary>
      
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="NAO" scheme="https://something.plus/tags/NAO/"/>
    
    <category term="Python" scheme="https://something.plus/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python SDK入门（2）——让NAO行走并说话</title>
    <link href="https://something.plus/2021/06/08/Techniques/2018-04-25-make-nao-speak-and-move/"/>
    <id>https://something.plus/2021/06/08/Techniques/2018-04-25-make-nao-speak-and-move/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-SDK-入门（2）——让-NAO-行走并说话"><a href="#Python-SDK-入门（2）——让-NAO-行走并说话" class="headerlink" title="Python SDK 入门（2）——让 NAO 行走并说话"></a>Python SDK 入门（2）——让 NAO 行走并说话</h1><h2 id="１-使-NAO-刚化"><a href="#１-使-NAO-刚化" class="headerlink" title="１.　使 NAO 刚化"></a>１.　使 NAO 刚化</h2><ul><li><p>除非你将 NAO 的 stiffness 的值设为非 0 数，否则它是不会移动的</p></li><li><p>而要做到这点其实很简单，只要通过调用<a href="http://doc.aldebaran.com/2-1/naoqi/motion/control-stiffness-api.html#ALMotionProxy::setStiffnesses__AL::ALValueCR.AL::ALValueCR"><code>ALMotionProxy::setStiffnesses()</code></a>进行设置即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALProxy</span><br><span class="line">motion = ALProxy(<span class="string">&quot;ALMotion&quot;</span>, <span class="string">&quot;nao.local&quot;</span>, <span class="number">9559</span>)</span><br><span class="line">motion.setStiffnesses(<span class="string">&quot;Body&quot;</span>, <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-使-NAO-移动"><a href="#2-使-NAO-移动" class="headerlink" title="2. 使 NAO 移动"></a>2. 使 NAO 移动</h2><p>为了让 NAO 移动，我们应该使用 <a href="http://doc.aldebaran.com/2-1/naoqi/motion/control-walk-api.html#ALMotionProxy::moveInit"><code>ALMotionProxy::moveInit()</code>函数</a>（以使 NAO 处于合适的姿势），然后再调用<a href="http://doc.aldebaran.com/2-1/naoqi/motion/control-walk-api.html#ALMotionProxy::moveTo__floatCR.floatCR.floatCR"><code>ALMotionProxy::moveTo()</code></a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALProxy</span><br><span class="line">motion = ALProxy(<span class="string">&quot;ALMotion&quot;</span>, <span class="string">&quot;nao.local&quot;</span>, <span class="number">9559</span>)</span><br><span class="line">motion.moveInit()</span><br><span class="line">motion.moveTo(<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="3-使-NAO-同时说话并行走"><a href="#3-使-NAO-同时说话并行走" class="headerlink" title="3. 使 NAO 同时说话并行走"></a>3. 使 NAO 同时说话并行走</h2><p>我们创建的每一个代理(proxy)都有一个叫做”post”的属性，且可以通过使用它在后台调用很多方法。</p><p>这可以帮助我们使机器人同时做很多事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALProxy</span><br><span class="line">motion = ALProxy(<span class="string">&quot;ALMotion&quot;</span>, <span class="string">&quot;nao.local&quot;</span>, <span class="number">9559</span>)</span><br><span class="line">tts = ALProxy(<span class="string">&quot;ALTextToSpeech&quot;</span>, <span class="string">&quot;nao.local&quot;</span>, <span class="number">9559</span>)</span><br><span class="line">motion.moveInit()</span><br><span class="line">motion.post.moveTo(<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">tts.say(<span class="string">&quot;I&#x27;m walking&quot;</span>)</span><br></pre></td></tr></table></figure><p>当然，如果需要等待一个任务结束，我们可以使用 ALProxy 中的等待方法，使用寄出的方法(the post usage)所返回的任务 ID:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALProxy</span><br><span class="line">motion = ALProxy(<span class="string">&quot;ALMotion&quot;</span>, <span class="string">&quot;nao.local&quot;</span>, <span class="number">9559</span>)</span><br><span class="line">motion.moveInit()</span><br><span class="line"><span class="built_in">id</span> = motion.post.moveTo(<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">motion.wait(<span class="built_in">id</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="完整的程序"><a href="#完整的程序" class="headerlink" title="完整的程序"></a>完整的程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALProxy</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">motion = ALProxy(<span class="string">&quot;ALMotion&quot;</span>, <span class="string">&quot;192.168.1.114&quot;</span>, <span class="number">9559</span>)<span class="comment">#NAO的动作对象</span></span><br><span class="line">tts = ALProxy(<span class="string">&quot;ALTextToSpeech&quot;</span>, <span class="string">&quot;192.168.1.114&quot;</span>, <span class="number">9559</span>)<span class="comment">#NAO的语言对象</span></span><br><span class="line">posture = ALProxy(<span class="string">&quot;ALRobotPosture&quot;</span>, <span class="string">&quot;192.168.1.114&quot;</span>, <span class="number">9559</span>)<span class="comment">#NAO的姿势对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#首先唤醒NAO</span></span><br><span class="line">motion.wakeUp()</span><br><span class="line"></span><br><span class="line"><span class="comment">#让NAO站好</span></span><br><span class="line">posture.goToPosture(<span class="string">&quot;StandInit&quot;</span>, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将其刚化</span></span><br><span class="line">motion.setStiffnesses(<span class="string">&quot;Body&quot;</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化</span></span><br><span class="line">motion.moveInit()</span><br><span class="line"></span><br><span class="line"><span class="comment">#让NAO向前走1米，同时返回任务ID给id</span></span><br><span class="line"><span class="built_in">id</span> = motion.post.moveTo(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tts.say(<span class="string">&quot;I&#x27;m walking&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直到id传过来了，再执行wait()函数</span></span><br><span class="line">motion.wait(<span class="built_in">id</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tts.say(<span class="string">&quot;I will not walk anymore&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#让NAO休眠</span></span><br><span class="line">motion.rest()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python-SDK-入门（2）——让-NAO-行走并说话&quot;&gt;&lt;a href=&quot;#Python-SDK-入门（2）——让-NAO-行走并说话&quot; class=&quot;headerlink&quot; title=&quot;Python SDK 入门（2）——让 NAO 行走并说话&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="NAO" scheme="https://something.plus/tags/NAO/"/>
    
    <category term="Python" scheme="https://something.plus/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python SDK入门（3）——对事件做出反应</title>
    <link href="https://something.plus/2021/06/08/Techniques/2018-04-27-react-to-event/"/>
    <id>https://something.plus/2021/06/08/Techniques/2018-04-27-react-to-event/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-SDK-入门（3）——对事件做出反应"><a href="#Python-SDK-入门（3）——对事件做出反应" class="headerlink" title="Python SDK 入门（3）——对事件做出反应"></a>Python SDK 入门（3）——对事件做出反应</h1><p>​ 这一节，我想让 NAO 在每一次侦测到人脸的时候都说一句“你好，人类”。为了达到这一点，我们需要使用 ALFacedetection 模型下的”FaceDetected”事件。</p><p>​ 所以我们需要用 Python 写一个 NAOqi 模型出来。而要创建模型，我们首先需要一个中间件(Broker)。</p><p>​ 下面是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;每当侦测到人脸时都要说一声“你好，人类”&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALProxy</span><br><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALBroker</span><br><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALModule</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> optparse <span class="keyword">import</span> OptionParser</span><br><span class="line"></span><br><span class="line">pip = <span class="string">&quot;nao.local&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用全局变量来存储&quot;HumanGreeter&quot;模型中的实例</span></span><br><span class="line">HumanGreeter = <span class="literal">None</span></span><br><span class="line">memory = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanGreeterModule</span>(<span class="title class_ inherited__">ALModule</span>):</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">ALmodule.__init__(self, name)</span><br><span class="line"><span class="comment">#在这里不需要IP和端口，</span></span><br><span class="line"><span class="comment">#因为我们可以在之后用自己写的中间件去连NAOqi中的中间件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个ALTextToSpeech稍后使用</span></span><br><span class="line">self.tts = ALProxy(<span class="string">&quot;ALTextToSpeech&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用FaceDetected事件</span></span><br><span class="line"><span class="keyword">global</span> memory</span><br><span class="line">memory = ALProxy(<span class="string">&quot;ALMemory&quot;</span>)</span><br><span class="line">memory.subscribeToEvent(<span class="string">&quot;FaceDetected&quot;</span>,</span><br><span class="line"><span class="string">&quot;HumanGreeter&quot;</span>, <span class="string">&quot;onFaceDetected&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onFaceDetected</span>(<span class="params">self,*_args</span>):</span><br><span class="line"><span class="comment">#这个方法将会在每次侦测到人脸的时候被调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当走路的时候不使用该事件</span></span><br><span class="line"><span class="comment">#以避免多次重复</span></span><br><span class="line">memory.unsubscribeToEvent(<span class="string">&quot;FaceDetected&quot;</span>, <span class="string">&quot;HumanGreeter&quot;</span>)</span><br><span class="line"></span><br><span class="line">self.tts.setLanguage(<span class="string">&quot;Chinese&quot;</span>)</span><br><span class="line">self.tts.say(<span class="string">&quot;你好，人类&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次使用上面那个方法</span></span><br><span class="line">memory.subscribeToEvent(<span class="string">&quot;FaceDetected&quot;</span>,</span><br><span class="line"><span class="string">&quot;HumanGreeter&quot;</span>, <span class="string">&quot;onFaceDetected&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Main entry point</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    parser = OptionParser()</span><br><span class="line">    parser.add_option(<span class="string">&quot;--pip&quot;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Parent broker port. The IP address or your robot&quot;</span>,</span><br><span class="line">        dest=<span class="string">&quot;pip&quot;</span>)</span><br><span class="line">    parser.add_option(<span class="string">&quot;--pport&quot;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Parent broker port. The port NAOqi is listening to&quot;</span>,</span><br><span class="line">        dest=<span class="string">&quot;pport&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&quot;int&quot;</span>)</span><br><span class="line">    parser.set_defaults(</span><br><span class="line">        pip=NAO_IP,</span><br><span class="line">        pport=<span class="number">9559</span>)</span><br><span class="line"></span><br><span class="line">    (opts, args_) = parser.parse_args()</span><br><span class="line">    pip   = opts.pip</span><br><span class="line">    pport = opts.pport</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#我们需要用这个中间件来构建NAOqi模型并使用其他模型</span></span><br><span class="line"><span class="comment">#这个中间件必须在运行期间始终有效</span></span><br><span class="line">    myBroker = ALBroker(<span class="string">&quot;myBroker&quot;</span>,</span><br><span class="line">       <span class="string">&quot;0.0.0.0&quot;</span>,   <span class="comment"># 监听所有的</span></span><br><span class="line">       <span class="number">0</span>,           <span class="comment"># 找到一个空端口并使用它</span></span><br><span class="line">       pip,         <span class="comment"># 父类中间件IP</span></span><br><span class="line">       pport)       <span class="comment"># 父类中间件端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：HumanGreeter必须是全局变量</span></span><br><span class="line"><span class="comment">#传入结构体的名字必须是这个变量的名字</span></span><br><span class="line">    <span class="keyword">global</span> HumanGreeter</span><br><span class="line">    HumanGreeter = HumanGreeterModule(<span class="string">&quot;HumanGreeter&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Interrupted by user, shutting down&quot;</span></span><br><span class="line">        myBroker.shutdown()</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>一些注意事项：</p><ul><li>要确保我们对实例使用的是全局变量</li><li>要确保我们传入 ALModule 的结构体的名字是自己的变量的名字</li><li>如果我们为此方法编写了文档字符串，且它不以下划线开头，则我们的类的方法会自动转换为绑定方法。（The method of your class are automatically transform into bound methods, <strong>providing that you wrote a doc string</strong> for this method, and it <strong>does not start with an underscore</strong>.）</li><li>一旦建立了 ALBroker 对象，我们需要使这个对象一直有效，以使订阅（the subscribing）工作。 我们还需要中间件处于有效状态才能创建代理而不必指定 IP 或端口。</li><li>脚本必须有–pip 和–pport 才能工作</li></ul><p><strong>补充内容：</strong> 让 Python 脚本在 NAO 上运行的方法：</p><p>​ 将脚本传到 NAO 上，如&#x2F;home&#x2F;nao&#x2F;reacting_to_events.py，然后编辑&#x2F;home&#x2F;nao&#x2F;naoqi&#x2F;preferences 下的 autoload.ini 文件，加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[python]</span><br><span class="line">/home/nao/reacting_to_events.py</span><br></pre></td></tr></table></figure><p>请注意，在运行脚本时 NAOqi 会自动设置-pip 和-pport 值。</p><p>最后，运行这个脚本，然后把你的脸放在 NAO 的面前，你将会听到一声”你好，人类“。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python-SDK-入门（3）——对事件做出反应&quot;&gt;&lt;a href=&quot;#Python-SDK-入门（3）——对事件做出反应&quot; class=&quot;headerlink&quot; title=&quot;Python SDK 入门（3）——对事件做出反应&quot;&gt;&lt;/a&gt;Python SDK </summary>
      
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="NAO" scheme="https://something.plus/tags/NAO/"/>
    
    <category term="Python" scheme="https://something.plus/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python SDK入门（4）——记录数据</title>
    <link href="https://something.plus/2021/06/08/Techniques/2018-04-27-record-data/"/>
    <id>https://something.plus/2021/06/08/Techniques/2018-04-27-record-data/</id>
    <published>2021-06-08T02:14:29.000Z</published>
    <updated>2022-04-20T03:10:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-SDK-入门（4）——-记录数据"><a href="#Python-SDK-入门（4）——-记录数据" class="headerlink" title="Python SDK 入门（4）—— 记录数据"></a>Python SDK 入门（4）—— 记录数据</h1><p>对于 NAO 来说，记录下它众多传感器的数据是很容易的。让我们来看一个简单的例子吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- UTF-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;记录下一些传感器的数据，并将它们写入到一个文本中&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MEMORY_VALUE_NAMES 是我们想要存储的ALMemory的值的列表</span></span><br><span class="line">ALMEMORY_KEY_NAMES = [</span><br><span class="line"><span class="string">&quot;Device/SubDeviceList/HeadYaw/Position/Sensor/Value&quot;</span></span><br><span class="line"><span class="string">&quot;Device/SubDeviceList/HeadYaw/Position/Actuator/value&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">NAO_IP = <span class="string">&quot;nao.local&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> naoqi <span class="keyword">import</span> ALProxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recordData</span>(<span class="params">nao_ip</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;记录ALMemory中的数据，并返回一个值的矩阵&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Recording data...&quot;</span></span><br><span class="line">memory = ALProxy(<span class="string">&quot;ALMemory&quot;</span>, nao_ip, <span class="number">9559</span>)</span><br><span class="line">data = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">line = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> ALMEMORY_KEY_NAMES:</span><br><span class="line">value = memory.getData(key)</span><br><span class="line">line.append(value)</span><br><span class="line">data.append(line)</span><br><span class="line">time.sleep(<span class="number">0.05</span>)</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="string">&quot;&quot;&quot;解析命令行参数，</span></span><br><span class="line"><span class="string">运行recordData并将结果写进一个csv文件中</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">nao_ip = ROBOT_IP</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nao_ip = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">motion = ALProxy(<span class="string">&quot;ALMotion&quot;</span>, nao_ip, <span class="number">9559</span>)</span><br><span class="line"><span class="comment"># 设置头部马达的刚化</span></span><br><span class="line">motion.setSetiffnesses(<span class="string">&quot;Head&quot;</span>, <span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># 将会在两秒钟内从1.0弧度到0弧度</span></span><br><span class="line">motion.post.angleInterpolation(</span><br><span class="line">[<span class="string">&quot;HeadYaw&quot;</span>],</span><br><span class="line">[<span class="number">1.0</span>, <span class="number">0.0</span>],</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">)</span><br><span class="line">data = recordData(nao_ip)</span><br><span class="line"><span class="comment"># 轻轻的将头部点击固定</span></span><br><span class="line">motion.setSetiffnesses(<span class="string">&quot;Head&quot;</span>, <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">output = os.path.abspath(<span class="string">&quot;record.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(output, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line"><span class="keyword">for</span> lint <span class="keyword">in</span> data:</span><br><span class="line">fp.write(<span class="string">&quot;;&quot;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> line))</span><br><span class="line">fp.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Results written to&quot;</span>, output</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ = <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>接下来我们将会没 50ms 调用一次<a href="http://doc.aldebaran.com/2-1/naoqi/core/almemory-api.html#ALMemoryProxy::getData__ssCR"><code>ALMemoryProxy::getData()</code></a> 来将值存进一个矩阵中，然后将这个矩阵写入一个文件。</p><p><strong><em>注意：</em></strong> 这个方法相当的慢！但是不要尝试更高的频率去获取数据，这会给 NAO 的 CPU 带来很大的负担！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python-SDK-入门（4）——-记录数据&quot;&gt;&lt;a href=&quot;#Python-SDK-入门（4）——-记录数据&quot; class=&quot;headerlink&quot; title=&quot;Python SDK 入门（4）—— 记录数据&quot;&gt;&lt;/a&gt;Python SDK 入门（4）—</summary>
      
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="NAO" scheme="https://something.plus/tags/NAO/"/>
    
    <category term="Python" scheme="https://something.plus/tags/Python/"/>
    
  </entry>
  
</feed>
