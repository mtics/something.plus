<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浪漫生活手册</title>
  
  <subtitle>荔枝老师今天干嘛啦？</subtitle>
  <link href="https://something.plus/atom.xml" rel="self"/>
  
  <link href="https://something.plus/"/>
  <updated>2022-05-13T07:00:59.393Z</updated>
  <id>https://something.plus/</id>
  
  <author>
    <name>一颗荔枝味汤圆</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写于 24 岁生日时</title>
    <link href="https://something.plus/2021/08/06/Essays/2021-08-06-on-my-24th-birthday/"/>
    <id>https://something.plus/2021/08/06/Essays/2021-08-06-on-my-24th-birthday/</id>
    <published>2021-08-06T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Sorry, the password is not correct, please type again." data-whm="Sorry, the article is not hased, but you can read it now.">  <script id="hbeData" type="hbeData" data-hmacdigest="260e8e0c35b8bb73d4c037088bf7936194c1f91b8a118adaf133ac0db42cea89">4dc7a94e7c5a545a902ed34cc5b2f1c30cb0316419a3e53372a759eec4ff5daa492038bc7698d60a66dea877b65f2a01f2a2a294bd6a7287facd4a43dc1c1f517fe73d5235de656023f825a80c7ec80f2b23bc5a6f7dcffcac86fdae7e1af2a8f6d59b37716b9c1799219639a3acbaffcd481b2ebfd2939e810bdf034f0947415529de0f490a6d7c825f81435ebe4ac685c68b3a95132884d1a73cd188c0948dc9f9381df237eb6f5e41d3da3d2ec874e611d3baa028fe6dc385c1a8deb6df8e11fb8c14b27ababa55116d096bd37a22c6f72d3d4b5c1625a31717565b500ba95f5cfb952c0f68ece63b66b9330e3e5a33fddfa6bfca772a754f658963a17b4bdd59dd04849136b4439c5aee631233e619f6521e79a7bc98dec67ce7345468b31e217097102f1d8ceaadfc1a68b282fbb3ee6252e7bd1d68edceb9a7a650adc38432cb2d26e1fa1757ea3f929d6351a7cd1accc2366deef63e581b49d59f3ce1d38319aa0821d8456a5402d28e3a3b92f9dfc07e84f8879158cfc22da9b24dead7b595d0bdaaa6502079ce470ec7bb113fac4e1e4112e36e5bfa4b06c8db4f869cd9fed90f63db9408227d9e7a3cc8f49f8d2ba589e5f95e469ed3696bb9614b331babfada09e68056c1b52b5ec6659e498d0bc40ff4afc1bbd7a561ed1618264d7d7be1ceb1a20c56b59a5e8a491d8ecaa17333ba21eeb4b0d975828ebfa9cb19660dd1ce34992010f16baa4504f024343a16ab9c7c8ab8b089704e1847b53229c8d129d03969dd4373a7e1e106bbf4e4f968144cea4e25790fae7af72ce7440ea73db64d0a3ce4e448fff616b5fa963fa441618bc4b9d75ac8504c5ad1f009c33fcff662f378e1772f53c9dbe2d7a30b1dcc28e6f35d10d3d36fbf5fedbbc6cc3c15052486d192f9f003d570237e92cd904805ad7b8454a62e2987de2e7b53de590d9bc1014da1194958ad04d68f6276d18ff37bf1a54e69877e56541ace1cfbc2edeaee28433a0e5bb3436a4a19a3a1a766c986fe9feec4c68869f22532b8132a49227ce2ca6bbeb975cd550bd6b3509b16209d77249cb971a3ad5b01927441865d045724abc0f2de459c7b56dc318ecbd16aa3a9eb0c24a5097c198fcff247ebfe317307e413acb828f1455ac28e6d10ba01c849f98413fe9eec40252c83fc8bdd0e9e02ea3d7830b8b802a4ed666b3efa7120f50879ba299a4b2d8ae167a759f2d62bd7c64de8eccc611d65f2673300f3de7c36c46cfc7c6d7761d3d80daada63d04fa123332d2e7a1eeb7a3e1620b26954ccd3ff27b270f6b4a178fb6b72b2980a5006148ec976197486f523deae1c1aa1b9d4f24ae2b81443ff66ec5f6502a5bd14da387f847b9a37cca7c1595f485fe4ec8e3eb55258bde0a802d67a2001154c7601c3651cd65167d52304ef874f0b953bbc8660748b77d479b52f968050de4414f6c0fe396a2d49320df12b43344c1beafdd03646a496512c0f0cb0c1c5cdc439966964892caa7037c0f94b8728b0037bb5318d9e8827fd3aa24ca608a0f75eff453e4b8e441bc37346c0335508a65b18c745ffa60d98e9e287c5a38a16deb7a60a75c40ceb7662dff8464182120b688bd399025dcad0d06e52490425a71a487b2a0380678b5c33cdeb38fe7c9e38561307a888aaf08e0189f86c630cae9dce138c47ca41091276f05b4cbe75f666443a7be46b9b341730718ca688e8e1d2d8d21bea8111f3bfe53a3ead304ddc80641f189c2b0f374d1be74b26408eb6c3b88130f2495ba31698b3bb7576905b6b60b822bd661e2455c9e5ba87eae34b6b0d876dd822494244fc6be46d03d8d33817acae4a25948158710a5df303079b1dbab26966418c2b36f607d6816804d2b62e234a9cf73bb747248f94357d87b4b7d54de2d11d1ec299c662f2794c83a4c3b5e34bb522eec089575ee50a0962a9e88d1c1f4a11348e570a59b139dffba8cb89d4eb00a63a301b4b79e4e81f3f47d9cfc785839c0658bbb5a1a60a128a9694974e841671125fb2e8dbfa7b10411a6f78fbd49b006e3de3ea63938880e02a1a9b35a349b82ece66b7f5b7fb73dcfe7b2a7fd591de99d51cae3b1cfc0b73216b8e94ca9594d5ba81256d7eb212b863314703dafdfb94a639bb13e404818a67cf8128ee99ea4c11c2f8ce856701ee9937844121b81d58484aa3801eae48</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Type the password here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">The article is encrypted, please type the password.</summary>
    
    
    
    <category term="Essays" scheme="https://something.plus/categories/Essays/"/>
    
    
    <category term="Life" scheme="https://something.plus/tags/Life/"/>
    
    <category term="Personal" scheme="https://something.plus/tags/Personal/"/>
    
  </entry>
  
  <entry>
    <title>使用Python实现平台自动打卡</title>
    <link href="https://something.plus/2020/04/08/Techniques/2020-04-08-auto-sign-zzu-jksb/"/>
    <id>https://something.plus/2020/04/08/Techniques/2020-04-08-auto-sign-zzu-jksb/</id>
    <published>2020-04-08T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Python-实现平台自动打卡"><a href="#使用-Python-实现平台自动打卡" class="headerlink" title="使用 Python 实现平台自动打卡"></a>使用 Python 实现平台自动打卡</h1><span id="more"></span><blockquote><p>众所周知，人的懒惰是技术发展的一大动力。<br>现在正处疫情期间，因为我总是忘记及时健康打卡而导致被年级群通报，故干脆写了个 Python 脚本来自动打卡。<br>若之后我的身体状态、所在地等信息都没有改变的话，这个脚本就能帮我完成一个小任务嘞。</p></blockquote><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>代码整体并不难。</p><p>通过使用 Selenium 库，能够将一切网页端的操作模拟成一个真正的用户在操作。</p><h3 id="Selenium-安装"><a href="#Selenium-安装" class="headerlink" title="Selenium 安装"></a>Selenium 安装</h3><p>库本身并不难安装，只需要运行以下指令即可：</p><p><code>pip install selenium</code></p><p>但要注意，要想使用它还需要安装浏览器驱动。比如我用的是 Chrome，就需要安装<a href="https://sites.google.com/a/chromium.org/chromedriver/">ChromeDriver</a>。</p><p><strong>ChromeDriver 的版本号要与本机安装的 Chrome 浏览器的版本相同</strong>。打开 Chrome，可以通过点击右上角的菜单按钮（即三个竖直排列的”.”），然后选择<code>&quot;帮助&quot; &gt; &quot;关于 Google Chrome&quot;</code>，即可看到浏览器的版本号：</p><p><img src="https://aspi.oss-cn-beijing.aliyuncs.com/blog/pic/Chrome版本号.png" alt="Chrome版本号"></p><p>按照 Chrome 的版本下载 ChromeDriver，然后还需要将其安装到 Python 环境中。打开命令行界面，通过<code>where python</code>查询 Python 环境位置，将下载好的<code>chromedriver.exe</code>复制到<code>Scripts</code>文件夹中。</p><p>之后在命令行界面中通过<code>chromedriver</code>命令可查看 ChromeDriver 是否正常安装。若正常，则会出现如下类似输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting ChromeDriver <span class="number">80.0</span>.<span class="number">3987.106</span> (f68069574609230cf9b635cd784cfb1bf81bb53a<span class="literal">-refs</span>/branch<span class="literal">-heads</span>/<span class="number">3987</span><span class="selector-tag">@</span>&#123;<span class="comment">#882&#125;) on port ****</span></span><br><span class="line">Only local connections are allowed.</span><br><span class="line">Please protect ports used by ChromeDriver and related test frameworks to prevent access by malicious code.</span><br></pre></td></tr></table></figure><h2 id="签到部分"><a href="#签到部分" class="headerlink" title="签到部分"></a>签到部分</h2><p>Selenium 的一个好处是所有的操作都是直接运行再浏览器中，和真正的用户操作是一样的。因此就不需要设置伪装头文件了。</p><h4 id="浏览器模拟"><a href="#浏览器模拟" class="headerlink" title="浏览器模拟"></a>浏览器模拟</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这部分用来设置运行时不显示浏览器窗口</span></span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(<span class="string">&quot;--headless&quot;</span>)</span><br><span class="line"><span class="comment"># 模拟浏览器进行访问</span></span><br><span class="line">browser = webdriver.Chrome(options=chrome_options)</span><br><span class="line">browser.get(<span class="string">&quot;https://jksb.v.zzu.edu.cn/vls6sss/zzujksb.dll/first0&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="进行签到"><a href="#进行签到" class="headerlink" title="进行签到"></a>进行签到</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过find_element_by_xpath来定位用户名和密码的输入框</span></span><br><span class="line">browser.find_element_by_xpath(<span class="string">&quot;//*[@id=&#x27;mt_5&#x27;]/div[1]/div[3]/input&quot;</span>).send_keys(uid)</span><br><span class="line">browser.find_element_by_xpath(<span class="string">&quot;//*[@id=&#x27;mt_5&#x27;]/div[2]/div[3]/input&quot;</span>).send_keys(pwd)</span><br></pre></td></tr></table></figure><p>为了防止加载不完全的错误，可以设置<code>time.sleep(2)</code>来阻塞两秒等待加载。</p><p>通过以下代码可以获取到签到完成后的提示信息，用作之后的通知邮件的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_text = browser.find_element_by_xpath(<span class="string">&quot;//*[@id=&#x27;bak_0&#x27;]/div[2]/div[2]/div[2]/div[2]&quot;</span>).text</span><br></pre></td></tr></table></figure><h3 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a>邮件通知</h3><p>签到后会通过邮件来告知我是否成功。</p><p>这里我用的是 QQ 邮箱：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mail</span>(<span class="params">mail_text, mail_to</span>):</span><br><span class="line">    <span class="comment"># 设置邮件内容，用的是之前签到返回的提示信息</span></span><br><span class="line">    msg = MIMEText(mail_text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置邮件主题、发送方和接收方</span></span><br><span class="line">    msg[<span class="string">&#x27;Subject&#x27;</span>] = <span class="string">&quot;每日健康打卡通知&quot;</span></span><br><span class="line">    msg[<span class="string">&#x27;From&#x27;</span>] = MAIL_USER</span><br><span class="line">    msg[<span class="string">&#x27;To&#x27;</span>] = mail_to</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送邮件</span></span><br><span class="line">    send = smtplib.SMTP_SSL(<span class="string">&quot;smtp.qq.com&quot;</span>, <span class="number">465</span>)</span><br><span class="line">    send.login(MAIL_USER, MAIL_PWD)</span><br><span class="line">    send.send_message(msg)</span><br><span class="line">    <span class="comment"># 退出邮件</span></span><br><span class="line">    send.quit()</span><br></pre></td></tr></table></figure><h3 id="私人信息"><a href="#私人信息" class="headerlink" title="私人信息"></a>私人信息</h3><p>因这部分牵涉到了个人信息，我单独建了一个<code>private_info.py</code>来存储，并没有公开，故用户在使用时需要自行创建。内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MAIL_USER = <span class="string">&quot;your-notice@email.address&quot;</span> <span class="comment"># 用于发送通知的邮箱</span></span><br><span class="line">MAIL_PWD = <span class="string">&quot;your-authorization-code&quot;</span><span class="comment"># 该邮箱的授权码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单用户</span></span><br><span class="line">UID = <span class="string">&quot;your-id&quot;</span><span class="comment"># 学号</span></span><br><span class="line">PWD = <span class="string">&quot;your-password&quot;</span><span class="comment"># 密码</span></span><br><span class="line">MAIL_TO = <span class="string">&quot;your-email&quot;</span><span class="comment"># 接受通知的邮箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多用户</span></span><br><span class="line">users = <span class="built_in">list</span>()</span><br><span class="line">users.append(User(<span class="string">&quot;your-id&quot;</span>, <span class="string">&quot;your-password&quot;</span>, <span class="string">&quot;your-email&quot;</span>))</span><br></pre></td></tr></table></figure><p>其中多用户添加账户信息时，使用的是自定义类 User()，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    uid = <span class="string">&quot;&quot;</span></span><br><span class="line">    pwd = <span class="string">&quot;&quot;</span></span><br><span class="line">    email = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, uid, pwd, email</span>):</span><br><span class="line">        self.uid = uid</span><br><span class="line">        self.pwd = pwd</span><br><span class="line">        self.email = email</span><br></pre></td></tr></table></figure><p>完整代码放在了<a href="https://github.com/mtics/auto_sign_zzu_jksb">Github</a>上，如果读者有兴趣，不妨试一试。</p><h2 id="任务定时"><a href="#任务定时" class="headerlink" title="任务定时"></a>任务定时</h2><p><strong>现在，程序本身已经支持定时了！</strong></p><p>通过修改<code>auto_sign.py</code>中第 72 行代码中<code>==</code>后的数字就可以自定义时间了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> now.hour == <span class="number">6</span> <span class="keyword">and</span> now.minute == <span class="number">0</span>:</span><br></pre></td></tr></table></figure><p>代价就是<strong>程序必须一直运行着</strong>。</p><p>作为补偿，我将编码修改为了 GBK，这样可以运行在 Linux 服务器上了，通过以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python auto_sign.py &amp;</span><br></pre></td></tr></table></figure><p><del>我看了几个 Python 实现的定时运行方法，感觉都不是很好。</del></p><p><del>在尝试了几种后，最终选择了使用 Win10 自带的“任务计划程序”。</del></p><p><del><img src="https://aspi.oss-cn-beijing.aliyuncs.com/blog/pic/任务计划程序.png" alt="任务计划程序"></del></p><p><del>单击右侧“创建基本任务”：</del></p><p><del><img src="C:\Users\lizw9\Pictures\Saved Pictures\创建基本任务.png" alt="创建基本任务"></del></p><p><del>输入名称、描述后单击下一步，选择“每天”，开始时间我设置在了“06:00”。</del></p><p><del>之后选择“启动程序”，继续下一步。</del></p><p><del>接下来会到“启动程序界面”，在“程序或脚本”处选择自己的 python 环境所在位置，然后在“添加参数处”输入<code>auto_sign.py</code>的路径，如图所示：</del></p><p><del><img src="https://aspi.oss-cn-beijing.aliyuncs.com/blog/pic/启动程序.png" alt="启动成勋设置"></del></p><p><del>继续“下一步”后，单击“完成”即可。</del></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用-Python-实现平台自动打卡&quot;&gt;&lt;a href=&quot;#使用-Python-实现平台自动打卡&quot; class=&quot;headerlink&quot; title=&quot;使用 Python 实现平台自动打卡&quot;&gt;&lt;/a&gt;使用 Python 实现平台自动打卡&lt;/h1&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="Python" scheme="https://something.plus/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢</title>
    <link href="https://something.plus/2020/03/02/Techniques/2020-03-02-introduction-of-gamification/"/>
    <id>https://something.plus/2020/03/02/Techniques/2020-03-02-introduction-of-gamification/</id>
    <published>2020-03-02T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢"><a href="#为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢" class="headerlink" title="为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢"></a>为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢</h1><span id="more"></span><iframe src="//player.bilibili.com/player.html?aid=89509862&cid=152881669&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢&quot;&gt;&lt;a href=&quot;#为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢&quot; class=&quot;headerlink&quot; title=&quot;为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢&quot;&gt;&lt;/a&gt;为什么我们会很容易沉迷于游戏，却很难沉迷于学习中呢&lt;/h1&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="Gamify" scheme="https://something.plus/tags/Gamify/"/>
    
  </entry>
  
  <entry>
    <title>利用Hexo打造属于自己的网页版简历</title>
    <link href="https://something.plus/2020/01/27/Techniques/2020-01-27-mtics-resume-template/"/>
    <id>https://something.plus/2020/01/27/Techniques/2020-01-27-mtics-resume-template/</id>
    <published>2020-01-27T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用-Hexo-打造属于自己的网页版简历"><a href="#利用-Hexo-打造属于自己的网页版简历" class="headerlink" title="利用 Hexo 打造属于自己的网页版简历"></a>利用 Hexo 打造属于自己的网页版简历</h1><p>最近想着做一个网页版的个人简历，想着要满足一下几个需求：</p><ul><li>简洁直观不花里胡哨的</li><li>方便修改内容，能根据修改后的内容自动生成网页</li></ul><span id="more"></span><p>这就要求我最好能用静态博客框架来做，如：Hexo、Hugo 等。</p><p>但是找了许多主题，都没有一个很能令我满意的。</p><p>最接近的一个是<a href="https://github.com/crispgm/resume"><code>Crisp Minimal Résumé</code></a>。</p><p>但是该主题的 Hexo 版本中存在许多 BUG，而且排版松懈、没有照片。</p><p>所以趁着春节无处可去，干脆在家做了个 Hexo 的简历主题——Mtics-Resume。</p><p>本主题在<code>Crisp Minimal Résumé</code>上做了许多修改，使它更符合我的喜好。</p><p>本主题具有以下特点：</p><ul><li>简洁直观</li><li>配置简单</li><li>可定制性强</li><li>响应式布局</li><li>在隐藏了 footer 后，可直接打印成为纸质简历</li></ul><p>欢迎各位使用 Hexo 或者对本主题有兴趣的大佬试用，并向我提出建议或与我一起开发。</p><p>项目地址：<a href="https://github.com/mtics/hexo-mtics-resume">https://github.com/mtics/hexo-mtics-resume</a></p><p>在线演示：<a href="https://mtics.netlify.com/">https://mtics.netlify.com/</a></p><p>Ps: 因本项目及演示都放在 Github 上，通过 Netlify 进行部署，所以访问速度可能较慢，敬请谅解。</p><p><img src="https://aspi.oss-cn-beijing.aliyuncs.com/blog/pic/hexo-mtics-laptop.png" alt="hexo-mtics-laptop"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;利用-Hexo-打造属于自己的网页版简历&quot;&gt;&lt;a href=&quot;#利用-Hexo-打造属于自己的网页版简历&quot; class=&quot;headerlink&quot; title=&quot;利用 Hexo 打造属于自己的网页版简历&quot;&gt;&lt;/a&gt;利用 Hexo 打造属于自己的网页版简历&lt;/h1&gt;&lt;p&gt;最近想着做一个网页版的个人简历，想着要满足一下几个需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁直观不花里胡哨的&lt;/li&gt;
&lt;li&gt;方便修改内容，能根据修改后的内容自动生成网页&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="Hexo" scheme="https://something.plus/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用Faster-RCNN进行指定GPU训练（续）</title>
    <link href="https://something.plus/2020/01/09/Techniques/2020-01-09-train-with-resnet101-on-pascal_voc/"/>
    <id>https://something.plus/2020/01/09/Techniques/2020-01-09-train-with-resnet101-on-pascal_voc/</id>
    <published>2020-01-09T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Faster-RCNN-进行指定-GPU-训练（续）"><a href="#使用-Faster-RCNN-进行指定-GPU-训练（续）" class="headerlink" title="使用 Faster-RCNN 进行指定 GPU 训练（续）"></a>使用 Faster-RCNN 进行指定 GPU 训练（续）</h1><span id="more"></span><ol><li><p>今天接着昨天的实验继续跑“多 GPU 训练”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python trainval_net.py \ --dataset pascal_voc --net res101 \ --bs 24 --nw 8 \ --lr $LEARING_RATE --lr_decay_step $DECAY_STEP \ --cuda --mGPUs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(pascal_voc.py    self._classes   类别修改)</span></span><br></pre></td></tr></table></figure></li><li><p>训练自己的数据集（步骤与之前样例中相同）</p></li><li><p>训练完成后对数据集进行处理，发现有些图片因为亮度不够或模糊而识别有误。下一步考虑怎么提高图片的清晰度，使识别率提高。</p></li><li><p>目前有个想法：</p><ol><li>计算图片清晰度，如果清晰度不在某个范围的话，进行第二步操作；</li><li>调整图片的亮度和对比度，然后再进行清晰度计算。若清晰度达到要求，则输出；否则，继续调整，直到符合要求。</li></ol></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>问题一：“多 GPU 训练”中出现<code>ctx.input_sizes = tuple(map(lambda i: i.size(ctx.dim), inputs)) RuntimeError: dimension specified as 0 but tensor has no dimensions</code>错误</p><ul><li><p>解决：在<a href="https://github.com/jwyang/faster-rcnn.pytorch">faster-rcnn.pytorch</a>中的<a href="https://github.com/jwyang/faster-rcnn.pytorch/issues/421">issue: multi gpu train errors!</a>可以看到这个问题出现的比较多，其中有两条解决方案：</p><ol><li><p>the pytorch 1.0 branch works fine with multi GPU training（pytorch 1.0 分支可以正常进行多 GPU 训练）。但因为太麻烦，我没有尝试。</p></li><li><p>在<code>faster-rcnn.pytorch/lib/model/faster_rcnn/faster_rcnn.py</code>中加入以下几行（经测试可行）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpn_loss_cls = torch.Tensor([<span class="number">0</span>]).cuda() + rpn_loss_cls</span><br><span class="line">rpn_loss_bbox = torch.Tensor([<span class="number">0</span>]).cuda() + rpn_loss_bbox</span><br><span class="line">RCNN_loss_cls = torch.Tensor([<span class="number">0</span>]).cuda() + RCNN_loss_cls</span><br><span class="line">RCNN_loss_bbox = torch.Tensor([<span class="number">0</span>]).cuda() + RCNN_loss_bbox</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>问题二：<code>assert (boxes[:, 2] &gt;= boxes[:, 0]).all() AssertionError</code></p><ul><li><p>解决：将<code>datasets/pascal_voc.py</code>中的如下代码的”-1”删掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bbox = obj.find(<span class="string">&#x27;bndbox&#x27;</span>)</span><br><span class="line"><span class="comment"># Make pixel indexes 0-based</span></span><br><span class="line">x1 = <span class="built_in">float</span>(bbox.find(<span class="string">&#x27;xmin&#x27;</span>).text) - <span class="number">1</span></span><br><span class="line">y1 = <span class="built_in">float</span>(bbox.find(<span class="string">&#x27;ymin&#x27;</span>).text) - <span class="number">1</span></span><br><span class="line">x2 = <span class="built_in">float</span>(bbox.find(<span class="string">&#x27;xmax&#x27;</span>).text) - <span class="number">1</span></span><br><span class="line">y2 = <span class="built_in">float</span>(bbox.find(<span class="string">&#x27;ymax&#x27;</span>).text) - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>问题三：<code>raise ValueError(&quot;bg_num_rois = 0 and fg_num_rois = 0, this should not happen!&quot;)</code></p><ul><li>解决： 玄学解决，按照<a href="https://github.com/jwyang/faster-rcnn.pytorch/issues/111">ValueError: bg_num_rois = 0 and fg_num_rois = 0, this should not happen! </a>中的方法都试了一遍，莫名其妙的就跑通了。。。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用-Faster-RCNN-进行指定-GPU-训练（续）&quot;&gt;&lt;a href=&quot;#使用-Faster-RCNN-进行指定-GPU-训练（续）&quot; class=&quot;headerlink&quot; title=&quot;使用 Faster-RCNN 进行指定 GPU 训练（续）&quot;&gt;&lt;/a&gt;使用 Faster-RCNN 进行指定 GPU 训练（续）&lt;/h1&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="Machine Learning" scheme="https://something.plus/tags/Machine-Learning/"/>
    
    <category term="Deep Learning" scheme="https://something.plus/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>使用Faster-RCNN进行指定GPU训练</title>
    <link href="https://something.plus/2020/01/08/Techniques/2020-01-08-train-with-resnet101-on-pascal_voc/"/>
    <id>https://something.plus/2020/01/08/Techniques/2020-01-08-train-with-resnet101-on-pascal_voc/</id>
    <published>2020-01-08T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Faster-RCNN-进行指定-GPU-训练"><a href="#使用-Faster-RCNN-进行指定-GPU-训练" class="headerlink" title="使用 Faster-RCNN 进行指定 GPU 训练"></a>使用 Faster-RCNN 进行指定 GPU 训练</h1><span id="more"></span><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li><p>解决了昨日环境配置剩下的问题（三~六），接着昨日第 7 步继续</p></li><li><p>测试库中用例，检查是否能跑通</p><ol><li><p>在”faster-rcnn.pytorch”文件夹中打开终端</p></li><li><p>指定 GPU 训练</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=$GPU_ID python trainval_net.py \</span><br><span class="line">            --dataset pascal_voc --net res101 \</span><br><span class="line">            --bs $BATCH_SIZE --nw $WORKER_NUMBER \</span><br><span class="line">            --lr $LEARNING_RATE --lr_decay_step $DECAY_STEP \</span><br><span class="line">            --cuda</span><br></pre></td></tr></table></figure><ul><li>参数意义：<ul><li><code>CUDA_VISIBLE_DEVICES=$GPU_ID</code>：指明所使用的 GPU ID，<code>$GPU_ID</code>需修改为指定 ID</li><li><code>--dataset pascal_voc --net res101</code>：在 pascal_voc 上使用 resnet101 进行训练</li><li><code>--bs $BATCH_SIZE --nw $WORKER_NUMBER</code>：可以根据 GPU 内存大小来自适应地设置 BATCH_SIZE(批处理尺寸)和 WORKER_NUMBER。<strong>在具有 12G 内存的 Titan Xp 上，它最多可以为 4</strong></li><li><code>--lr $LEARNING_RATE --lr_decay_step $DECAY_STEP</code>：<strong>学习率(Learning rate)</strong>作为监督学习以及深度学习中重要的超参，其决定着目标函数能否收敛到局部最小值以及何时收敛到最小值。合适的学习率能够使目标函数在合适的时间内收敛到局部最小值。</li></ul></li></ul></li><li><p>多 GPU 训练(这一步实验没有做，“指定 GPU 实验”居然从下午三点多跑到了晚上 11 点多…)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python trainval_net.py \ --dataset pascal_voc --net res101 \ --bs 24 --nw 8 \ --lr $LEARING_RATE --lr_decay_step $DECAY_STEP \ --cuda --mGPUs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(pascal_voc.py    self._classes   类别修改)</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>问题一：<code>RuntimeError: The expanded size of the tensor (2) must match the existing size (0) at non-singleton dimension 1</code></p><ul><li>解决：原因在于计算二分类交叉熵损失函数时是在每个 batch 中进行的，而总的图片数量并不能被所设置的 batch_size 整除，造成最后一个 batch 的图片数量与 batch_size 不相等。</li></ul></li><li><p>问题二：<code>AttributeError: &#39;int&#39; object has no attribute &#39;astype&#39;</code></p><ul><li>解决：将<code>/lib/roi_data_layer/roibatchLoader.py</code>中第 52 行的<code>target_ratio = 1</code>改为<code>target_ratio = np.array(1)</code></li></ul></li><li><p>问题三：<code>AttributeError: &#39;Tensor&#39; object has no attribute &#39;index&#39;</code></p><ul><li>解决： 将 torch 的版本改为 0.4.0…所以昨天的错误到时出在哪个依赖上了？？？</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用-Faster-RCNN-进行指定-GPU-训练&quot;&gt;&lt;a href=&quot;#使用-Faster-RCNN-进行指定-GPU-训练&quot; class=&quot;headerlink&quot; title=&quot;使用 Faster-RCNN 进行指定 GPU 训练&quot;&gt;&lt;/a&gt;使用 Faster-RCNN 进行指定 GPU 训练&lt;/h1&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="Machine Learning" scheme="https://something.plus/tags/Machine-Learning/"/>
    
    <category term="Deep Learning" scheme="https://something.plus/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Faster-RCNN环境配置</title>
    <link href="https://something.plus/2020/01/07/Techniques/2020-01-07-faster-rcnn-env/"/>
    <id>https://something.plus/2020/01/07/Techniques/2020-01-07-faster-rcnn-env/</id>
    <published>2020-01-07T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Faster-RCNN-环境配置"><a href="#Faster-RCNN-环境配置" class="headerlink" title="Faster-RCNN 环境配置"></a>Faster-RCNN 环境配置</h1><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><span id="more"></span><ol><li>创建虚拟环境</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create --name &lt;env_name&gt; &lt;package_names&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如: conda create --name lzw python=3.6</span></span><br></pre></td></tr></table></figure><ol><li><p>激活虚拟环境</p><p><del><code>source activate &lt;env_name&gt;</code></del>(太老)<br>使用<code>conda activate &lt;env_name&gt;</code>替代</p></li><li><p>退出虚拟环境</p><p><del><code>source deactivate</code></del>(太老)<br>使用<code>conda deactivate</code>替代</p></li><li><p>查看已创建环境</p><p><code>conda env list</code></p></li><li><p>安装 pytorch0.4 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch=0.4.0 cuda80 -c pytorch</span><br><span class="line">pip install torch==0.4.0 -f https://download.pytorch.org/whl/cu80/stable #CUDA 8.0 build</span><br></pre></td></tr></table></figure></li><li><p>克隆 Faster-RCNN.Pytorch 库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1. 从Git上克隆</span><br><span class="line">git clone https://github.com/jwyang/faster-rcnn.pytorch.git</span><br><span class="line"></span><br><span class="line"># 2. 打开文件夹并创建文件夹‘data’</span><br><span class="line">cd faster-rcnn.pytorch &amp;&amp; mkdir data</span><br><span class="line"></span><br><span class="line"># 3. 安装所需依赖</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"># 4. 编译环境</span><br><span class="line">cd lib</span><br><span class="line">sh make.sh</span><br></pre></td></tr></table></figure></li><li><p>测试库中用例，检查是否能跑通</p><ol><li><p>在”faster-rcnn.pytorch”文件夹中打开终端</p></li><li><p>指定 GPU 训练</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VIDIBLE_DEVICES=$GPU_ID python trainval_net.py \ --dataset pascal_voc --net res101 \ --bs $BATCH_SIZE --nw $WORKER_NUMBER \ --lr $LEARING_RATE --lr_decay_step $DECAY_STEP \ --cuda</span><br></pre></td></tr></table></figure></li><li><p>多 GPU 训练</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python trainval_net.py \ --dataset pascal_voc --net res101 \ --bs 24 --nw 8 \ --lr $LEARING_RATE --lr_decay_step $DECAY_STEP \ --cuda --mGPUs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(pascal_voc.py    self._classes   类别修改)</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>问题一： 在 Anaconda 虚拟环境中，命令<code>python</code>默认指向 python2 版本,需要修改为 python3 版本</p><ul><li><p>解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除原来指向python2的软链接</span></span><br><span class="line">mv /home/ciisr/anaconda3/envs/lzw/bin/python /home/ciisr/anaconda3/envs/lzw/bin/python.bak</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按照自己的实际情况进行更改</span></span><br><span class="line">ln -s /home/ciisr/anaconda3/envs/lzw/bin/python3.6 /home/ciisr/anaconda3/envs/lzw/bin/python</span><br></pre></td></tr></table></figure></li></ul></li><li><p>问题二： 明明<code>import torch</code>已经没有问题，但<code>sh make.sh</code>时会提示找不到 torch 模块</p><ul><li>解决：注释”make.sh”中首行<code>#! /usr/bin/env bash</code></li></ul></li><li><p>问题三： 在运行上述第 7 步时“指定 GPU 训练”提示<code>AttributeError: module &#39;torch.nn&#39; has no attribute &#39;ModuleDict&#39;</code></p><ul><li>解决： <del>torch 0.4.0 版本中不包含”torch.nn”,需要卸载后重新安装 0.4.1</del>及以上<del>版本（只能是 0.4.1，不然会导致问题五的发生）</del>在 2020-01-08 的实验中我发现 torch 只能安装 0.4.0 版本的…</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall torch</span><br><span class="line">pip install torch==0.4.0</span><br></pre></td></tr></table></figure></li><li><p>问题四：在运行上述第 7 步时“指定 GPU 训练”提示<code>from scipy.misc import imread. ImportError: cannot import name &#39;imread&#39;</code></p></li><li><p>解决：scipy 需要安装 1.2.1 左右的版本，同时 pillow 版本不能高于 7.0.0，否则会导致<code>ImportError: cannot import name &#39;PILLOW_VERSION&#39;</code>错误</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall scipy pillow</span><br><span class="line">pip install scipy==1.2.1 pillow==5.2.0</span><br></pre></td></tr></table></figure><ul><li><p>问题五：在运行上述第 7 步时“指定 GPU 训练”提示<code>ImportError: torch.utils.ffi is deprecated. Please use cpp extensions instead.</code></p><ul><li>解决： <del>torch 的版本只能安装 0.4.1</del>在 2020-01-08 的实验中我发现 torch 只能安装 0.4.0 版本的…</li></ul></li><li><p>问题六：在运行上述第 7 步时“指定 GPU 训练”提示<code>torch.jit.frontend.NotSupportedError: slicing multiple dimensions at the same time isn&#39;t supported yet</code></p><ul><li>解决： 重新安装 torchvision0.2.2 版本.</li><li><strong><em>注意</em></strong>：不能把 torch 版本升级到 1.0.0，不然会导致问题五的发生。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Faster-RCNN-环境配置&quot;&gt;&lt;a href=&quot;#Faster-RCNN-环境配置&quot; class=&quot;headerlink&quot; title=&quot;Faster-RCNN 环境配置&quot;&gt;&lt;/a&gt;Faster-RCNN 环境配置&lt;/h1&gt;&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h3&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="Machine Learning" scheme="https://something.plus/tags/Machine-Learning/"/>
    
    <category term="Deep Learning" scheme="https://something.plus/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>总结2019，展望2020</title>
    <link href="https://something.plus/2020/01/03/Essays/2020-01-03-2020-new-year-plan/"/>
    <id>https://something.plus/2020/01/03/Essays/2020-01-03-2020-new-year-plan/</id>
    <published>2020-01-03T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结-2019，展望-2020"><a href="#总结-2019，展望-2020" class="headerlink" title="总结 2019，展望 2020"></a>总结 2019，展望 2020</h1><blockquote><p>本来应该元旦前就写好的总结，一直拖到了今天。没办法，研究生考试结束了又赶上期末结课和考试以及毕设相关事宜，元旦后放了三天假又忙了三天，就一直拖到了今天才开始写。</p></blockquote><span id="more"></span><h2 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h2><ol><li>2019 年上半年随队参加了 Robocup 中国赛标准平台组，拿下了大学三年来自己的最高奖项——中国赛季军，随后不久又拿下了亚洲赛亚军。</li><li>2019 年下半年主要就在准备考研。因为时间短，数学没能好好复习，但是我可以问心无愧地说一句“尽力了”。考完了之后我屏蔽了所有考研群和公众号，不对答案不参与和讨论。但行好事，莫问前程。</li></ol><h2 id="规划篇"><a href="#规划篇" class="headerlink" title="规划篇"></a>规划篇</h2><blockquote><p>做规划得做两手准备，考研上岸了一个规划，没上岸再做一个规划。</p></blockquote><h3 id="未来十年长期计划（2020-2029）"><a href="#未来十年长期计划（2020-2029）" class="headerlink" title="未来十年长期计划（2020-2029）"></a>未来十年长期计划（2020-2029）</h3><ol><li>[x] 读研</li><li>[ ] 读博（可选）</li><li>[ ] 找一个合适的工作</li><li>[ ] 结婚</li><li>[ ] 有自己的房子</li></ol><h3 id="2020-年计划"><a href="#2020-年计划" class="headerlink" title="2020 年计划"></a>2020 年计划</h3><blockquote><p>这部分就得分为两部分了，我太难了……</p></blockquote><h4 id="未成功上岸版"><a href="#未成功上岸版" class="headerlink" title="未成功上岸版"></a><del>未成功上岸版</del></h4><ol><li><del>[ ] 锻炼身体</del></li><li><del>[ ] 好好学习，准备考研</del></li></ol><h4 id="成功上岸版"><a href="#成功上岸版" class="headerlink" title="成功上岸版"></a>成功上岸版</h4><ol><li>[x] 锻炼身体，减肥（至少到 160 斤）</li><li>[x] 试着翻译一些计算机专业英文材料</li><li>[x] 做好专业要做的事，学好该学的习</li><li>[ ] 掌握一门能挣钱的副业</li><li>[ ] 学习 Java Web/小程序</li><li>[ ] 日语入门（可选）</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;总结-2019，展望-2020&quot;&gt;&lt;a href=&quot;#总结-2019，展望-2020&quot; class=&quot;headerlink&quot; title=&quot;总结 2019，展望 2020&quot;&gt;&lt;/a&gt;总结 2019，展望 2020&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本来应该元旦前就写好的总结，一直拖到了今天。没办法，研究生考试结束了又赶上期末结课和考试以及毕设相关事宜，元旦后放了三天假又忙了三天，就一直拖到了今天才开始写。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essays" scheme="https://something.plus/categories/Essays/"/>
    
    
    <category term="Life" scheme="https://something.plus/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>没了手机，有了焦虑</title>
    <link href="https://something.plus/2019/12/26/Essays/2019-12-26-my-phone-was-broken/"/>
    <id>https://something.plus/2019/12/26/Essays/2019-12-26-my-phone-was-broken/</id>
    <published>2019-12-26T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="没了手机，有了焦虑"><a href="#没了手机，有了焦虑" class="headerlink" title="没了手机，有了焦虑"></a>没了手机，有了焦虑</h1><p>12 月 24 日平安夜，像往常一样我在玩手机，然而手机却突然自动重启了。这种情况之前也发生过，但与之不同的是这次它没能一次重启后就正常开机，而是陷入了“无限重启”中。在大约 3-5 次重启后，手机进入了异常状态。经过在网上查询，我选择了在异常状态页面进行“恢复出厂设置”，还为此花了 3G 的流量开热点下载系统更新包。可是，一切准备就绪后，它还是会无限重启。至此，陪伴了我两年多的手机宣告了报废。</p><span id="more"></span><p>尴尬的是，一时半会我还没有备用智能机，唯一的老手机也是一台五年前使用的功能机。这意味着，在接下来的一天多里我将无法随心所欲地使用支付宝、微信、QQ 等可以说是日常必须的软件。在屋里的时候因为有电脑和微信还没有显得有多不方便，然而当我 25 日上午需要去找华为售后修手机时，才发现我的生活已经倒退回了 2016 年：</p><ol><li>因为手机坏了，没办法通过 NFC 或者支付宝乘坐地铁，我去翻箱倒柜找出了很久不用的地铁卡。幸亏地铁卡里面还有 30 多块钱，不然充值的麻烦也会随之而来——我身上连一元现金都没有。</li><li>从我居住的地方到地铁站有大约一公里的距离，当我下楼的时候下意识地想开一辆共享单车地时候才想起来手机坏了没法扫码，只好走到地铁站。</li><li>出了地铁站，我并不知道售后在哪，也不能用手机查询地图，只好去问路人。</li><li>到了售后楼下看到有小吃，想买点吃的，可是手机坏了没办法扫码也没有现金，故只能作罢。</li><li>和家人朋友们联系，只能通过电话短信，而没办法通过 QQ 微信。</li></ol><p>说实话，在智能手机还好的时候，这些行为真的已经是日常最普遍的行为，也是最必须的。日常的大多数出行也只用带上手机和钥匙，最多再多个充电宝。</p><p>如果不是它坏了，我都没有意识到智能手机已经这么深入我们的生活，成为了必需品。</p><p>还好，这段时光只维持了不到一天，因为新手机到了~</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;没了手机，有了焦虑&quot;&gt;&lt;a href=&quot;#没了手机，有了焦虑&quot; class=&quot;headerlink&quot; title=&quot;没了手机，有了焦虑&quot;&gt;&lt;/a&gt;没了手机，有了焦虑&lt;/h1&gt;&lt;p&gt;12 月 24 日平安夜，像往常一样我在玩手机，然而手机却突然自动重启了。这种情况之前也发生过，但与之不同的是这次它没能一次重启后就正常开机，而是陷入了“无限重启”中。在大约 3-5 次重启后，手机进入了异常状态。经过在网上查询，我选择了在异常状态页面进行“恢复出厂设置”，还为此花了 3G 的流量开热点下载系统更新包。可是，一切准备就绪后，它还是会无限重启。至此，陪伴了我两年多的手机宣告了报废。&lt;/p&gt;</summary>
    
    
    
    <category term="Essays" scheme="https://something.plus/categories/Essays/"/>
    
    
    <category term="Life" scheme="https://something.plus/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>天亮了，该检查衣服洗的怎么样了</title>
    <link href="https://something.plus/2019/12/23/Essays/2019-12-23-graduate-school-entrance-exam/"/>
    <id>https://something.plus/2019/12/23/Essays/2019-12-23-graduate-school-entrance-exam/</id>
    <published>2019-12-23T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="天亮了，该检查衣服洗的怎么样了"><a href="#天亮了，该检查衣服洗的怎么样了" class="headerlink" title="天亮了，该检查衣服洗的怎么样了"></a>天亮了，该检查衣服洗的怎么样了</h1><p>2019 年 12 月 22 日下午五点多，在老师把所有试卷、文具整理好之后，这场为期两天的研究生招生考试正式结束了。说是两天，其实算上前期的准备，也算是一场持续半年的“马拉松”。</p><span id="more"></span><p>之前在网上看到有人对考研的比喻，我觉得挺形象，在这里也分享给大家：</p><blockquote><p>“考研备考，就像在黑屋子里洗衣服，你不知道洗干净了没有，只能一遍又一遍地去洗。等到上考场的那一刻，灯光亮了，你发现，如果你认真洗过了，那件衣服光亮如新。让你以后每次穿这件衣服都会想起那段岁月。”</p></blockquote><p>实际上也正是如此，尤其是对我这种没有报考研辅导班也没有和大家一起复习而是选择独自备战的人来说，根本了解不到大家在每一个阶段的水平都是什么样的，恰如“在黑屋子里洗衣服一样”。</p><p>偶尔刷各种考研群，看到大家在群里说自己数学模拟 130、140，而自己只有七八十的时候也会很焦虑，但也像黑屋子里突然有人喊了一声“看我衣服洗的多干净”一样，具体怎么样谁也不知道。</p><p>黑夜再长，也会迎来天亮，屋子里也来了人要检查衣服洗的怎么样。当我真正上了考场之后，大家的真实水平怎么样就都暴露出来。这个时候才发现，不仅有人会偷工减料、消极怠工，甚至有些位置的主人从头到尾都没有出现过。当然，认认真真地备考的人还是占大多数。</p><p>跟大家进行对比之后，才发现自己准备的其实没有想象的那么差。至少我有把政治卷子工工整整地写满，有好好的背作文模板（而且 21 日中午去考场前背的最后一篇小作文恰巧是考到的通知），对于数学和专业课也尽量把会写的都写上了，至少现在的我能够硬气地说一声“自己尽力了”。接下来的日子就只剩下期末结课的相关事宜与期待考研分数的发布。</p><p>离 2020 年只剩下不到 10 天的时间了，10 年代也就要结束。剩下的时间我打算做个新年规划，希望能不再浑浑噩噩的过日子了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;天亮了，该检查衣服洗的怎么样了&quot;&gt;&lt;a href=&quot;#天亮了，该检查衣服洗的怎么样了&quot; class=&quot;headerlink&quot; title=&quot;天亮了，该检查衣服洗的怎么样了&quot;&gt;&lt;/a&gt;天亮了，该检查衣服洗的怎么样了&lt;/h1&gt;&lt;p&gt;2019 年 12 月 22 日下午五点多，在老师把所有试卷、文具整理好之后，这场为期两天的研究生招生考试正式结束了。说是两天，其实算上前期的准备，也算是一场持续半年的“马拉松”。&lt;/p&gt;</summary>
    
    
    
    <category term="Essays" scheme="https://something.plus/categories/Essays/"/>
    
    
    <category term="Life" scheme="https://something.plus/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://something.plus/2019/06/09/Courses/2019-06-09-computer-network-chp3/"/>
    <id>https://something.plus/2019/06/09/Courses/2019-06-09-computer-network-chp3/</id>
    <published>2019-06-09T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>信道分类：</p><ul><li><strong>点对点信道</strong>：这种信道使用<em>一对一</em>的点对点通信方式</li><li><strong>广播信道</strong>：这种信道使用<em>一对多</em>的广播通信方式</li></ul><p><img src="http://storage.qiniu.aspi.tech/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%9C%B0%E4%BD%8D%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%9C%A8%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E6%B5%81%E5%8A%A8.png" alt="数据链路层的位置及数据在数据链路层的流动"></p><blockquote><p><em>不同的链路层可能使用不同的数据链路层协议</em></p></blockquote><span id="more"></span><h2 id="使用点对点的数据链路层"><a href="#使用点对点的数据链路层" class="headerlink" title="使用点对点的数据链路层"></a>使用点对点的数据链路层</h2><ul><li><strong>链路</strong>：<ul><li>就是从一个结点到相邻结点的一段物理线路（有线或无线）</li><li>链路只是一条路径的组成部分</li><li><strong>数据链路</strong>：<ul><li>当需要在一条线路上传送数据时，出了必须有一条物理线路外，还必须有一些的必要的通信协议来控制这些数据的传输</li><li>一般的网络适配器都包括了<em>数据链路层</em>和<em>物理层</em>这两层的功能</li></ul></li><li>若把链路分为物理链路和逻辑链路：<ul><li><strong>物理链路</strong>就是上面所说的链路</li><li><strong>逻辑链路</strong>就是上面的数据链路，即物理链路加上必要的通信协议</li></ul></li></ul></li><li><strong>帧</strong>：点对点信道的数据链路层的协议数据单元<ul><li>数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，以及把接收到的<strong>帧</strong>中的数据取出并上交给网络层。</li><li>网络层协议数据单元是<strong>IP 数据报</strong>（简称<strong>数据报</strong>、<strong>分组</strong>或<strong>包</strong>）</li></ul></li></ul><p><img src="http://storage.qiniu.aspi.tech/%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png" alt="使用点对点信道的数据链路层"></p><p>点对点信道的数据链路层在进行通信时的主要步骤如下：</p><ol><li>结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成<em>帧</em></li><li>结点 A 把封装好的帧发送给结点 B 的数据链路层</li><li>若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧</li></ol><p>数据链路层不必考虑物理层如何实现比特传输的细节。</p><p>数据链路层协议有许多种，但有三个问题则是共同的：</p><ol><li><strong>封装成帧</strong>：就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧<ul><li>分组交换的一个重要概念：所有在互联网上传送的数据都以<em>分组（即 IP 数据报）</em>为传送单位</li><li>网络层的 IP 数据报传送到数据链路层就成为帧的数据部分</li><li>在帧的数据部分的前面和后面分别添加上首部和尾部，就构成了一个完整的帧<ul><li>首部和尾部一个重要作用就是进行<strong>帧定界</strong>（即确定帧的界限）</li><li>首部和尾部包括许多必要的控制信息</li><li>为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度</li></ul></li><li>每一种链路层协议都规定了所能传送的帧的数据部分长度上限——<strong>最大传送单元 MTU</strong>(Maximum Transfer Unit)</li></ul></li><li><strong>透明传输</strong><ul><li>由于帧的开始和结束的标记使用专门指明的控制字符。因此，所传输的数据中的任何 8 比特的组合一定<strong>不允许</strong>和用作帧定界的控制字符的比特编码一样，<em>否则就会出现帧定界的错误</em>。</li><li><strong>透明</strong>是指：某一个实际存在的事物看起来却好像不存在一样</li><li>“在数据链路层透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。或者说，数据链路层对这些数据来说是透明的。</li></ul></li><li><strong>差错控制</strong><ul><li><strong>比特差错</strong>：<ul><li>比特在传输过程中可能会产生差错：1 可能变成 0，0 可能变成 1</li></ul></li><li><strong>误码率 BER</strong>(Bit Error Rate)：在一段时间内，传输错误的比特占所传输比特总数的比率<ul><li>若设法提高信噪比，就可以使误码率减小</li></ul></li><li><em>凡是接收端数据链路层接收的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程没有产生差错</em><ul><li>接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受</li><li>也可近似地表述为“凡是接收端数据链路层接受的帧均无差错”</li></ul></li><li><strong>可靠传输</strong>：数据链路层的发送端发送什么，在接收端就收到什么</li><li>传输差错可分为两类：<ul><li>一类即前面的最基本的比特差错</li><li>另一类传输差错更复杂些，虽然收到的帧没有出现比特差错，但却出现了<strong>帧丢失</strong>、<strong>帧重复</strong>或<strong>帧失序</strong></li></ul></li></ul></li></ol><h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><p>PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议</p><ul><li>PPP 协议应满足的需求<ol><li><strong>简单</strong><ul><li>接收方每收到一个帧，就进行 CRC 检验。入如 CRC 检验正确，就收下这个帧；反之，就丢弃这个帧，其他什么也不做</li></ul></li><li><strong>封装成帧</strong><ul><li>PPP 协议必须规定特殊的宇符作为<strong>帧定界符</strong>(即标志一个帧的开始和结束的字符)，以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。</li></ul></li><li><strong>透明性</strong><ul><li>PPP 协议必须保证数据传输的透明性</li></ul></li><li><strong>多种网络层协议</strong><ul><li>PPP 协议必须能够在<strong>同一条物理链路上同时支持多种网络层协议</strong></li></ul></li><li><strong>多种类型链路</strong><ul><li>除了要支持多种网络层的协议外， PPP 还必须能够在多种类型的链路上运行</li></ul></li><li><strong>差错检测</strong><ul><li>PPP 协议必须能够对接收端收到的帧进行检测，并<strong>立即丢弃有差错的帧</strong></li></ul></li><li><strong>检测链接状态</strong><ul><li>PPP 协议必须具有一种机制能够及时(不超过几分钟)自动检测出链路是否处于正常工作状态</li></ul></li><li><strong>最大传送单元</strong><ul><li>PPP 协议必须对每 → 种类型的点对点链路设置最大传送单元 MTU 的标准默认值。这样做是为了<strong>促进各种实现之间的互操作性</strong></li><li>MTU 是数据链路层的帧可以载荷的<strong>数据部分</strong>的最大长度，而<strong>不是帧的总长度</strong>。</li></ul></li><li><strong>网络层地址协商</strong> - PPP 协议必须提供一种机制使通信的两个网络层(例如，两个 IP 层)的实体能够通过协商知道或能够配置彼此的网络层地址。 10.<strong> 数据压缩协商</strong> - PPP 协议必须提供一种方法来协商使用数据压缩算法</li></ol></li><li>PPP 协议的组成<ol><li><em>一个将 IP 数据报封装到串行链路的方法</em>。 PPP 既支持异步链路(无奇偶检验的 8 比特数据)，也支持面向比特的同步链路。 IP 数据报在 PPP 帧中就是其信息部分。这个信息部分的长度受最大传送单元 MTU 的限制。</li><li><em>一个用来建立、配置和测试数据链路连接的链路控制协议 LCP</em> (Link Control Protocol)。通信的双方可协商一些选项。</li><li><em>一套网络控制协议 NCP</em> (Network Control Protocol)，其中的每一个协议支持不同的网络层协议。</li></ol></li></ul><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><ul><li><strong>局域网</strong>：<ul><li>最主要的<strong>特点</strong>：网络为一个单位所拥有，且地理范围和站点数目均有限</li><li>主要优点：<ol><li>具有广播功能，从一个站点可很方便地访问全网</li><li>便于系统的扩展和逐渐演变，各设备的位置可灵活调整和改变</li><li>提高了系统的可靠性、可用性和生存性</li></ol></li><li>共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便地共享通信媒体资源。这在技术上有两种方法：<ul><li><strong>静态划分信道</strong>。用户只要分配到了信道就不会和其他用户发生冲突。</li><li><strong>动态媒体介入控制</strong>，又称为<strong>多点接入</strong>。<ul><li>特点：信道并非在用户通信时固定分配给用户</li><li>分为两类：<ul><li>随机接入</li><li>受控接入</li></ul></li></ul></li></ul></li></ul></li><li><strong>适配器</strong>：<ul><li><strong>作用</strong>：计算机与外界局域网的连接是通过通信适配器进行的。<ul><li>适配器和局域网之间的通信是通过电缆或双绞线以<em>串行传输</em>方式进行的</li><li>适配器与计算机之间的通信是通过计算机主板上的 I/O 总线以<em>并行传输</em>方式进行的</li></ul></li><li>适配器在接收和发送各种帧时，不使用计算机的 CPU</li></ul></li><li>CSMA/CD 协议：<ul><li>CSMA/CD 指<strong>载波监听多点接入/碰撞检测</strong>（Carrier Sense Multiple Access with Collision Detection）</li><li>为了通信的简便，以太网采取以下两种措施：<ol><li>采用较为灵活的<strong>无连接</strong>的工作方式，即<em>不必先建立连接就可以直接发送数据</em>。<ul><li>适配器对发送的数据帧<strong>不进行编号，也不要求对方发回确认</strong>。<ul><li>原因：局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。</li><li>以太网提供的服务是<em>尽最大努力的交付</em>，即<strong>不可靠的交付</strong></li></ul></li><li>对有差错帧是否需要重传则由高层来决定</li><li>总线上，<em>在同一时间只能允许一台计算机发送数据</em>，否则各计算机之间就会相互干扰。</li></ul></li><li>以太网发送的数据都使用<strong>曼彻斯特编码</strong>的信号。<ul><li>曼彻斯特编码的编码方法：把每一个码元再分成两个相等的间隔</li><li>优点：保证了每一个码元的正中间出现一次电压的转换，而接收端就利用这种电压的转换很方便地把位同步信号提取出来</li><li>缺点：它所占的频带宽度比原始的基带信号增加了一倍（因为每秒传送的码元数加倍了）</li></ul></li></ol></li><li>CSMA/CD 协议的要点：<ul><li><strong>“多点接入”</strong><ul><li>许多计算机以多点接入的方式连接在一根总线上</li><li>协议的实质是：“载波监听”和“碰撞检测”</li></ul></li><li><strong>“载波监听”</strong><ul><li>用电子技术检测总线上有没有其他计算机也在发送，即<strong>检测信号</strong></li><li>不管在发送前，还是在发送中，每个站都必须不停地检测信道</li></ul></li><li><strong>“碰撞检测”</strong><ul><li>“边发送边监听”。即适配器边发送数据边检测信道上的信号电压的变化情况，一边判断自己在发送数据时其他站是否也在发送数据。</li></ul></li></ul></li><li>在使用 CSMA/CD 协议时，一个站<em>不可能同时进行发送和接收</em>。因此使用该协议的以太网不可能进行全双工通信而只能进行<strong>双向交替通信（半双工通信）</strong></li></ul></li><li><strong>集线器</strong><ul><li>双绞线以太网总是和集线器配合使用的</li><li>集线器的特点：<ul><li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是 CSMA/CD 协议。<ul><li>网络中的各站必须竞争对传输媒体的控制，并且在同一时刻至多只允许一个站发送数据</li></ul></li><li>一个集线器有许多接口</li><li>集线器工作在物理层。它的每个接口<strong>仅仅简单地转发比特</strong>，<strong>不进行碰撞检测</strong></li><li>集线器采用了专门的芯片，进行自适应传音回波抵消。<ul><li>这样可以使接口转发出去的较强信号不致对该接口接收到的较弱信号产生干扰</li></ul></li></ul></li></ul></li><li>MAC 层的硬件地址<ul><li><strong>硬件地址</strong>又称为<em>物理地址</em>或<em>MAC 地址</em>，实际上就是适配器地址</li><li>在标识系统中，地址是识别某个系统的一个非常重要的标识符</li><li>“名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处”</li><li>严格地讲，名字应当与系统所在地无关</li></ul></li></ul><h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><ul><li>常用方法：<ul><li><strong>网桥</strong>：对收到的额帧根据其 MAC 帧的地址进行<em>转发</em>和<em>过滤</em><ul><li>一次只能分析和转发一个帧</li></ul></li><li><strong>交换式集线器</strong>：常称为第二层交换机或以太网交换机<ul><li>这种交换机<strong>工作在数据链路层</strong></li><li>特点<ul><li>实质上就是一个<strong>多接口的网桥</strong>。<ul><li>每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。</li></ul></li><li>具有并行性。能同时连通多对接口，使多对主机能同时通信。</li><li>相互通信的主机都是<strong>独占传输媒体，无碰撞地传输数据</strong></li><li>以太网交换机地接口还有存储器，能在输出端口繁忙时<em>把到来的帧进行缓存</em>，以获取目的 MAC 地址</li><li>以太网交换机是一种即插即用设备。</li></ul></li><li>以太网交换机处理帧的方法：<ol><li>对收到的帧采用<strong>存储转发</strong>方式进行转发</li><li>对收到的帧采用<strong>直通</strong>交换方式</li></ol></li></ul></li></ul></li><li>虚拟局域网 VLAN<ul><li>虚拟局域网是由一些局域网网段构成的<em>与物理位置无关的逻辑组</em></li><li>每一个 VLAN 帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个 VLAN</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;p&gt;信道分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;点对点信道&lt;/strong&gt;：这种信道使用&lt;em&gt;一对一&lt;/em&gt;的点对点通信方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;广播信道&lt;/strong&gt;：这种信道使用&lt;em&gt;一对多&lt;/em&gt;的广播通信方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://storage.qiniu.aspi.tech/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%9C%B0%E4%BD%8D%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%9C%A8%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E6%B5%81%E5%8A%A8.png&quot; alt=&quot;数据链路层的位置及数据在数据链路层的流动&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;不同的链路层可能使用不同的数据链路层协议&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Computer Network" scheme="https://something.plus/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>《微机原理与接口技术（第五版）》第一章</title>
    <link href="https://something.plus/2019/05/29/Courses/2019-05-29-the-principle-of-microcomputer-chp1/"/>
    <id>https://something.plus/2019/05/29/Courses/2019-05-29-the-principle-of-microcomputer-chp1/</id>
    <published>2019-05-29T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><blockquote><p>本总结笔记基于钱晓捷老师的《微机原理与接口技术（第五版）》</p></blockquote><span id="more"></span><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><ul><li>计算集的运算和控制核心，即<em>中央处理单元</em>（CPU, Central Process Unit）</li><li><em>微处理器</em>(Micrprocessor):<ul><li>一块大规模集成电路芯片</li><li>代表着整个微型机系统的性能</li><li><em>微型机</em>：采用微处理器为核心构造的计算机</li></ul></li></ul><h2 id="处理器性能参数"><a href="#处理器性能参数" class="headerlink" title="处理器性能参数"></a>处理器性能参数</h2><ul><li><strong>字长</strong>：处理器每个时间单位可以处理的二进制数据位数</li><li><strong>时钟频率</strong>：表明处理器的处理速度，反映了处理器的基本时间单位</li><li><strong>集成度</strong>：表明处理器的生产工艺水平，通常用芯片上集成的晶体管数量来表达</li></ul><h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><p><strong>摩尔定律</strong>：每 18 个月，集成电路的性能将提高一倍，而其价格将降低一半</p><h2 id="处理器总线"><a href="#处理器总线" class="headerlink" title="处理器总线"></a>处理器总线</h2><ul><li><strong>系统总线</strong>：<ul><li>用于多个部件相互连接、传递信息的公共通道</li><li>任一时刻再总线上智能传送一种信息，但可以由多个部件在接收信息</li></ul></li><li><strong>数据总线</strong>：<ul><li>是处理器与存储器或外设交换信息的通道</li><li>其个数（条数）就是一次能够传送数据的二进制位数，通常<em>等于处理器字长</em></li><li>处理器的数据通过该组信号线输出到主存或外设，可以<em>双向传输</em>信号</li></ul></li><li><strong>地址总线</strong>：<ul><li>用于指定存储器或外设的具体单元</li><li>其个数反映处理器能够访问的主存储器容量或外设范围</li><li>在该组信号线上，处理器<em>单向输出</em>将要访问的主存单元或 I/O 端口的地址信息</li></ul></li><li><strong>控制总线</strong>：<ul><li>用于协调系统中各部件的操作</li><li>控制总线决定了总线的功能强弱、适应性的好坏</li><li>各类总线的特点主要取决于其控制总线</li></ul></li></ul><h2 id="80x86-系列处理器"><a href="#80x86-系列处理器" class="headerlink" title="80x86 系列处理器"></a>80x86 系列处理器</h2><ul><li><em>8086</em>：<ul><li>主存容量为 2^20 B = 1 MB</li></ul></li><li><em>80286</em>:<ul><li>主存容量为 2^32 B = 4 GB</li></ul></li></ul><h2 id="冯·诺伊曼计算机的基本思想"><a href="#冯·诺伊曼计算机的基本思想" class="headerlink" title="冯·诺伊曼计算机的基本思想"></a>冯·诺伊曼计算机的基本思想</h2><ul><li>采用<em>二进制</em>形式表示数据和指令，指令由<em>操作码</em>和<em>地址码</em>组成<ul><li>指令是控制计算机操作的命令，是处理器不需要翻译就能识别（直接执行）的“母语”，即机器语言</li><li>程序是由指令构成的</li><li>指令的操作码表明指令的操作</li><li><em>操作数</em>是参与操作的数据，主要以寄存器或存储器地址形式指明数据的来源，所以也称<strong>地址码</strong></li></ul></li><li>“<strong>存储程序</strong>”、“<strong>程序控制</strong>”<ul><li>存储程序：把指令以代码的形式事先输入到计算机的主存储器中，这些指令按一定的规则组成程序</li><li>程序控制：当计算机启动后，程序会控制计算机按规定的顺序逐条执行指令，自动完成预定的信息处理任务</li></ul></li><li>指令的执行是<em>顺序</em>的，即一般按照指令再存储器中存放的顺序执行，程序分支由转移指令实现</li><li>计算机由<em>存储器、运算器、控制器、输入设备和输出设备</em>5 大基本部件组成。</li></ul><p>数字计算机中信息的最基本单位就是<em>二进制位</em>，或称<em>比特位</em>。</p><ul><li>半字节：4 个二进制位</li><li>一字节：8 个二进制位</li><li>字：16 位</li><li>双字：32 位</li><li>四字：64 位</li></ul><h2 id="处理器的主要功能"><a href="#处理器的主要功能" class="headerlink" title="处理器的主要功能"></a>处理器的主要功能</h2><ul><li><strong>取指</strong>：从主存储器读取指令</li><li><strong>译码</strong>：翻译指令代码的功能</li><li><strong>执行</strong>：执行指令所规定的操作</li></ul><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><ul><li>存储器：用来存放程序和数据的部件</li><li><em>主存储器</em>：<ul><li>造价高、速度快、容量小</li><li>用来存放当前正在运行的程序和正待处理的数据</li></ul></li><li><em>辅助存储器</em>（简称<em>辅存</em>或<em>外存</em>）:<ul><li>造价低、容量大、信息可长期保存、速度慢</li><li>主要用来长久保存程序和数据</li></ul></li></ul><h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p><img src="http://storage.qiniu.aspi.tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机系统的层次结构"></p><ul><li><em>用户层</em>：<ul><li>是计算机用户看到的计算机</li><li>呈现给用户的是可执行程序和数据文件</li></ul></li><li><em>高级语言层</em>：<ul><li>面向软件程序员</li></ul></li><li><em>汇编语言层</em>：<ul><li>面向系统程序员</li><li>汇编语言程序员需要利用操作系统提供的功能，掌握指令系统，理解主存储器的组织</li></ul></li><li><em>操作系统层</em>：<ul><li>操作系统是最主要的系统程序，也称为系统软件层</li></ul></li><li><em>机器语言层</em>：<ul><li>由处理器直接识别的指令组成，面向系统结构设计师</li><li>该层具有承上启下的功能。一方面为上层软件提供硬件指令支持，另一方面是下层硬件实现的目标</li></ul></li><li><em>控制层</em>：<ul><li>面向硬件设计师</li><li>这一层由微程序实现，也可以由硬布线实现</li></ul></li><li><em>数字电路层</em>：<ul><li>是计算机的具体物理实现</li></ul></li></ul><h2 id="软件与硬件的等价性原理"><a href="#软件与硬件的等价性原理" class="headerlink" title="软件与硬件的等价性原理"></a>软件与硬件的等价性原理</h2><ul><li>原则上说，任何一个由软件所完成的操作也可以直接由硬件来实现，任何一条由硬件所执行的指令也能用软件来完成。</li><li>软件与硬件的等价性原理是指<em>软硬件在逻辑功能上的等价</em>，并<em>不意味</em>着在现实中性能和成本的等价。<ul><li>软件易于实现各种逻辑和运算功能，但是往往速度较慢，甚至不能满足时间要求</li><li>硬件则可以高速实现逻辑和运算功能，但是难以实现复杂功能或计算，甚至无法实现</li></ul></li></ul><h2 id="计算机的结构、组成与实现"><a href="#计算机的结构、组成与实现" class="headerlink" title="计算机的结构、组成与实现"></a>计算机的结构、组成与实现</h2><ul><li><strong>计算机结构</strong>：<ul><li>计算机结构是指为机器编写正确的（时间无关的）程序、机器语言程序员必须理解的一种结构。</li><li><strong>指令集结构</strong>：<ul><li>计算机结构的经典定义确定了计算机系统中软件和硬件的接口，即<em>指令集结构</em></li><li>它包括指令集（指令系统）、指令格式、数据类型、寄存器、寻址方式、主存访问方式和 I/O 机制等</li></ul></li></ul></li><li><strong>计算机组成</strong>：<ul><li>也称为<em>计算机组织</em>，是计算机结构的逻辑实现（逻辑设计），对应计算机层次结构的控制层。</li></ul></li><li><strong>计算机实现</strong>：<ul><li>是计算机组成物理实现，对应<em>数字电路层</em></li></ul></li></ul><h2 id="软件兼容与系列机和兼容机"><a href="#软件兼容与系列机和兼容机" class="headerlink" title="软件兼容与系列机和兼容机"></a>软件兼容与系列机和兼容机</h2><ul><li><strong>软件兼容</strong>：指<em>同一个厂家</em>生产的具有<em>相同计算机结构</em>，但具有<em>不同组成和实现</em>的一系列不同档次、不同型号的机器。</li><li><strong>兼容机</strong>：指<em>不同厂家</em>生产的具有<em>相同计算机结构</em>（<em>不同的组成和实现</em>）的计算机</li><li>为了保证软件的<strong>向上向下、向前向后兼容</strong>，系列机和兼容机必须保持结构不变，但这又限制了计算机结构的发展</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本总结笔记基于钱晓捷老师的《微机原理与接口技术（第五版）》&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Computers and Digital Systems" scheme="https://something.plus/tags/Computers-and-Digital-Systems/"/>
    
  </entry>
  
  <entry>
    <title>2019 Robocup 赛后总结</title>
    <link href="https://something.plus/2019/04/24/Essays/2019-04-24-2019-robocup-summary/"/>
    <id>https://something.plus/2019/04/24/Essays/2019-04-24-2019-robocup-summary/</id>
    <published>2019-04-24T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019-Robocup-赛后总结"><a href="#2019-Robocup-赛后总结" class="headerlink" title="2019 Robocup 赛后总结"></a>2019 Robocup 赛后总结</h1><blockquote><p>任对方调得激烈，我方自是唠的火热。倒也是挺符合我们的队名：不管怎么样反正 NAO 就队!</p></blockquote><span id="more"></span><p><img src="http://storage.qiniu.aspi.tech/2019robocup/%E8%B5%9B%E5%90%8E%E5%90%88%E7%85%A7.jpg" alt=""></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>上周我们有幸代表郑州大学去绍兴参加 2019 年 Robocup 中国赛。</p><p>作为第一次参加的队伍，我们今年的准备并不充分。一开始大家并没有使用 BHuman 平台，而是从网上找的各种资料来用 Python 自己造轮子。从寒假到 3 月底，我们用了足足三个月的时间造了一个不那么圆的轮子……直到三月底政乔跟其他学校交流，我们才知道大部分队伍用的是 BHuman 平台。</p><p>四月初，在我和政乔去同济学习回来后，我们才算是真正开始准备本次比赛。而此时，距大赛开始只有不到半个月的时间。</p><p>因为只有半个月的时间，所以太过仓促了。BHuman 平台中的许多调试工具都没用上，购买的绿毯也比正式比赛的场地要硬得多……在学校调试的防守员下坐防御动作在比赛场地上根本不能用，只要下坐就会往前倒。临出发前，5 号的头部风扇一直嗡嗡响，备用机 6 号也出了问题，一直到出发也没再能拿出一台备用机。</p><p>总之，仓促之中我们就此出战。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p><img src="http://storage.qiniu.aspi.tech/2019robocup/%E4%BC%9A%E5%9C%BA%E5%90%88%E7%85%A7.jpg" alt="会场合照"></p><p>初到绍兴，才发现这里不愧是南方水乡。城市中到处都有河流穿过，站在桥上迎着吹来的风还是挺凉爽的~</p><p>这次比赛和以往比赛相比规格真的高得多。会场服务十分到位，每天都有班车接送，宾馆也提供早餐，报道注册时还送了很多小东西。</p><p>绍兴这个地方我觉得很神奇，明明人很少，住宅区看上去也不是很高大上，但是附近的商场却很漂亮。然而直到晚上，我们一群男生去寻找网吧时才明白，这附近的商业并没有看上去那么发达。好多店都关门了，不仅仅是网吧，甚至商场里的饭店也是。柯桥区的商业有种让人觉得金玉其外，败絮其中的感觉。</p><p><img src="http://storage.qiniu.aspi.tech/2019robocup/%E5%AE%BE%E9%A6%86%E5%B0%8F%E5%8D%A1%E7%89%87.jpg" alt="宾馆小卡片"><br>夜晚的宾馆也是让人觉得没有那么舒服。且不说住了这么久的宾馆第一次碰到有人塞小卡片，每晚凌晨时分都有人在走廊大声说话。住了五晚，我没有一晚是能睡踏实的……</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>比赛耗时三天，算上调试一共是四天。我们因为没有带备用机，所以只在调试那一天，针对场地适应性进行了调整，后期都是在电脑上用 SimRobot 调整参数。这也就导致了后面比赛的三天里，所有队伍都在场上紧张刺激地进行调试，只有我们坐在场边唠嗑~这一唠，就唠了三天……</p><p>说来惭愧，因为是首秀，对其他学校的实力没有一个认知，我们在开始比赛前一直担心能否赢至少一场拿个三等奖……赢了华师的时候，又听说集美大学弃赛，这就代表我们能赢至少两场。换言之，三等奖稳了。然而对上上交，还是没能赢。怎么说呢，不愧是去年亚军。</p><p>第一天 16 进 12，我们已经觉得很幸运了，而且也已经达成了我们的预期目标，所以后来基本就没什么压力，大家唠嗑唠地更开心了~</p><p>第二天 12 进 8。踢厦大那场基本没什么压力。但是踢武大那场状态不断。先是边裁吹哨被主裁以为是对场吹的，结果没有点 Play。我们在 set 情况下 30 多秒就踢进了一球，却没办法加分。还好李树老师裁决进球有效。然而后来我方 5 号就坏了……前期在学校调试，把 5 号散热扇摔坏了。没想到这个时候爆发出来问题了，导致对武大这场 1：2 输了……不过好在后来厦大踢赢了武大，我们也能够出线。</p><p>8 进 4 时对上南京邮电大学，当时我们已经能够稳拿二等奖，又看着南邮在场上调地热火朝天，我们在场边唠嗑的时候还想着这次已经赚了，估摸着第二天就能出去旅游了。比赛时，和身边的南邮老哥还在说估计我们明天就能出去旅游……结果后面又赢了，说来挺对不起那老哥的，毕竟当面扎心……晚上半决赛又对上了上交，毫无疑问的输了。</p><p>最后一天是和西北民族大学竞争第三名，上半场四号又坏了，被西民抓住机会抢先进了一球。下半场四号调整完毕，5 台 NAO 相互配合，算是踢进了一球，扳平了比分。之前万万没想过我们会踢出平局需要点球，不过西民也没想到，大家准备的都不充分。休息的五分钟里，我提议直接烧 BHuman 提供的例程 Striker，没想到还挺好用的，也得亏西民的守门员一直往边界走，我们才能做到三球三进，最终夺得季军。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p><img src="http://storage.qiniu.aspi.tech/2019robocup/%E5%A5%96%E6%9D%AF.jpg" alt="奖杯"></p><p>这次比赛，因为是郑州大学的首秀，我们自身压力也没那么大，所以在看到别人激烈地调机器时，还能愉快地唠嗑，最终唠出季军~</p><p>所以说这次比赛和我们没什么关系，都是 NAO 自己努力的结果~</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2019-Robocup-赛后总结&quot;&gt;&lt;a href=&quot;#2019-Robocup-赛后总结&quot; class=&quot;headerlink&quot; title=&quot;2019 Robocup 赛后总结&quot;&gt;&lt;/a&gt;2019 Robocup 赛后总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;任对方调得激烈，我方自是唠的火热。倒也是挺符合我们的队名：不管怎么样反正 NAO 就队!&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essays" scheme="https://something.plus/categories/Essays/"/>
    
    
    <category term="Life" scheme="https://something.plus/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://something.plus/2019/03/24/Courses/2019-03-24-computer-network-chp2/"/>
    <id>https://something.plus/2019/03/24/Courses/2019-03-24-computer-network-chp2/</id>
    <published>2019-03-24T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><blockquote><p>首先强调指出，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体</p></blockquote><span id="more"></span><h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><ol><li><p>物理层的主要任务：确定与传输媒体的接口有关的一些特性</p><ol><li><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸，引脚数目和排列，固定和锁定装置等。</li><li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压的范围</li><li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压表示何种意义</li><li><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序</li></ol></li><li><p><strong>串行传输</strong>：数据在通信线路（传输媒体）上的传输方式一般都是串行传输，即逐个比特按照时间顺序传输。因此物理层还要完成传输方式的转换。</p></li></ol><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="数据通信系统的三大部分"><a href="#数据通信系统的三大部分" class="headerlink" title="数据通信系统的三大部分"></a>数据通信系统的三大部分</h3><ol><li><p><strong>源系统</strong>（发送端、发送方）</p><ol><li><em>源点</em>：源点设备产生要传输的数据，又称为源站或信源</li><li><em>发送器</em>：<ul><li>通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。</li><li>典型的发送器就是调制器。</li></ul></li></ol></li><li><p><strong>传输系统</strong>（传输网络）</p></li><li><p><strong>目的系统</strong>（接收端、接收方）</p><ol><li><em>接收器</em>：<ul><li>接受传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。</li><li>典型的接收器就是解调器</li></ul></li><li><em>终点</em>：终点设备从接收器获取传送来的数字比特流，然后把信息输出，又称为<em>目的站</em>或<em>信宿</em></li></ol></li></ol><h4 id="常用术语："><a href="#常用术语：" class="headerlink" title="常用术语："></a>常用术语：</h4><ul><li><p><strong>通信</strong>：目的是传送消息（Message），如话音、文字、图像、视频等</p></li><li><p><strong>数据</strong>：是运送信息的实体，通常是有意义的符号序列</p></li><li><p><strong>信号</strong>：是数据的电气或电磁的表现，根据信号中代表信息的参数的取值方式不同，信号可分为两大类：</p><ol><li><p><em>模拟信号</em>（连续信号）——代表信息的参数的取值是连续的</p></li><li><p><em>数字信号</em>（离散信号）——代表信息的参数的取值是离散的</p></li></ol></li><li><p><strong>码元</strong>：在使用时间域（或简称为时域）的波形表示数字信号时，则代表不同离散数值的基本波形</p></li></ul><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条<em>发送信道</em>和一条<em>接受信道</em>。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ol><li><p><strong>单向通信（单工通信）</strong>：即只能有一个方向的通信而没有反方向的交互，例如电视广播</p></li><li><p><strong>双向交替通信（半双工通信）</strong>：即通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收），是一方发送，另一方接收，过一段时间后再反过来</p></li><li><p><strong>双向同时通信（全双工通信）</strong>：即通信的双方可以同时发送和接收信息</p></li></ol><p><strong>基带信号</strong>：来自信源的信号。基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。所以，必须对基带信号进行<em>调制</em>。</p><p><strong>调制</strong>：</p><ol><li><p><strong>基带调制</strong>：仅仅对基带信号的波形进行变换，使它能够与信道特性相适应，变换后信号仍然是基带信号。因此大家更愿意把这种过程称为<strong>编码</strong>。</p></li><li><p><strong>带通调制</strong>：需要使用<em>载波</em>进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>（即仅在一段频率范围内能够通过信道）。</p></li></ol><h4 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h4><p><img src="http://storage.qiniu.aspi.tech/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="数字信号常用的编码方式"></p><ol><li><p><strong>不归零制</strong>：正电平代表 1，负电平代表 0</p></li><li><p><strong>归零制</strong>：正脉冲代笔哦啊 1，负脉冲代表 0</p></li><li><p><strong>曼切斯特编码</strong>：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1，也可以反过来定义</p></li><li><p><strong>差分曼切斯特编码</strong>：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1</p></li></ol><h4 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h4><p><img src="http://storage.qiniu.aspi.tech/%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95.png" alt="最基本的三种调制方式"></p><ol><li><p><strong>调幅（AM）</strong>：即载波的振幅随基带数字信号而变化，例如，0 或 1 分别对应于无载波或有载波输出</p></li><li><p><strong>调频（FM）</strong>：即载波的频率随基带数字信号而变化，例如，0 或 1 分别对应于频率 f1 或 f2</p></li><li><p><strong>调相（PM）</strong>：即载波的初始相位随基带数字信号而，例如，0 或 1 分别对应于相位 0 度或 180 度</p></li></ol><h4 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h4><p>码元传输的速率越高，或信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形的失真就越严重。从概念上讲，限制码元在信道上的传输速率有以下两个：</p><ol><li><p>信道能够通过的频率范围</p><ul><li><strong>码间串扰</strong>：<ul><li>在接收端收到的信号波形失去了码元之间的清晰界限。</li></ul></li><li><strong>奈氏准则</strong>：在任何信道中，码元传输的速率是有上限的，传输速率超过次上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li><li>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</li></ul></li><li><p>信噪比</p><ol><li><strong>信噪比</strong>：<ul><li>信号的平均功率和噪声的平均功率之比，常记为 S/N，并用分贝（dB）作为度量单位。</li><li>即：信噪比(dB) = 10 log10(S/N) (dB)</li></ul></li><li><strong>香农公式</strong>：<ul><li>信道的极限信息传输速率 C 是:C = W log2(1+S/N) (bit/s)</li><li><em>W</em>为信道的带宽（以 Hz 为单位）；<em>S</em>为信道内所传信号的平均功率；<em>N</em>为信道内部的高斯噪声功率。</li><li>香农公式表明：<em>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</em></li><li>香农公式的意义：<em>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</em></li><li>除此之外，还有一个提高信息的传输速率的方法，就是用编码的方法让每一个码元携带更多比特的信息量</li></ul></li></ol></li></ol><h3 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h3><h4 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h4><p><strong>传输媒体</strong>也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。</p><ol><li><p>导引型传输媒体：电磁波被导引沿着固定媒体（铜线或光纤）传播</p></li><li><p>非导引型传输媒体：指自由空间，常称为无线传输</p></li></ol><h5 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h5><ol><li><p>双绞线：</p><ul><li>把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合起来就构成双绞线。</li><li>它是最古老但又是最常用的传输媒体。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。导线越粗，其通信距离就越远，但导线的价格也越高</li><li>为了提高双绞线的抗电磁干扰的能力，可以在双绞线外面再加上一层用金属丝编织成的屏蔽层，也就是<strong>屏蔽双绞线</strong>，简称 STP，价格比无屏蔽双绞线 UTP 要贵一些</li><li><p>现在常用的 UTP 是 5 类线</p></li><li><p>直通：A——A 异类相接 B——B</p></li><li><p>交叉：A——B 同类相接</p></li></ul></li></ol><div class="table-container"><table><thead><tr><th>序号</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>A 序</td><td>绿白</td><td>绿</td><td>橙白</td><td>蓝</td><td>蓝白</td><td>橙</td><td>棕白</td><td>棕</td></tr><tr><td>B 序</td><td>橙白</td><td>橙</td><td>绿白</td><td>蓝</td><td>蓝白</td><td>绿</td><td>棕白</td><td>棕</td></tr></tbody></table></div><ol><li><p><strong>同轴电缆</strong>：由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及保护塑料外层所组成。</p><ul><li><p>同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。</p></li><li><p>同轴电缆的带宽取决于电缆的质量。</p></li><li><p>50 欧姆：粗，LAN/数字传输常用</p></li><li><p>75 欧姆：细，有线电视/模拟传输常用</p></li></ul></li><li><p><strong>光缆</strong>：光纤通信就是利用光导纤维传递光脉冲来进行通信，有光脉冲相当于 1，没有光脉冲相当于 0。 光纤是光纤通信的传输媒体。</p><ul><li><p>多模光纤：可以存在多条不同角度入射的光纤在一条光钎中传输</p></li><li><p>单模光钎：光钎的直径减小到只有一个光的波长，则光钎就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射</p></li></ul><p>在光钎通信中常用的三个波段的中心分别位于 850nm，1310nm 和 1550nm。所以这三个波段都具有 25000-30000GHz 的宽带</p><ul><li><p>光钎的优点：</p><ol><li><p>通信容量大；</p></li><li><p>传输损耗小，中继距离长，对远距离传输特别经济；</p></li><li><p>抗雷电和电磁干扰性能好，这在有大电流脉冲干扰的环境下尤为重要；</p></li><li><p>无串音干扰，保密性好，也不易被窃听或截取数据；</p></li><li><p>体积小，重量轻，这在现有电缆管道已拥塞不堪的情况下特别有利。</p></li></ol></li></ul></li></ol><h3 id="信道复用技术（提高信道利用率）"><a href="#信道复用技术（提高信道利用率）" class="headerlink" title="信道复用技术（提高信道利用率）"></a>信道复用技术（提高信道利用率）</h3><ul><li><p><strong>复用</strong>：通信技术中的基本概念</p></li><li><p><strong>频分复用</strong>：</p><ul><li>用户在分配到一定的频带后，在通信过程中自始自终都占用这个频带。</li><li>所有用户在同样的时间占用不同的宽带资源。</li></ul></li><li><p><strong>时分复用</strong>：</p><ul><li>将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>所有用户是在不同的时间占用同样的频带宽度。</li><li>由于计算机的<strong>突发性质</strong>，用户对已经分配到的子信道的利用率一般是不高的</li></ul></li><li><p><strong>统计时分复用</strong>：是一种改进的时分复用，它能明显地提高信道的利用率</p></li><li><p><strong>波分复用</strong>：光的频分复用，借用传统的载波电话的频分复用的概念，使用一根光纤来同时传送多个频率很接近的光载波信号</p></li><li><p><strong>码分复用</strong>：</p><ul><li>每一个用户可以在同样的时间使用同样的频带进行通信。</li><li>由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</li></ul></li></ul><h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><ul><li><p><strong>ADSL 技术</strong>：非对称数字用户线，是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带数字业务。</p></li><li><p><strong>光纤同轴混合网（HFC 网）</strong>：目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传送电视节目外，还能提供电话、数据和其他宽带交互型业务。</p></li><li><p><strong>FTTx 技术</strong>：光纤到 x 技术，这里的 x 可代表不同的光纤接入点</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;物理层&quot;&gt;&lt;a href=&quot;#物理层&quot; class=&quot;headerlink&quot; title=&quot;物理层&quot;&gt;&lt;/a&gt;物理层&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;首先强调指出，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Computer Network" scheme="https://something.plus/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>电路交换与分组交换</title>
    <link href="https://something.plus/2019/03/17/Courses/2019-03-17-computer-network-chp-1/"/>
    <id>https://something.plus/2019/03/17/Courses/2019-03-17-computer-network-chp-1/</id>
    <published>2019-03-17T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、电路交换与分组交换"><a href="#一、电路交换与分组交换" class="headerlink" title="一、电路交换与分组交换"></a>一、电路交换与分组交换</h1><span id="more"></span><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><ol><li>定义：<br>电路交换是以电路连接为目的的交换方式。通信之前要在通信两方之间建立一条被两方独占的物理通道。</li><li>三个阶段：<ol><li>建立连接</li><li>通信</li><li>释放连接</li></ol></li><li>优点：<ol><li>因为通信线路为通信两方用户专用，数据直达。所以数据传输的时延非常小；</li><li>通信两方之间的屋里通路一旦建立，两方能够随时通信，实时性强；</li><li>两方通信时按发送顺序传送数据，不存在失序问题；</li><li>电路交换既适用于传输模拟信号，也适用于传输数字信号；</li><li>电路交换的交换设备及控制均比较简单。</li></ol></li><li>缺点：<ol><li>电路交换平均连接建立时间对计算机通信来说较长；</li><li>电路交换家里连接后，物理通路被通信两方独占，即使通信线路空暇，也不能供其它用户使用，因而信道利用率低；</li><li>电路交换时，数据直达。不同类型、不同规格、不同速率的终端非常难相互进行通信，也难以在通信过程中进行差错控制。</li></ol></li></ol><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><ol><li>定义：<br>分组交换是以分组为单位进行传输和交换的，它是一种<em>存储——转发</em>交换方式。即将到达交换机的分组先送到存储器临时存储和处理，等到对应的输出电路有空暇时再送出。</li><li>长处：<ol><li>分组交换不须要为通信双反预先建立一条专用的通信线路。不存在连接建立时延，用户可随时发送分组；</li><li>因为采用存储转发方式，加之交换节点具有路径选择，当某条传输线路故障时可选择其它传输线路，提高了传输的可靠性；</li><li>通信双方不是固定地占用一条通信线路，而是在不同的时间一段一段地部分占用这条物理通路，因而大大提高了通信线路的利用率；</li><li>加速了数据在网络中的传输。因为分组是逐个传输，能够使后一个分组的存储操作与前一个分组的转发操作并行。这样的流水线式传输方式降低了传输时间，提升了效率；</li><li>分组长度固定，对应的缓冲区的大小也固定，所以简化了交换节点中存储器的管理；</li><li>分组较短，出错几率降低，每次重发的数据量也降低，不仅提高了可靠性，也降低了时延。</li></ol></li><li>缺点：<ol><li>因为数据进入交换节点后要经历存储转发这一过程，从而引起的转发时延（包含接受分组、检验正确性、排队、发送时间等），并且网络的通信量越大，造成的时延就越大。实时性较差；</li><li>分组交换仅仅适用于数字信号；</li><li>分组交换可能出现失序，丢失或反复分组。分组到达目的节点时，对分组按编号进行排序等工作添加了麻烦。</li></ol></li></ol><p>综上，若传输的数据量非常大，并且传送时间远大于呼叫时间。则采用<em>电路交换</em>较为合适；当端到端的通路有非常多段链路组成时，采用<em>分组交换</em>较为合适。从提高整个网络的信道利用率上看，<strong>分组交换优于电路交换</strong>。</p><h1 id="二、协议及其三要素"><a href="#二、协议及其三要素" class="headerlink" title="二、协议及其三要素"></a>二、协议及其三要素</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ol><li>定义：<br><strong>网络协议</strong>(Network protocol)： 为进行网络中的数据交换而建立的规则、标准或约定。</li><li>作用：<br>协议明确规定了所交换的数据的格式以及有关的同步问题</li></ol><h2 id="组成三要素"><a href="#组成三要素" class="headerlink" title="组成三要素"></a>组成三要素</h2><ol><li><strong>语法</strong>，即数据与控制信息的结构或格式；</li><li><strong>语义</strong>，即需要发出何种控制信息，完成何种动作以及做出何种响应:</li><li><strong>同步</strong>，即事件实现顺序的详细说明。</li></ol><h1 id="协议为什么分层？"><a href="#协议为什么分层？" class="headerlink" title="协议为什么分层？"></a>协议为什么分层？</h1><h2 id="协议各层次的功能"><a href="#协议各层次的功能" class="headerlink" title="协议各层次的功能"></a>协议各层次的功能</h2><ol><li><strong>差错控制</strong>：使相应层次对等方的通信更加可靠。</li><li><strong>流量控制</strong>：发送端的发送速率必须使接收端来得及接收，不要太快。</li><li><strong>分段和重装</strong>：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li><strong>复用和分用</strong>：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li><strong>连接建立和释放</strong>：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li></ol><h2 id="协议为什么分层"><a href="#协议为什么分层" class="headerlink" title="协议为什么分层"></a>协议为什么分层</h2><ol><li><strong>各层之间是独立的</strong>。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口(即界面)所提供的服务。由于每一层只实现一种相对独立的功能，因而可将一个难以处理的复杂问题分解为若干个较容易处理的更小一些的问题。这样，整个问题的复杂程度就下降了。</li><li><strong>灵活性好</strong>。当任何一层发生变化时(例如由于技术的变化)，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某 → 层提供的服务还可进行修改。当某层提供的服务不再需要时，甚至可以将这层取消。</li><li><strong>结构上可分割开</strong>。各层都可以采用最合适的技术来实现。</li><li><strong>易于实现和维护</strong>。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统己被分解为若干个相对独立的子系统。</li><li><strong>易于实现和维护</strong>。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统己被分解为若干个相对独立的子系统。</li></ol><h2 id="分层的缺点"><a href="#分层的缺点" class="headerlink" title="分层的缺点"></a>分层的缺点</h2><p>有些功能会在不同的层次中重复出现，因而产生了额外开销。</p><h1 id="什么是计算机网络体系结构？"><a href="#什么是计算机网络体系结构？" class="headerlink" title="什么是计算机网络体系结构？"></a>什么是计算机网络体系结构？</h1><ol><li><strong>网络的体系结构</strong>(architecure)：计算机网络的各层及其协议的集合，是这个计算机网络及其构件所应完成的功能的精确定义。</li><li>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。</li></ol><h2 id="具有五层协议的体系结构"><a href="#具有五层协议的体系结构" class="headerlink" title="具有五层协议的体系结构"></a>具有五层协议的体系结构</h2><p><img src="/images/计算机网络体系结构.png" alt="计算机网络体系结构"></p><ol><li>应用层<ol><li>任务：是通过应用进程间的交互来完成特定网络应用。</li><li>协议：应用层协议定义的是应用进程间通信和交互的规则。</li><li><strong>报文</strong>：应用层交互的数据单元</li></ol></li><li>运输层<ol><li>任务：负责向两台主机中进程之间的通信提供通用的数据传输服务</li><li>协议：<ol><li><strong>传输控制协议 TCP</strong> (Transmission Control Protocol)一一提供面向连接的、可靠的数据传输服务，其数据传输的单位是<em>报文段</em>(segment)。</li><li><strong>用户数据报协议 UDP</strong> (User Datagram Protocol)— 提供无连接的、尽最大努力(best-effort) 的数据传输服务(不保证数据传输的可靠性)，其数据传输的单位是<em>用户数据报</em>。</li></ol></li></ol></li><li>网络层<ol><li>任务：网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</li><li>协议：使用 IP 协议</li></ol></li><li>数据链路层<br>任务：在两个相邻结点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成<em>帧</em>(framing) ，在两个相邻结点间的链路上传送<em>帧</em>(frame) 。每一<strong>帧</strong>包括<em>数据</em>和必要的<em>控制信息</em>(如同步信息、地址信息、差错控制等)。</li><li>物理层<br>任务：<ol><li>在物理层上所传数据的单位是<strong>比特</strong>。</li><li>物理层要考虑用多大的电压代表 “1”或”0” ，以及接收方如何识别出发送方所发送的比特。</li><li>物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。</li></ol></li></ol><h1 id="协议与服务的关系"><a href="#协议与服务的关系" class="headerlink" title="协议与服务的关系"></a>协议与服务的关系</h1><ol><li><strong>实体</strong>(entity)：任何可发送或接收信息的硬件或软件进程</li><li><strong>协议</strong>：控制两个对等实体(或多个实体)进行通信的规则的集合</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</li><li>协议是”<em>水平的</em>“，即协议是控制对等实体之间通信的规则。但服务是”<em>垂直的</em>“，即服务是由下层向上层通过层间接口提供的。另外，并非在一个层内完成的全部功能都称为服务。只有那些能够被高一层实体”看得见”的功能才能称之为”服务”。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、电路交换与分组交换&quot;&gt;&lt;a href=&quot;#一、电路交换与分组交换&quot; class=&quot;headerlink&quot; title=&quot;一、电路交换与分组交换&quot;&gt;&lt;/a&gt;一、电路交换与分组交换&lt;/h1&gt;</summary>
    
    
    
    <category term="Courses" scheme="https://something.plus/categories/Courses/"/>
    
    
    <category term="Computers and Digital Systems" scheme="https://something.plus/tags/Computers-and-Digital-Systems/"/>
    
  </entry>
  
  <entry>
    <title>Github常见操作及问题</title>
    <link href="https://something.plus/2018/11/07/Techniques/2018-11-07-github/"/>
    <id>https://something.plus/2018/11/07/Techniques/2018-11-07-github/</id>
    <published>2018-11-07T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-常见操作及问题"><a href="#Github-常见操作及问题" class="headerlink" title="Github 常见操作及问题"></a>Github 常见操作及问题</h1><blockquote><p>笔者每次新建仓库后首次同步都记不住操作，故干脆开篇博客记录一下</p></blockquote><span id="more"></span><h2 id="本地仓库首次推送"><a href="#本地仓库首次推送" class="headerlink" title="本地仓库首次推送"></a>本地仓库首次推送</h2><ol><li><code>git init</code></li><li><code>touch README.md</code></li><li><code>git add .</code>也可以<code>git remote add origin git@github.com:xxxxx/yyyyy.git</code></li><li><code>git commit -m &quot;first commit&quot;</code></li><li><code>git push -u origin master</code></li><li>如果推送失败，但是上面又没有什么必要的，可以使用强制推送<code>git push -f origin master</code></li></ol><h2 id="删除-github-仓库上的文件夹"><a href="#删除-github-仓库上的文件夹" class="headerlink" title="删除 github 仓库上的文件夹"></a>删除 github 仓库上的文件夹</h2><ol><li><code>git pull orint master</code>将远程仓库拉下来;</li><li><code>dir</code>查看目录;</li><li><code>git rm -r --cached 文件夹名</code>将指定文件夹删除;</li><li><code>git commit -m &#39;删除了XXX文件夹&#39;</code>提交并添加操作说明;</li><li><code>git push -u origin master</code>将本次操作推送到 github 上</li></ol><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><p>同步时出现<code>Permanently added the RSA host key for IP address &#39;xxx.xxx.xxx.xxx&#39; to the list of known host</code><br>这个提示只是一个警告，对实际操作没有影响。若要取消这个提示，只需在 hosts 文件下添加一条记录就可以了：</p><p><code>sudo vim /etc/hosts</code></p><p>打开之后，添加<code>xxx.xxx.xxx.xxx github.com</code>，保存并关闭即可</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Github-常见操作及问题&quot;&gt;&lt;a href=&quot;#Github-常见操作及问题&quot; class=&quot;headerlink&quot; title=&quot;Github 常见操作及问题&quot;&gt;&lt;/a&gt;Github 常见操作及问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;笔者每次新建仓库后首次同步都记不住操作，故干脆开篇博客记录一下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="Github" scheme="https://something.plus/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Java通过Cookie模拟登录微博</title>
    <link href="https://something.plus/2018/10/17/Techniques/2018-10-17-use-cookie-signin-weibo/"/>
    <id>https://something.plus/2018/10/17/Techniques/2018-10-17-use-cookie-signin-weibo/</id>
    <published>2018-10-17T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-通过-Cookie-模拟登录微博"><a href="#Java-通过-Cookie-模拟登录微博" class="headerlink" title="Java 通过 Cookie 模拟登录微博"></a>Java 通过 Cookie 模拟登录微博</h1><blockquote><p>笔者从开始了解到写出这篇博客一共只用了几天的时间，所以本文更适合小白参考<br>本文以 weibo.cn 为例，但只需修改 Request Header 中的部分参数，也可用与模拟登录 weibo.com</p></blockquote><span id="more"></span><h2 id="浏览器端操作"><a href="#浏览器端操作" class="headerlink" title="浏览器端操作"></a>浏览器端操作</h2><blockquote><p>firefox 下有款插件挺好用的，但笔者只安装了 Chrome，故本文只介绍 Chrome 下的操作。</p></blockquote><ol><li><p>在 Chrome 中打开”weibo.cn”，按下<code>F12</code>，在”Network”中勾选”Preserve log”<br><img src="/img/in-post/2018-10-17-cookie/preserve-log.png" alt="preserve-log"></p></li><li><p>点击”登录”，输入自己的帐号密码并登录</p></li><li><p>登录之后查看刚才的”Network”，下面出现了许多文件，从中找到以自己首页地址命名或命名为”home”的文件并点击，找到”Request Headers”一栏<br><img src="/img/in-post/2018-10-17-cookie/network-home.png" alt="network-home"></p></li></ol><p>浏览器端的操作基本就是这样，接下来我们开始写代码</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><ol><li><p>为了方便操作，笔者将部分操作封装成了实体类。首先是操作 Cookie 的实体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.http.client.HttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.BasicCookieStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpClient client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpPost post;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpGet get;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BasicCookieStore cookieStore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HttpClient <span class="title function_">getClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClient</span><span class="params">(HttpClient client)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HttpPost <span class="title function_">getPost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> post;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPost</span><span class="params">(HttpPost post)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.post = post;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HttpGet <span class="title function_">getGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGet</span><span class="params">(HttpGet get)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.get = get;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BasicCookieStore <span class="title function_">getCookieStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cookieStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCookieStore</span><span class="params">(BasicCookieStore cookieStore)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cookieStore = cookieStore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>接下来定义 WeiboLogin 类，在里面写入登录操作方法。首先需要实例化```eInfo:</p><p><code>private CookieInfo cookieInfo = new CookieInfo();</code></p></li><li><p>接下来设置 Cookie 登录策略，不设置的话微博会拒绝登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">WeiboLogin</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//Cookie策略，不设置会拒绝Cookie Rejected, 设置策略保存Cookie信息</span></span><br><span class="line">    cookieInfo.setCookieStore(<span class="keyword">new</span> <span class="title class_">BasicCookieStore</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">CookieSpecProvider</span> <span class="variable">myCookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CookieSpecProvider</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> CookieSpec <span class="title function_">create</span><span class="params">(HttpContext httpContext)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultCookieSpec</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Registry&lt;CookieSpecProvider&gt; rg = RegistryBuilder.&lt;CookieSpecProvider&gt;create().</span><br><span class="line">            register(<span class="string">&quot;myCookie&quot;</span>, myCookie).build();</span><br><span class="line"></span><br><span class="line">    cookieInfo.setClient(HttpClients.custom().setDefaultCookieSpecRegistry(rg).build());</span><br><span class="line">    cookieInfo.setGet(<span class="keyword">new</span> <span class="title class_">HttpGet</span>());</span><br><span class="line">    cookieInfo.setPost(<span class="keyword">new</span> <span class="title class_">HttpPost</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再写一个方法，将浏览器中刚才看到的”Request Headers”中的参数填入保存，同时加入一个输出语句，用于检验是否成功登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Login</span><span class="params">()</span> <span class="keyword">throws</span> ClientProtocolException, IOException, URISyntaxException&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">LoginUrl</span> <span class="operator">=</span> <span class="string">&quot;https://weibo.cn/?luicode=20000174&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加Request Header，用于模拟登陆</span></span><br><span class="line">        cookieInfo.getGet().setURI(<span class="keyword">new</span> <span class="title class_">URI</span>(LoginUrl));</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html; charset=utf-8&quot;</span>);</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;Host&quot;</span>, <span class="string">&quot;weibo.cn&quot;</span>);</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&quot;</span>);</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;API-RemoteIP&quot;</span>, <span class="string">&quot;192.168.0.1&quot;</span>);           <span class="comment">//模拟登录IP</span></span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>,<span class="string">&quot;192.168.0.1&quot;</span>);</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;CLIENT-IP&quot;</span>, <span class="string">&quot;192.168.0.1&quot;</span>);</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;</span>);</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;</span>);</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip, deflate, br&quot;</span>);</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot; https://passport.weibo.cn/signin/login?entry=mweibo&amp;r=https%3A%2F%2Fweibo.cn%2F%3Fluicode%3D20000174&amp;backTitle=%CE%A2%B2%A9&amp;vt=&quot;</span>);</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>);</span><br><span class="line">        cookieInfo.getGet().addHeader(<span class="string">&quot;Cookie&quot;</span>, <span class="string">&quot;自己的Cookie信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> cookieInfo.getClient().execute(cookieInfo.getGet());</span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将获取到的网页信息打印出来，检验是否登录成功</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> EntityUtils.toString(entity);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取的微博内容&quot;</span>+context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>最后新建 Test 类，写入 Main 主方法，调用 Login()方法即可。如果代码没有问题，那么到这里就能看到自己的首页源代码了。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java-通过-Cookie-模拟登录微博&quot;&gt;&lt;a href=&quot;#Java-通过-Cookie-模拟登录微博&quot; class=&quot;headerlink&quot; title=&quot;Java 通过 Cookie 模拟登录微博&quot;&gt;&lt;/a&gt;Java 通过 Cookie 模拟登录微博&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;笔者从开始了解到写出这篇博客一共只用了几天的时间，所以本文更适合小白参考&lt;br&gt;本文以 weibo.cn 为例，但只需修改 Request Header 中的部分参数，也可用与模拟登录 weibo.com&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="Java" scheme="https://something.plus/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>NAO学习——从NAOqi和rviz开始学习在ROS上运行NAO</title>
    <link href="https://something.plus/2018/08/07/Techniques/2018-08-07-run-naoqi-on-ros/"/>
    <id>https://something.plus/2018/08/07/Techniques/2018-08-07-run-naoqi-on-ros/</id>
    <published>2018-08-07T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NAO-学习——从-NAOqi-和-rviz-开始学习在-ROS-上运行-NAO"><a href="#NAO-学习——从-NAOqi-和-rviz-开始学习在-ROS-上运行-NAO" class="headerlink" title="NAO 学习——从 NAOqi 和 rviz 开始学习在 ROS 上运行 NAO"></a>NAO 学习——从 NAOqi 和 rviz 开始学习在 ROS 上运行 NAO</h1><h2 id="1-开始连接一个实体-NAO"><a href="#1-开始连接一个实体-NAO" class="headerlink" title="1. 开始连接一个实体 NAO"></a>1. 开始连接一个实体 NAO</h2><h3 id="1-1-运行-nao-bringup"><a href="#1-1-运行-nao-bringup" class="headerlink" title="1.1 运行 nao_bringup"></a>1.1 运行 nao_bringup</h3><p>在开始之前，我们首先要确定三个必须的依赖包 <em>naoqi_driver</em>，<em>naoqi_bridge</em> 和 <em>nao_description</em> 是否满足。这三个包可以通过包管理器或者从 github 上 clone。</p><span id="more"></span><p>为了运行<em>nao_bringup</em>， 需要执行下列命令：</p><p><code>$ roslaunch nao_bringup nao_full.launch nao_ip:=&lt;robot_ip&gt; roscore_ip:=&lt;roscore_ip&gt;</code></p><p>如果用的是 Python SDK，则需要执行：</p><p><code>$ roslaunch nao_bringup nao_full_py.launch nao_ip:=&lt;robot_ip&gt; roscore_ip:=&lt;roscore_ip&gt;</code></p><p><code>&lt;robot_ip&gt;</code>是 NAO 的地址，’<roscore_ip>‘是运行 roscore 的电脑 IP 地址。因为 roscore 并不是在 NAO 上运行的，所以用这两个参数来让 NAO 找到 roscore 运行的位置是很必要的。将这两个参数修改为正确的 IP 地址，以在 NAO 和电脑之间建立正确连接。</p><p>当 nao_bringup 成功运行之后，我们就可以打开 rviz 了。</p><h3 id="1-2-在-RVIZ-上显示-NAO"><a href="#1-2-在-RVIZ-上显示-NAO" class="headerlink" title="1.2 在 RVIZ 上显示 NAO"></a>1.2 在 RVIZ 上显示 NAO</h3><p>首先打开 RVIZ：</p><p><code>$ rosrun rviz rviz</code></p><p>ROS 上提供了一个预先设置好的 RVIZ 配置文件<em>urdf.rviz</em>，保存在<code>~/catkin_ws/src/nao_robot/nao_description/config/</code>下。</p><p>如果想要看到完整的 NAO 的 3D 模型，我们需要安装一个包：</p><p><code>$ sudo apt-get install ros-indigo-nao-meshes</code></p><p>在安装过程中，我们需要接受它的许可信息。安装完成后，重启一下 RVIZ。</p><h2 id="2-控制-NAO"><a href="#2-控制-NAO" class="headerlink" title="2. 控制 NAO"></a>2. 控制 NAO</h2><p>如果上面的步骤都成功了，我们这个时候就已经能在 RVIZ 中看见 NAO 了。</p><p>接下来我们将用 ROS 命令来控制 NAO。</p><p>首先执行<code>$ rosnode list</code>，我们应该能找到<code>/nao_walker</code>结点。这证明 NAO 的 walker 结点已经运行。</p><p>很重要的一点是，在开始控制实体 NAO 之前，需要先将其刚化：</p><p><code>$ rosservice call /body_stiffness/enable &quot;&#123;&#125;&quot;</code></p><p><strong>注</strong>：刚化之后，就不能再用手去移动 NAO 的关节。</p><p>若想解除刚化，则只需执行：</p><p><code>$ rosservice call /body_stiffness/disable &quot;&#123;&#125;&quot;</code></p><p>刚化之后，我们就可以向 NAO 发送一个行走的命令：</p><p><code>$ rostopic pub -1 /cmd_vel geometry_msgs/Twist &#39;&#123;linear: &#123;x: 1.0, y: 0.0, z: 0.0&#125;, angular: &#123;x: 0.0, y: 0.0, z: 0.0&#125;&#125;&#39;</code></p><p>这条指令将会使 NAO 不断沿 x 轴方向行走，每个循环都会走一米。</p><p>若需要停止，则只需将<em>linear</em>中的<code>x: 1.0</code>修改为<code>x: 0.0</code>：</p><p><code>$ rostopic pub -1 /cmd_vel geometry_msgs/Twist &#39;&#123;linear: &#123;x: 0.0, y: 0.0, z: 0.0&#125;, angular: &#123;x: 0.0, y: 0.0, z: 0.0&#125;&#125;&#39;</code></p><p>我们也可通过 ROS 一些已有的远程控制工具（如:<a href="http://wiki.ros.org/teleop_twist_keyboard">ROS telep</a>）来用键盘控制 NAO。</p><h2 id="3-在-ROS-上运行虚拟的-NAOqi"><a href="#3-在-ROS-上运行虚拟的-NAOqi" class="headerlink" title="3. 在 ROS 上运行虚拟的 NAOqi"></a>3. 在 ROS 上运行虚拟的 NAOqi</h2><h3 id="3-1-加载环境"><a href="#3-1-加载环境" class="headerlink" title="3.1 加载环境"></a>3.1 加载环境</h3><p>首先，需要确保 roscore 已经运行。</p><p>然后在一个新的终端中，输入下列指令来在本地电脑运行 NAOqi，以模拟出一个 NAO：</p><p><code>$ ~/naoqi/naoqi-sdk-1.12.3-linux32/naoqi --verbose --broker-ip 127.0.0.1</code></p><p>broker-ip 地址<code>127.0.0.1</code>是连接本地电脑的回路地址。只有在本地安装的 ROS 才能连接 NAOqi。NAOqi API 将可以通过 broker-ip 地址访问，而 nao_driver 将成为 NAOqi API 的包装器。</p><p>接下来在一个新的终端中加载<em>ros_driver</em>包，以连接本地的虚拟 NAO：</p><p><code>$ LD_LIBRARY_PATH=~/naoqi/naoqi-sdk-1.14.5-linux64/lib:$LD_LIBRARY_PATH NAO_IP=127.0.0.1 roslaunch naoqi_driver naoqi_driver.launch force_python:=true</code></p><p><strong>注</strong>：<a href="http://wiki.ros.org/nao/Tutorials/Getting-Started">ROS 官网上英文教程</a>中的这一指令貌似有错误，我用的是<a href="https://answers.ros.org/question/202319/blocked-on-the-install-tutorial-naoqi_driver-not-found/">ROS 论坛</a>中的解决方法。</p><p>如果运行成功，那么会看到与下列相似的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Walker online...</span><br><span class="line">.</span><br><span class="line">nao_controller running...</span><br></pre></td></tr></table></figure><p><strong>注</strong>：不要将这个路径添加到全局<em>LD_LIBRARY_PATH</em>中，不然可能会在运行其他程序时出错。</p><h3 id="3-2-在-RVIZ-中查看虚拟的-NAO"><a href="#3-2-在-RVIZ-中查看虚拟的-NAO" class="headerlink" title="3.2 在 RVIZ 中查看虚拟的 NAO"></a>3.2 在 RVIZ 中查看虚拟的 NAO</h3><p>首先退出之前所有正在运行的终端应用。</p><p>然后安装<em>rospack</em>：</p><p><code>$ sudo apt-get install ros-fuerte-rospack</code></p><p>再安装一些 ROS 的可视化工具：</p><p><code>$ sudo apt-get install ros-fuerte-visualization</code></p><p>接下来重新启动<em>roscore</em>、NAOqi 和 <em>nao_driver</em>。</p><p>现在我们需要启动 robot_state_publisher 并让其加载 NAO 的 URDF 模型：</p><p><code>$ roslaunch nao_description nao_state_publisher.launch</code></p><p>然后重新启动 RVIZ 即可。</p><p>在 RVIZ 中，将左部的”Displays”中的”Fixed Frame”修改为”/base_link”。若只有”/map”选项，则证明 URDF 模型没有成功加载。</p><p>右部的”Target Frame”应该是<code>&lt;Fixed Frame&gt;</code>。</p><p>运行第二节中行走命令，我们就能看到 RVIZ 中的 NAO 开始行走了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;NAO-学习——从-NAOqi-和-rviz-开始学习在-ROS-上运行-NAO&quot;&gt;&lt;a href=&quot;#NAO-学习——从-NAOqi-和-rviz-开始学习在-ROS-上运行-NAO&quot; class=&quot;headerlink&quot; title=&quot;NAO 学习——从 NAOqi 和 rviz 开始学习在 ROS 上运行 NAO&quot;&gt;&lt;/a&gt;NAO 学习——从 NAOqi 和 rviz 开始学习在 ROS 上运行 NAO&lt;/h1&gt;&lt;h2 id=&quot;1-开始连接一个实体-NAO&quot;&gt;&lt;a href=&quot;#1-开始连接一个实体-NAO&quot; class=&quot;headerlink&quot; title=&quot;1. 开始连接一个实体 NAO&quot;&gt;&lt;/a&gt;1. 开始连接一个实体 NAO&lt;/h2&gt;&lt;h3 id=&quot;1-1-运行-nao-bringup&quot;&gt;&lt;a href=&quot;#1-1-运行-nao-bringup&quot; class=&quot;headerlink&quot; title=&quot;1.1 运行 nao_bringup&quot;&gt;&lt;/a&gt;1.1 运行 nao_bringup&lt;/h3&gt;&lt;p&gt;在开始之前，我们首先要确定三个必须的依赖包 &lt;em&gt;naoqi_driver&lt;/em&gt;，&lt;em&gt;naoqi_bridge&lt;/em&gt; 和 &lt;em&gt;nao_description&lt;/em&gt; 是否满足。这三个包可以通过包管理器或者从 github 上 clone。&lt;/p&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="NAO" scheme="https://something.plus/tags/NAO/"/>
    
    <category term="Python" scheme="https://something.plus/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>NAO学习——在ROS上安装NAO</title>
    <link href="https://something.plus/2018/08/03/Techniques/2018-08-03-install-naoqi-ros/"/>
    <id>https://something.plus/2018/08/03/Techniques/2018-08-03-install-naoqi-ros/</id>
    <published>2018-08-03T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NAO-学习——在-ROS-上安装-NAO"><a href="#NAO-学习——在-ROS-上安装-NAO" class="headerlink" title="NAO 学习——在 ROS 上安装 NAO"></a>NAO 学习——在 ROS 上安装 NAO</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-配置-NAOqi"><a href="#1-1-配置-NAOqi" class="headerlink" title="1.1 配置 NAOqi"></a>1.1 配置 NAOqi</h3><pre><code>在从[Aldebaran Nao官网软件库](https://community.ald.softbankrobotics.com/en/resources/software)下载NAOqi SDK时，需要先注册账户</code></pre><span id="more"></span><p>不知道为什么，我们实验室中现在只能用 2.1.2 版本的 SDK，装其他的都会报错。各位读者可以自己尝试一下别的版本。<br>下载好之后，我们先解压压缩包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar xzf pynaoqi-python2.7-2.1.2.17-linux64.tar</span><br></pre></td></tr></table></figure><p>然后讲压缩包中的所有文件直接复制到 Python2.7 的 site-packages 文件中。<br>为了检验是否成功导入，我们可以运行 Python：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import naoqi</span><br></pre></td></tr></table></figure><p>若没有报错，则证明导入成功。<br><strong>注</strong>：也可按照<a href="http://wiki.ros.org/nao/Tutorials/Installation">ROS 官方教程</a>或<a href="http://doc.aldebaran.com/2-1/dev/python/install_guide.html">NAO 官方文档</a>来配置</p><h3 id="1-2-安装-NAO-机器人的-ROS-包"><a href="#1-2-安装-NAO-机器人的-ROS-包" class="headerlink" title="1.2 安装 NAO 机器人的 ROS 包"></a>1.2 安装 NAO 机器人的 ROS 包</h3><p>在 ROS 上连接 NAO 需要一些额外的包，安装如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-indigo-driver-base ros-indigo-move-base-msgs ros-indigo-octomap ros-indigo-octomap-msgs ros-indigo-humanoid-msgs ros-indigo-humanoid-nav-msgs ros-indigo-camera-info-manager ros-indigo-camera-info-manager-py</span><br></pre></td></tr></table></figure><p>如果只是想使用 RViz 或者其他支持的 ROS 工具，则只需要安装:<br><code>sudo apt-get install ros-indigo-nao-robot</code><br><strong>注</strong>：版本号 indigo 可以换成自己安装的版本（如：kinetic/hydro 等）</p><p>至此，我们就已基本配置完了 NAO 的环境。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;NAO-学习——在-ROS-上安装-NAO&quot;&gt;&lt;a href=&quot;#NAO-学习——在-ROS-上安装-NAO&quot; class=&quot;headerlink&quot; title=&quot;NAO 学习——在 ROS 上安装 NAO&quot;&gt;&lt;/a&gt;NAO 学习——在 ROS 上安装 NAO&lt;/h1&gt;&lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1. 安装&quot;&gt;&lt;/a&gt;1. 安装&lt;/h2&gt;&lt;h3 id=&quot;1-1-配置-NAOqi&quot;&gt;&lt;a href=&quot;#1-1-配置-NAOqi&quot; class=&quot;headerlink&quot; title=&quot;1.1 配置 NAOqi&quot;&gt;&lt;/a&gt;1.1 配置 NAOqi&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在从[Aldebaran Nao官网软件库](https://community.ald.softbankrobotics.com/en/resources/software)下载NAOqi SDK时，需要先注册账户
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="NAO" scheme="https://something.plus/tags/NAO/"/>
    
    <category term="Python" scheme="https://something.plus/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>NAO学习——ROS的安装</title>
    <link href="https://something.plus/2018/08/03/Techniques/2018-08-03-install-ros/"/>
    <id>https://something.plus/2018/08/03/Techniques/2018-08-03-install-ros/</id>
    <published>2018-08-03T02:14:29.000Z</published>
    <updated>2022-05-13T07:00:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nao-学习——ROS-的安装"><a href="#Nao-学习——ROS-的安装" class="headerlink" title="Nao 学习——ROS 的安装"></a>Nao 学习——ROS 的安装</h1><p>搬运自<a href="http://wiki.ros.org/cn/kinetic/Installation/Ubuntu">在 Ubuntu 中安装 ROS Kinetic</a></p><span id="more"></span><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><pre><code>ROS Kinetic 只 支持Wily (Ubuntu 15.10), Xenial (Ubuntu 16.04) 和Jessie (Debian 8) 的debian包。</code></pre><h3 id="1-1-配置-Ubuntu-软件仓库"><a href="#1-1-配置-Ubuntu-软件仓库" class="headerlink" title="1.1 配置 Ubuntu 软件仓库"></a>1.1 配置 Ubuntu 软件仓库</h3><pre><code>配置你Ubuntu 软件仓库(repositories) 以允许 &quot;restricted&quot;、&quot;universe&quot; 和 &quot;multiverse&quot;这三种安装模式</code></pre><h3 id="1-2-添加-sources-list"><a href="#1-2-添加-sources-list" class="headerlink" title="1.2 添加 sources.list"></a>1.2 添加 sources.list</h3><p><code>sudo sh -c &#39;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;</code></p><p><strong>注：</strong>强烈建议使用国内或者新加波的镜像源，这样能够大大提高安装下载速度。</p><h3 id="1-3-添加-keys"><a href="#1-3-添加-keys" class="headerlink" title="1.3 添加 keys"></a>1.3 添加 keys</h3><p><code>sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</code></p><h3 id="1-4-安装"><a href="#1-4-安装" class="headerlink" title="1.4 安装"></a>1.4 安装</h3><p>首先，确保你的 Debian 软件包索引是最新的：<br><code>sudo apt-get update</code><br>在 ROS 中，有很多不同的库和工具，官方提供了四种默认的配置：</p><ul><li><strong>桌面完整版: (推荐</strong>) : 包含 ROS、rqt、rviz、机器人通用库、2D/3D 模拟器、导航以及 2D/3D 感知<br><code>sudo apt-get install ros-kinetic-desktop-full</code></li><li><p><strong>桌面版安装</strong>: 包含 ROS、rqt、rviz 以及通用机器人函数库。<br><code>sudo apt-get install ros-kinetic-desktop</code></p></li><li><p><strong> 基础版安装: (简版</strong>) 包含 ROS 核心软件包、构建工具以及通信相关的程序库，无 GUI 工具。<br><code>sudo apt-get install ros-kinetic-ros-base</code></p></li><li><p><strong>单个软件包安装</strong>: 你也可以安装某个指定的 ROS 软件包（使用软件包名称替换掉下面的 PACKAGE）:<br><code>sudo apt-get install ros-kinetic-PACKAGE</code></p></li></ul><p>要查找可用软件包，请运行：<code>apt-cache search ros-kinetic</code></p><h3 id="1-5-初始化-rosdep"><a href="#1-5-初始化-rosdep" class="headerlink" title="1.5 初始化 rosdep"></a>1.5 初始化 rosdep</h3><p>在开始使用 ROS 之前你还需要初始化 rosdep。rosdep 可以方便在你需要编译某些源码的时候为其安装一些系统依赖，同时也是某些 ROS 核心功能组件所必需用到的工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><h3 id="1-6-环境配置"><a href="#1-6-环境配置" class="headerlink" title="1.6 环境配置"></a>1.6 环境配置</h3><p>如果每次打开一个新的终端时 ROS 环境变量都能够自动配置好（即添加到 bash 会话中），那将会方便很多：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>如果你安装有多个 ROS 版本, ~/.bashrc 必须只能 source 你当前使用版本所对应的 setup.bash。<br>如果你只想改变当前终端下的环境变量，可以执行以下命令：</p><p><code>source /opt/ros/kinetic/setup.bash</code></p><p>如果你使用 zsh，替换其中的 bash， 可以用以下命令来设置 shell:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/kinetic/setup.zsh&quot; &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="1-7-构建工厂依赖"><a href="#1-7-构建工厂依赖" class="headerlink" title="1.7 构建工厂依赖"></a>1.7 构建工厂依赖</h3><p>到目前为止，已经安装了运行核心 ROS 包所需的内容。为了创建和管理自己的 ROS 工作区，有各种各样的工具和需求分别分布。例如：rosinstall 是一个经常使用的命令行工具，它使你能够轻松地从一个命令下载许多 ROS 包的源树。</p><p>要安装这个工具和其他构建 ROS 包的依赖项，请运行:</p><p><code>sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Nao-学习——ROS-的安装&quot;&gt;&lt;a href=&quot;#Nao-学习——ROS-的安装&quot; class=&quot;headerlink&quot; title=&quot;Nao 学习——ROS 的安装&quot;&gt;&lt;/a&gt;Nao 学习——ROS 的安装&lt;/h1&gt;&lt;p&gt;搬运自&lt;a href=&quot;http://wiki.ros.org/cn/kinetic/Installation/Ubuntu&quot;&gt;在 Ubuntu 中安装 ROS Kinetic&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Techniques" scheme="https://something.plus/categories/Techniques/"/>
    
    
    <category term="NAO" scheme="https://something.plus/tags/NAO/"/>
    
    <category term="Python" scheme="https://something.plus/tags/Python/"/>
    
  </entry>
  
</feed>
